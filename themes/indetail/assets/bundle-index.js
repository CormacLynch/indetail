/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(_x3, _x4, _x5) {
  var _again = true;_function: while (_again) {
    var object = _x3,
        property = _x4,
        receiver = _x5;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        _x3 = parent;_x4 = property;_x5 = receiver;_again = true;desc = parent = undefined;continue _function;
      }
    } else if ('value' in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  }
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(7);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(8);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _baseStyles = __webpack_require__(37);

var _baseStyles2 = _interopRequireDefault(_baseStyles);

var _BurgerIcon = __webpack_require__(38);

var _BurgerIcon2 = _interopRequireDefault(_BurgerIcon);

var _CrossIcon = __webpack_require__(39);

var _CrossIcon2 = _interopRequireDefault(_CrossIcon);

exports['default'] = function (styles) {
  var Menu = function (_Component) {
    _inherits(Menu, _Component);

    function Menu(props) {
      _classCallCheck(this, Menu);

      _get(Object.getPrototypeOf(Menu.prototype), 'constructor', this).call(this, props);
      this.state = {
        isOpen: false
      };
    }

    _createClass(Menu, [{
      key: 'toggleMenu',
      value: function toggleMenu() {
        var _this = this;

        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var isOpen = options.isOpen;
        var noStateChange = options.noStateChange;

        var newState = {
          isOpen: typeof isOpen !== 'undefined' ? isOpen : !this.state.isOpen
        };

        this.applyWrapperStyles();

        this.setState(newState, function () {
          !noStateChange && _this.props.onStateChange(newState);

          // Timeout ensures wrappers are cleared after animation finishes.
          _this.timeoutId && clearTimeout(_this.timeoutId);
          _this.timeoutId = setTimeout(function () {
            _this.timeoutId = null;
            if (!newState.isOpen) {
              _this.applyWrapperStyles(false);
            }
          }, 500);
        });
      }

      // Applies component-specific styles to external wrapper elements.
    }, {
      key: 'applyWrapperStyles',
      value: function applyWrapperStyles() {
        var set = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        if (this.props.bodyClassName) {
          var body = document.querySelector('body');
          body.classList[set ? 'add' : 'remove'](this.props.bodyClassName);
        }

        if (styles.pageWrap && this.props.pageWrapId) {
          this.handleExternalWrapper(this.props.pageWrapId, styles.pageWrap, set);
        }

        if (styles.outerContainer && this.props.outerContainerId) {
          this.handleExternalWrapper(this.props.outerContainerId, styles.outerContainer, set);
        }
      }

      // Sets or unsets styles on DOM elements outside the menu component.
      // This is necessary for correct page interaction with some of the menus.
      // Throws and returns if the required external elements don't exist,
      // which means any external page animations won't be applied.
    }, {
      key: 'handleExternalWrapper',
      value: function handleExternalWrapper(id, wrapperStyles, set) {
        var html = document.querySelector('html');
        var body = document.querySelector('body');
        var wrapper = document.getElementById(id);

        if (!wrapper) {
          console.error("Element with ID '" + id + "' not found");
          return;
        }

        var builtStyles = this.getStyle(wrapperStyles);

        for (var prop in builtStyles) {
          if (builtStyles.hasOwnProperty(prop)) {
            wrapper.style[prop] = set ? builtStyles[prop] : '';
          }
        }

        // Prevent any horizontal scroll.
        [html, body].forEach(function (element) {
          element.style['overflow-x'] = set ? 'hidden' : '';
        });
      }

      // Builds styles incrementally for a given element.
    }, {
      key: 'getStyles',
      value: function getStyles(el, index, inline) {
        var propName = 'bm' + el.replace(el.charAt(0), el.charAt(0).toUpperCase());

        // Set base styles.
        var output = _baseStyles2['default'][el] ? this.getStyle(_baseStyles2['default'][el]) : {};

        // Add animation-specific styles.
        if (styles[el]) {
          output = _extends({}, output, this.getStyle(styles[el], index + 1));
        }

        // Add custom styles.
        if (this.props.styles[propName]) {
          output = _extends({}, output, this.props.styles[propName]);
        }

        // Add element inline styles.
        if (inline) {
          output = _extends({}, output, inline);
        }

        return output;
      }
    }, {
      key: 'getStyle',
      value: function getStyle(style, index) {
        var width = this.props.width;
        if (typeof width !== 'string') width = width + 'px';

        return style(this.state.isOpen, width, this.props.right, index);
      }
    }, {
      key: 'listenForClose',
      value: function listenForClose(e) {
        e = e || window.event;

        if (this.state.isOpen && (e.key === 'Escape' || e.keyCode === 27)) {
          this.toggleMenu();
        }
      }
    }, {
      key: 'shouldDisableOverlayClick',
      value: function shouldDisableOverlayClick() {
        if (typeof this.props.disableOverlayClick === 'function') {
          return this.props.disableOverlayClick();
        } else {
          return this.props.disableOverlayClick;
        }
      }
    }, {
      key: 'componentWillMount',
      value: function componentWillMount() {
        if (!styles) {
          throw new Error('No styles supplied');
        }
      }
    }, {
      key: 'componentDidMount',
      value: function componentDidMount() {
        window.onkeydown = this.listenForClose.bind(this);

        // Allow initial open state to be set by props.
        if (this.props.isOpen) {
          this.toggleMenu({ isOpen: true, noStateChange: true });
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        window.onkeydown = null;

        this.applyWrapperStyles(false);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var _this2 = this;

        if (styles.svg) {
          (function () {
            var morphShape = _reactDom2['default'].findDOMNode(_this2, 'bm-morph-shape');
            var path = styles.svg.lib(morphShape).select('path');

            if (_this2.state.isOpen) {
              // Animate SVG path.
              styles.svg.animate(path);
            } else {
              // Reset path (timeout ensures animation happens off screen).
              setTimeout(function () {
                path.attr('d', styles.svg.pathInitial);
              }, 300);
            }
          })();
        }
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (typeof nextProps.isOpen !== 'undefined' && nextProps.isOpen !== this.state.isOpen) {
          this.toggleMenu();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _this3 = this;

        return _react2['default'].createElement('div', null, !this.props.noOverlay && _react2['default'].createElement('div', {
          className: 'bm-overlay ' + this.props.overlayClassName,
          onClick: function onClick() {
            return !_this3.shouldDisableOverlayClick() && _this3.toggleMenu();
          },
          style: this.getStyles('overlay')
        }), _react2['default'].createElement('div', {
          id: this.props.id,
          className: 'bm-menu-wrap ' + this.props.className,
          style: this.getStyles('menuWrap')
        }, styles.svg && _react2['default'].createElement('div', { className: 'bm-morph-shape ' + this.props.morphShapeClassName, style: this.getStyles('morphShape') }, _react2['default'].createElement('svg', { width: '100%', height: '100%', viewBox: '0 0 100 800', preserveAspectRatio: 'none' }, _react2['default'].createElement('path', { d: styles.svg.pathInitial }))), _react2['default'].createElement('div', { className: 'bm-menu ' + this.props.menuClassName, style: this.getStyles('menu') }, _react2['default'].createElement('nav', { className: 'bm-item-list ' + this.props.itemListClassName, style: this.getStyles('itemList') }, _react2['default'].Children.map(this.props.children, function (item, index) {
          if (item) {
            var extraProps = {
              key: index,
              style: _this3.getStyles('item', index, item.props.style)
            };
            return _react2['default'].cloneElement(item, extraProps);
          }
        }))), this.props.customCrossIcon !== false && _react2['default'].createElement('div', { style: this.getStyles('closeButton') }, _react2['default'].createElement(_CrossIcon2['default'], {
          onClick: function onClick() {
            return _this3.toggleMenu();
          },
          styles: this.props.styles,
          customIcon: this.props.customCrossIcon,
          className: this.props.crossButtonClassName,
          crossClassName: this.props.crossClassName
        }))), this.props.customBurgerIcon !== false && _react2['default'].createElement('div', { style: this.getStyles('burgerIcon') }, _react2['default'].createElement(_BurgerIcon2['default'], {
          onClick: function onClick() {
            return _this3.toggleMenu();
          },
          styles: this.props.styles,
          customIcon: this.props.customBurgerIcon,
          className: this.props.burgerButtonClassName,
          barClassName: this.props.burgerBarClassName
        })));
      }
    }]);

    return Menu;
  }(_react.Component);

  Menu.propTypes = {
    bodyClassName: _propTypes2['default'].string,
    burgerBarClassName: _propTypes2['default'].string,
    burgerButtonClassName: _propTypes2['default'].string,
    crossButtonClassName: _propTypes2['default'].string,
    crossClassName: _propTypes2['default'].string,
    customBurgerIcon: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].oneOf([false])]),
    customCrossIcon: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].oneOf([false])]),
    disableOverlayClick: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].func]),
    id: _propTypes2['default'].string,
    isOpen: _propTypes2['default'].bool,
    itemListClassName: _propTypes2['default'].string,
    menuClassName: _propTypes2['default'].string,
    morphShapeClassName: _propTypes2['default'].string,
    noOverlay: _propTypes2['default'].bool,
    onStateChange: _propTypes2['default'].func,
    outerContainerId: styles && styles.outerContainer ? _propTypes2['default'].string.isRequired : _propTypes2['default'].string,
    overlayClassName: _propTypes2['default'].string,
    pageWrapId: styles && styles.pageWrap ? _propTypes2['default'].string.isRequired : _propTypes2['default'].string,
    right: _propTypes2['default'].bool,
    styles: _propTypes2['default'].object,
    width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string])
  };

  Menu.defaultProps = {
    bodyClassName: '',
    burgerBarClassName: '',
    burgerButtonClassName: '',
    className: '',
    crossButtonClassName: '',
    crossClassName: '',
    id: '',
    itemListClassName: '',
    menuClassName: '',
    morphShapeClassName: '',
    noOverlay: false,
    onStateChange: function onStateChange() {},
    outerContainerId: '',
    overlayClassName: '',
    pageWrapId: '',
    styles: {},
    width: 300
  };

  return Menu;
};

module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = __webpack_require__(19);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (true) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(2);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (true) {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (true) {
  var invariant = __webpack_require__(3);
  var warning = __webpack_require__(4);
  var ReactPropTypesSecret = __webpack_require__(10);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = require('./cjs/react-dom.production.min.js');
} else {
  module.exports = __webpack_require__(20);
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(36)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (true) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

exports['default'] = function () {
  var Snap = undefined;
  try {
    Snap = __webpack_require__(42);
  } finally {
    return Snap;
  }
};

module.exports = exports['default'];

/***/ }),
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(18);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(7);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _mobileMenu = __webpack_require__(33);

var _mobileMenu2 = _interopRequireDefault(_mobileMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.addEventListener('DOMContentLoaded', function () {
	var menuElement = document.querySelector('[data-menu]');

	if (menuElement) {
		_reactDom2.default.render(_react2.default.createElement(_mobileMenu2.default, { pageWrapId: "page-wrap", outerContainerId: "outer-container" }), menuElement);
	}
});

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (true) {
  (function () {
    'use strict';

    var _assign = __webpack_require__(5);
    var emptyObject = __webpack_require__(9);
    var invariant = __webpack_require__(3);
    var warning = __webpack_require__(4);
    var emptyFunction = __webpack_require__(2);
    var checkPropTypes = __webpack_require__(6);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.2.0';

    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }
      return null;
    }

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;
          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }
        }
      }

      if (invokeCallback) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var propTypesMisspellWarningShown = false;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;
      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      Fragment: REACT_FRAGMENT_TYPE,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(true){(function(){'use strict';var React=__webpack_require__(1);var invariant=__webpack_require__(3);var warning=__webpack_require__(4);var ExecutionEnvironment=__webpack_require__(21);var _assign=__webpack_require__(5);var emptyFunction=__webpack_require__(2);var EventListener=__webpack_require__(22);var getActiveElement=__webpack_require__(23);var shallowEqual=__webpack_require__(24);var containsNode=__webpack_require__(25);var focusNode=__webpack_require__(28);var emptyObject=__webpack_require__(9);var checkPropTypes=__webpack_require__(6);var hyphenateStyleName=__webpack_require__(29);var camelizeStyleName=__webpack_require__(31);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
autoFocus:HAS_BOOLEAN_VALUE,autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_OVERLOADED_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode$$1=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback...)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new *//* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and named imports.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;// Invoke setState callback an extra time to help detect side-effects.
if(debugRenderPhaseSideEffects){updateFn.call(instance,prevState,props);}return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.shouldComponentUpdate(newProps,newState,newContext);}{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){warning(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){warning(_typeof(workInProgress.type.childContextTypes)==='object','%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',getComponentName(workInProgress));}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillMount();}if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillReceiveProps(newProps,newContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillUpdate(newProps,newState,newContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol['for'];var REACT_ELEMENT_TYPE=hasSymbol?Symbol['for']('react.element'):0xeac7;var REACT_CALL_TYPE=hasSymbol?Symbol['for']('react.call'):0xeac8;var REACT_RETURN_TYPE=hasSymbol?Symbol['for']('react.return'):0xeac9;var REACT_PORTAL_TYPE=hasSymbol?Symbol['for']('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol['for']('react.fragment'):0xeacb;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted  the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work  work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,cancelDeferredCallback=config.cancelDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary - we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
var suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function checkRootNeedsClearing(root,fiber,expirationTime){if(!isWorking&&root===nextRoot&&expirationTime<nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;checkRootNeedsClearing(root,fiber,expirationTime);requestWork(root,expirationTime);checkRootNeedsClearing(root,fiber,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=-1;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
cancelDeferredCallback(callbackID);}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.
var currentMs=now()-startTime;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else{scheduleCallbackWithExpiration(expirationTime);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadline.
findHighestPriorityRoot();if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();stopRequestCallbackTimer(didExpire);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=-1;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.2.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;var cIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){return setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});};cIC=function cIC(timeoutID){clearTimeout(timeoutID);};}else if(typeof requestIdleCallback!=='function'||typeof cancelIdleCallback!=='function'){// Polyfill requestIdleCallback and cancelIdleCallback
var scheduledRICCallback=null;var isIdleScheduled=false;var timeoutTime=-1;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
var remaining=frameDeadline-performance.now();return remaining>0?remaining:0;}};}else{frameDeadlineObject={didTimeout:false,timeRemaining:function timeRemaining(){// Fallback to Date.now()
var remaining=frameDeadline-Date.now();return remaining>0?remaining:0;}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var currentTime=now();if(frameDeadline-currentTime<=0){// There's no time left in this idle period. Check if the callback has
// a timeout and whether it's been exceeded.
if(timeoutTime!==-1&&timeoutTime<=currentTime){// Exceeded the timeout. Invoke the callback even though there's no
// time left.
frameDeadlineObject.didTimeout=true;}else{// No timeout.
if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}// Exit without invoking the callback.
return;}}else{// There's still time left in this idle period.
frameDeadlineObject.didTimeout=false;}timeoutTime=-1;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback,options){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now()+options.timeout;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};cIC=function cIC(){scheduledRICCallback=null;isIdleScheduled=false;timeoutTime=-1;};}else{rIC=window.requestIdleCallback;cIC=window.cancelIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value,canUseEventSystem){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,cancelDeferredCallback:cIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(2);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (true) {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(26);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(27);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(30);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(32);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(7);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactBurgerMenu = __webpack_require__(34);

var _navUrls = __webpack_require__(51);

var _navUrls2 = _interopRequireDefault(_navUrls);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var navUrls = (0, _navUrls2.default)();
var mobileWidth = 769;

var MobileMenu = function (_Component) {
	_inherits(MobileMenu, _Component);

	function MobileMenu() {
		_classCallCheck(this, MobileMenu);

		var _this = _possibleConstructorReturn(this, (MobileMenu.__proto__ || Object.getPrototypeOf(MobileMenu)).call(this));

		_this.state = {
			shouldMenuRender: window.innerWidth < mobileWidth,
			isOpen: false
		};
		return _this;
	}

	_createClass(MobileMenu, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			window.addEventListener('resize', function (e) {
				_this2.setState({
					shouldMenuRender: window.innerWidth < mobileWidth
				});
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (!this.state.shouldMenuRender) {
				return false;
			}

			var styles = {
				bmBurgerButton: {
					zIndex: 10,
					position: 'absolute',
					width: '36px',
					height: '23px',
					right: '20px',
					top: '22px'
				},
				bmBurgerBars: {
					background: '#fff',
					height: '4px'
				},
				bmCrossButton: {
					height: '35px',
					width: '35px',
					right: '22px',
					top: '16px'
				},
				bmCross: {
					background: '#fff',
					height: '30px',
					width: '5px'
				},
				bmMenuWrap: {
					zIndex: 15
				},
				bmMenu: {
					background: 'rgba(0, 0, 0, 0.8)',
					padding: '2.5em 1.5em 0',
					fontSize: '1.15em'
				},
				bmMorphShape: {
					fill: '#373a47'
				},
				bmItemList: {
					color: '#b8b7ad',
					padding: '0.8em',
					textAlign: 'center'
				},
				bmOverlay: {
					background: 'rgba(0, 0, 0, 0.3)'
				}
			};

			var isMenuOpen = function isMenuOpen(state) {
				_this3.setState({
					isOpen: state.isOpen
				});
			};

			return _react2.default.createElement(
				_reactBurgerMenu.slide,
				{ right: true, styles: styles, onStateChange: isMenuOpen },
				_react2.default.createElement(
					'a',
					{ className: 'menu-item', href: '/' },
					'Home'
				),
				navUrls.map(function (navUrl, index) {
					return _react2.default.createElement(
						'a',
						{ key: index, className: 'menu-item', href: navUrl.href },
						navUrl.text
					);
				})
			);
		}
	}]);

	return MobileMenu;
}(_react.Component);

exports.default = MobileMenu;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});
exports['default'] = {
  slide: __webpack_require__(35),
  stack: __webpack_require__(40),
  elastic: __webpack_require__(41),
  bubble: __webpack_require__(44),
  push: __webpack_require__(45),
  pushRotate: __webpack_require__(46),
  scaleDown: __webpack_require__(47),
  scaleRotate: __webpack_require__(48),
  fallDown: __webpack_require__(49),
  reveal: __webpack_require__(50)
};
module.exports = exports['default'];

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(2);
var invariant = __webpack_require__(3);
var warning = __webpack_require__(4);
var assign = __webpack_require__(5);

var ReactPropTypesSecret = __webpack_require__(10);
var checkPropTypes = __webpack_require__(6);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});
var styles = {

  overlay: function overlay(isOpen) {
    return {
      position: 'fixed',
      zIndex: 1,
      width: '100%',
      height: '100%',
      background: 'rgba(0, 0, 0, 0.3)',
      opacity: isOpen ? 1 : 0,
      MozTransform: isOpen ? '' : 'translate3d(100%, 0, 0)',
      MsTransform: isOpen ? '' : 'translate3d(100%, 0, 0)',
      OTransform: isOpen ? '' : 'translate3d(100%, 0, 0)',
      WebkitTransform: isOpen ? '' : 'translate3d(100%, 0, 0)',
      transform: isOpen ? '' : 'translate3d(100%, 0, 0)',
      transition: isOpen ? 'opacity 0.3s' : 'opacity 0.3s, transform 0s 0.3s'
    };
  },

  menuWrap: function menuWrap(isOpen, width, right) {
    return {
      position: 'fixed',
      right: right ? 0 : 'inherit',
      zIndex: 2,
      width: width,
      height: '100%',
      MozTransform: isOpen ? '' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transition: 'all 0.5s'
    };
  },

  menu: function menu() {
    return {
      height: '100%',
      boxSizing: 'border-box',
      overflow: 'auto'
    };
  },

  itemList: function itemList() {
    return {
      height: '100%'
    };
  },

  item: function item() {
    return {
      display: 'block',
      outline: 'none'
    };
  },

  burgerIcon: function burgerIcon(isOpen, width, right) {
    return {};
  }

};

exports['default'] = styles;
module.exports = exports['default'];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(_x, _x2, _x3) {
  var _again = true;_function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
      }
    } else if ('value' in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  }
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(8);

var _propTypes2 = _interopRequireDefault(_propTypes);

var BurgerIcon = function (_Component) {
  _inherits(BurgerIcon, _Component);

  function BurgerIcon(props) {
    _classCallCheck(this, BurgerIcon);

    _get(Object.getPrototypeOf(BurgerIcon.prototype), 'constructor', this).call(this, props);
    this.state = {
      hover: false
    };
  }

  _createClass(BurgerIcon, [{
    key: 'getLineStyle',
    value: function getLineStyle(index) {
      return {
        position: 'absolute',
        height: '20%',
        left: 0,
        right: 0,
        top: 20 * (index * 2) + '%',
        opacity: this.state.hover ? 0.6 : 1
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _this = this;

      var icon = undefined;
      var buttonStyle = {
        position: 'absolute',
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        margin: 0,
        padding: 0,
        border: 'none',
        opacity: 0,
        fontSize: 8,
        cursor: 'pointer'
      };

      if (this.props.customIcon) {
        var extraProps = {
          className: 'bm-icon',
          style: _extends({ width: '100%', height: '100%' }, this.props.styles.bmIcon)
        };
        icon = _react2['default'].cloneElement(this.props.customIcon, extraProps);
      } else {
        icon = _react2['default'].createElement('span', null, [0, 1, 2].map(function (bar) {
          return _react2['default'].createElement('span', {
            key: bar,
            className: 'bm-burger-bars ' + _this.props.barClassName,
            style: _extends({}, _this.getLineStyle(bar), _this.props.styles.bmBurgerBars)
          });
        }));
      }

      return _react2['default'].createElement('div', {
        className: 'bm-burger-button ' + this.props.className,
        style: _extends({ zIndex: 1 }, this.props.styles.bmBurgerButton)
      }, icon, _react2['default'].createElement('button', {
        onClick: this.props.onClick,
        onMouseOver: function onMouseOver() {
          return _this.setState({ hover: true });
        },
        onMouseOut: function onMouseOut() {
          return _this.setState({ hover: false });
        },
        style: buttonStyle
      }, 'Open Menu'));
    }
  }]);

  return BurgerIcon;
}(_react.Component);

exports['default'] = BurgerIcon;

BurgerIcon.propTypes = {
  barClassName: _propTypes2['default'].string,
  customIcon: _propTypes2['default'].element,
  styles: _propTypes2['default'].object
};

BurgerIcon.defaultProps = {
  barClassName: '',
  className: '',
  styles: {}
};
module.exports = exports['default'];

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(_x, _x2, _x3) {
  var _again = true;_function: while (_again) {
    var object = _x,
        property = _x2,
        receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);if (parent === null) {
        return undefined;
      } else {
        _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
      }
    } else if ('value' in desc) {
      return desc.value;
    } else {
      var getter = desc.get;if (getter === undefined) {
        return undefined;
      }return getter.call(receiver);
    }
  }
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function');
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var _react = __webpack_require__(1);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(8);

var _propTypes2 = _interopRequireDefault(_propTypes);

var CrossIcon = function (_Component) {
  _inherits(CrossIcon, _Component);

  function CrossIcon() {
    _classCallCheck(this, CrossIcon);

    _get(Object.getPrototypeOf(CrossIcon.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CrossIcon, [{
    key: 'getCrossStyle',
    value: function getCrossStyle(type) {
      return {
        position: 'absolute',
        width: 3,
        height: 14,
        transform: type === 'before' ? 'rotate(45deg)' : 'rotate(-45deg)'
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _this = this;

      var icon;
      var buttonWrapperStyle = {
        position: 'absolute',
        width: 24,
        height: 24,
        right: 8,
        top: 8
      };
      var buttonStyle = {
        position: 'absolute',
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        margin: 0,
        padding: 0,
        border: 'none',
        textIndent: -9999,
        background: 'transparent',
        outline: 'none',
        cursor: 'pointer'
      };

      if (this.props.customIcon) {
        var extraProps = {
          className: 'bm-cross',
          style: _extends({ width: '100%', height: '100%' }, this.props.styles.bmCross)
        };
        icon = _react2['default'].cloneElement(this.props.customIcon, extraProps);
      } else {
        icon = _react2['default'].createElement('span', { style: { position: 'absolute', top: '6px', right: '14px' } }, ['before', 'after'].map(function (type, i) {
          return _react2['default'].createElement('span', {
            key: i,
            className: 'bm-cross ' + _this.props.crossClassName,
            style: _extends({}, _this.getCrossStyle(type), _this.props.styles.bmCross)
          });
        }));
      }

      return _react2['default'].createElement('div', {
        className: 'bm-cross-button ' + this.props.className,
        style: _extends({}, buttonWrapperStyle, this.props.styles.bmCrossButton)
      }, icon, _react2['default'].createElement('button', { onClick: this.props.onClick, style: buttonStyle }, 'Close Menu'));
    }
  }]);

  return CrossIcon;
}(_react.Component);

exports['default'] = CrossIcon;

CrossIcon.propTypes = {
  crossClassName: _propTypes2['default'].string,
  customIcon: _propTypes2['default'].element,
  styles: _propTypes2['default'].object
};

CrossIcon.defaultProps = {
  crossClassName: '',
  className: '',
  styles: {}
};
module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  menuWrap: function menuWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transition: isOpen ? 'transform 0.8s cubic-bezier(0.7, 0, 0.3, 1)' : 'transform 0.4s cubic-bezier(0.7, 0, 0.3, 1)'
    };
  },

  item: function item(isOpen, width, right, nthChild) {
    return {
      MozTransform: isOpen ? '' : 'translate3d(0, ' + nthChild * 500 + 'px, 0)',
      MsTransform: isOpen ? '' : 'translate3d(0, ' + nthChild * 500 + 'px, 0)',
      OTransform: isOpen ? '' : 'translate3d(0, ' + nthChild * 500 + 'px, 0)',
      WebkitTransform: isOpen ? '' : 'translate3d(0, ' + nthChild * 500 + 'px, 0)',
      transform: isOpen ? '' : 'translate3d(0, ' + nthChild * 500 + 'px, 0)',
      transition: isOpen ? 'transform 0.8s cubic-bezier(0.7, 0, 0.3, 1)' : 'transform 0s 0.2s cubic-bezier(0.7, 0, 0.3, 1)'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _snapsvgImporter = __webpack_require__(11);

var _snapsvgImporter2 = _interopRequireDefault(_snapsvgImporter);

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  svg: {
    lib: _snapsvgImporter2['default'],
    pathInitial: 'M-1,0h101c0,0-97.833,153.603-97.833,396.167C2.167,627.579,100,800,100,800H-1V0z',
    pathOpen: 'M-1,0h101c0,0,0-1,0,395c0,404,0,405,0,405H-1V0z',
    animate: function animate(path) {
      path.animate({ path: this.pathOpen }, 400, window.mina.easeinout);
    }
  },

  morphShape: function morphShape(isOpen, width, right) {
    return {
      position: 'absolute',
      width: 120,
      height: '100%',
      right: right ? 'inherit' : 0,
      left: right ? 0 : 'inherit',
      MozTransform: right ? 'rotateY(180deg)' : '',
      MsTransform: right ? 'rotateY(180deg)' : '',
      OTransform: right ? 'rotateY(180deg)' : '',
      WebkitTransform: right ? 'rotateY(180deg)' : '',
      transform: right ? 'rotateY(180deg)' : ''
    };
  },

  menuWrap: function menuWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      MsTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      OTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      WebkitTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transition: 'all 0.3s'
    };
  },

  menu: function menu(isOpen, width, right) {
    return {
      position: 'fixed',
      right: right ? 0 : 'inherit',
      width: 180,
      whiteSpace: 'nowrap',
      boxSizing: 'border-box',
      overflow: 'visible'
    };
  },

  itemList: function itemList(isOpen, width, right) {
    if (right) {
      return {
        position: 'relative',
        left: '-110px',
        width: '170%',
        overflow: 'auto'
      };
    }
  },

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, 0)' : 'translate3d(100px, 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, 0)' : 'translate3d(100px, 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, 0)' : 'translate3d(100px, 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, 0)' : 'translate3d(100px, 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(-100px, 0, 0)' : 'translate3d(100px, 0, 0)',
      transition: isOpen ? 'all 0.3s' : 'all 0.3s 0.1s'
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

window.eve = __webpack_require__(43);

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var mina = function (eve) {
    var animations = {},
        requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        setTimeout(callback, 16, new Date().getTime());
        return true;
    },
        requestID,
        isArray = Array.isArray || function (a) {
        return a instanceof Array || Object.prototype.toString.call(a) == "[object Array]";
    },
        idgen = 0,
        idprefix = "M" + (+new Date()).toString(36),
        ID = function ID() {
        return idprefix + (idgen++).toString(36);
    },
        diff = function diff(a, b, A, B) {
        if (isArray(a)) {
            res = [];
            for (var i = 0, ii = a.length; i < ii; i++) {
                res[i] = diff(a[i], b, A[i], B);
            }
            return res;
        }
        var dif = (A - a) / (B - b);
        return function (bb) {
            return a + dif * (bb - b);
        };
    },
        timer = Date.now || function () {
        return +new Date();
    },
        sta = function sta(val) {
        var a = this;
        if (val == null) {
            return a.s;
        }
        var ds = a.s - val;
        a.b += a.dur * ds;
        a.B += a.dur * ds;
        a.s = val;
    },
        speed = function speed(val) {
        var a = this;
        if (val == null) {
            return a.spd;
        }
        a.spd = val;
    },
        duration = function duration(val) {
        var a = this;
        if (val == null) {
            return a.dur;
        }
        a.s = a.s * val / a.dur;
        a.dur = val;
    },
        stopit = function stopit() {
        var a = this;
        delete animations[a.id];
        a.update();
        eve("mina.stop." + a.id, a);
    },
        pause = function pause() {
        var a = this;
        if (a.pdif) {
            return;
        }
        delete animations[a.id];
        a.update();
        a.pdif = a.get() - a.b;
    },
        resume = function resume() {
        var a = this;
        if (!a.pdif) {
            return;
        }
        a.b = a.get() - a.pdif;
        delete a.pdif;
        animations[a.id] = a;
        frame();
    },
        update = function update() {
        var a = this,
            res;
        if (isArray(a.start)) {
            res = [];
            for (var j = 0, jj = a.start.length; j < jj; j++) {
                res[j] = +a.start[j] + (a.end[j] - a.start[j]) * a.easing(a.s);
            }
        } else {
            res = +a.start + (a.end - a.start) * a.easing(a.s);
        }
        a.set(res);
    },
        frame = function frame(timeStamp) {
        // Manual invokation?
        if (!timeStamp) {
            // Frame loop stopped?
            if (!requestID) {
                // Start frame loop...
                requestID = requestAnimFrame(frame);
            }
            return;
        }
        var len = 0;
        for (var i in animations) {
            if (animations.hasOwnProperty(i)) {
                var a = animations[i],
                    b = a.get(),
                    res;
                len++;
                a.s = (b - a.b) / (a.dur / a.spd);
                if (a.s >= 1) {
                    delete animations[i];
                    a.s = 1;
                    len--;
                    (function (a) {
                        setTimeout(function () {
                            eve("mina.finish." + a.id, a);
                        });
                    })(a);
                }
                a.update();
            }
        }requestID = len ? requestAnimFrame(frame) : false;
    },

    /*\
     * mina
     [ method ]
     **
     * Generic animation of numbers
     **
     - a (number) start _slave_ number
     - A (number) end _slave_ number
     - b (number) start _master_ number (start time in general case)
     - B (number) end _master_ number (end time in general case)
     - get (function) getter of _master_ number (see @mina.time)
     - set (function) setter of _slave_ number
     - easing (function) #optional easing function, default is @mina.linear
     = (object) animation descriptor
     o {
     o         id (string) animation id,
     o         start (number) start _slave_ number,
     o         end (number) end _slave_ number,
     o         b (number) start _master_ number,
     o         s (number) animation status (0..1),
     o         dur (number) animation duration,
     o         spd (number) animation speed,
     o         get (function) getter of _master_ number (see @mina.time),
     o         set (function) setter of _slave_ number,
     o         easing (function) easing function, default is @mina.linear,
     o         status (function) status getter/setter,
     o         speed (function) speed getter/setter,
     o         duration (function) duration getter/setter,
     o         stop (function) animation stopper
     o         pause (function) pauses the animation
     o         resume (function) resumes the animation
     o         update (function) calles setter with the right value of the animation
     o }
    \*/
    mina = function mina(a, A, b, B, get, set, easing) {
        var anim = {
            id: ID(),
            start: a,
            end: A,
            b: b,
            s: 0,
            dur: B - b,
            spd: 1,
            get: get,
            set: set,
            easing: easing || mina.linear,
            status: sta,
            speed: speed,
            duration: duration,
            stop: stopit,
            pause: pause,
            resume: resume,
            update: update
        };
        animations[anim.id] = anim;
        var len = 0,
            i;
        for (i in animations) {
            if (animations.hasOwnProperty(i)) {
                len++;
                if (len == 2) {
                    break;
                }
            }
        }len == 1 && frame();
        return anim;
    };
    /*\
     * mina.time
     [ method ]
     **
     * Returns the current time. Equivalent to:
     | function () {
     |     return (new Date).getTime();
     | }
    \*/
    mina.time = timer;
    /*\
     * mina.getById
     [ method ]
     **
     * Returns an animation by its id
     - id (string) animation's id
     = (object) See @mina
    \*/
    mina.getById = function (id) {
        return animations[id] || null;
    };

    /*\
     * mina.linear
     [ method ]
     **
     * Default linear easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.linear = function (n) {
        return n;
    };
    /*\
     * mina.easeout
     [ method ]
     **
     * Easeout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeout = function (n) {
        return Math.pow(n, 1.7);
    };
    /*\
     * mina.easein
     [ method ]
     **
     * Easein easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easein = function (n) {
        return Math.pow(n, .48);
    };
    /*\
     * mina.easeinout
     [ method ]
     **
     * Easeinout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeinout = function (n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        var q = .48 - n / 1.04,
            Q = Math.sqrt(.1734 + q * q),
            x = Q - q,
            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    };
    /*\
     * mina.backin
     [ method ]
     **
     * Backin easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backin = function (n) {
        if (n == 1) {
            return 1;
        }
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    };
    /*\
     * mina.backout
     [ method ]
     **
     * Backout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backout = function (n) {
        if (n == 0) {
            return 0;
        }
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    };
    /*\
     * mina.elastic
     [ method ]
     **
     * Elastic easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.elastic = function (n) {
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - .075) * (2 * Math.PI) / .3) + 1;
    };
    /*\
     * mina.bounce
     [ method ]
     **
     * Bounce easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.bounce = function (n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < 1 / p) {
            l = s * n * n;
        } else {
            if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + .75;
            } else {
                if (n < 2.5 / p) {
                    n -= 2.25 / p;
                    l = s * n * n + .9375;
                } else {
                    n -= 2.625 / p;
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    };
    window.mina = mina;
    return mina;
}(typeof eve == "undefined" ? function () {} : eve);

// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var Snap = function (root) {
    Snap.version = "0.5.1";
    /*\
     * Snap
     [ method ]
     **
     * Creates a drawing surface or wraps existing SVG element.
     **
     - width (number|string) width of surface
     - height (number|string) height of surface
     * or
     - DOM (SVGElement) element to be wrapped into Snap structure
     * or
     - array (array) array of elements (will return set of elements)
     * or
     - query (string) CSS query selector
     = (object) @Element
    \*/
    function Snap(w, h) {
        if (w) {
            if (w.nodeType) {
                return wrap(w);
            }
            if (is(w, "array") && Snap.set) {
                return Snap.set.apply(Snap, w);
            }
            if (w instanceof Element) {
                return w;
            }
            if (h == null) {
                try {
                    w = glob.doc.querySelector(String(w));
                    return wrap(w);
                } catch (e) {
                    return null;
                }
            }
        }
        w = w == null ? "100%" : w;
        h = h == null ? "100%" : h;
        return new Paper(w, h);
    }
    Snap.toString = function () {
        return "Snap v" + this.version;
    };
    Snap._ = {};
    var glob = {
        win: root.window,
        doc: root.window.document
    };
    Snap._.glob = glob;
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        round = math.round,
        E = "",
        S = " ",
        objectToString = Object.prototype.toString,
        ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        separator = Snap._.separator = /[,\s]+/,
        whitespace = /[\s]/g,
        commaSpaces = /[\s]*,[\s]*/,
        hsrg = { hs: 1, rg: 1 },
        pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
        tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\s]*,?[\s]*/ig,
        idgen = 0,
        idprefix = "S" + (+new Date()).toString(36),
        ID = function ID(el) {
        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
    },
        xlink = "http://www.w3.org/1999/xlink",
        xmlns = "http://www.w3.org/2000/svg",
        hub = {},

    /*\
     * Snap.url
     [ method ]
     **
     * Wraps path into `"url('<path>')"`.
     - value (string) path
     = (string) wrapped path
    \*/
    URL = Snap.url = function (url) {
        return "url('#" + url + "')";
    };

    function $(el, attr) {
        if (attr) {
            if (el == "#text") {
                el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
            }
            if (el == "#comment") {
                el = glob.doc.createComment(attr.text || attr["#text"] || "");
            }
            if (typeof el == "string") {
                el = $(el);
            }
            if (typeof attr == "string") {
                if (el.nodeType == 1) {
                    if (attr.substring(0, 6) == "xlink:") {
                        return el.getAttributeNS(xlink, attr.substring(6));
                    }
                    if (attr.substring(0, 4) == "xml:") {
                        return el.getAttributeNS(xmlns, attr.substring(4));
                    }
                    return el.getAttribute(attr);
                } else if (attr == "text") {
                    return el.nodeValue;
                } else {
                    return null;
                }
            }
            if (el.nodeType == 1) {
                for (var key in attr) {
                    if (attr[has](key)) {
                        var val = Str(attr[key]);
                        if (val) {
                            if (key.substring(0, 6) == "xlink:") {
                                el.setAttributeNS(xlink, key.substring(6), val);
                            } else if (key.substring(0, 4) == "xml:") {
                                el.setAttributeNS(xmlns, key.substring(4), val);
                            } else {
                                el.setAttribute(key, val);
                            }
                        } else {
                            el.removeAttribute(key);
                        }
                    }
                }
            } else if ("text" in attr) {
                el.nodeValue = attr.text;
            }
        } else {
            el = glob.doc.createElementNS(xmlns, el);
        }
        return el;
    }
    Snap._.$ = $;
    Snap._.id = ID;
    function getAttrs(el) {
        var attrs = el.attributes,
            name,
            out = {};
        for (var i = 0; i < attrs.length; i++) {
            if (attrs[i].namespaceURI == xlink) {
                name = "xlink:";
            } else {
                name = "";
            }
            name += attrs[i].name;
            out[name] = attrs[i].textContent;
        }
        return out;
    }
    function is(o, type) {
        type = Str.prototype.toLowerCase.call(type);
        if (type == "finite") {
            return isFinite(o);
        }
        if (type == "array" && (o instanceof Array || Array.isArray && Array.isArray(o))) {
            return true;
        }
        return type == "null" && o === null || type == (typeof o === "undefined" ? "undefined" : _typeof(o)) && o !== null || type == "object" && o === Object(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
    }
    /*\
     * Snap.format
     [ method ]
     **
     * Replaces construction of type `{<name>}` to the corresponding argument
     **
     - token (string) string to format
     - json (object) object which properties are used as a replacement
     = (string) formatted string
     > Usage
     | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    Snap.format = function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,
            // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function replacer(all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
        return function (str, obj) {
            return Str(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    }();
    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor();
        for (var key in obj) {
            if (obj[has](key)) {
                res[key] = clone(obj[key]);
            }
        }return res;
    }
    Snap._.clone = clone;
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) {
            if (array[i] === item) {
                return array.push(array.splice(i, 1)[0]);
            }
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f.apply(scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }
    Snap._.cacher = cacher;
    function angle(x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
        }
    }
    function rad(deg) {
        return deg % 360 * PI / 180;
    }
    function deg(rad) {
        return rad * 180 / PI % 360;
    }
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }

    /*\
     * Snap.rad
     [ method ]
     **
     * Transform angle to radians
     - deg (number) angle in degrees
     = (number) angle in radians
    \*/
    Snap.rad = rad;
    /*\
     * Snap.deg
     [ method ]
     **
     * Transform angle to degrees
     - rad (number) angle in radians
     = (number) angle in degrees
    \*/
    Snap.deg = deg;
    /*\
     * Snap.sin
     [ method ]
     **
     * Equivalent to `Math.sin()` only works with degrees, not radians.
     - angle (number) angle in degrees
     = (number) sin
    \*/
    Snap.sin = function (angle) {
        return math.sin(Snap.rad(angle));
    };
    /*\
     * Snap.tan
     [ method ]
     **
     * Equivalent to `Math.tan()` only works with degrees, not radians.
     - angle (number) angle in degrees
     = (number) tan
    \*/
    Snap.tan = function (angle) {
        return math.tan(Snap.rad(angle));
    };
    /*\
     * Snap.cos
     [ method ]
     **
     * Equivalent to `Math.cos()` only works with degrees, not radians.
     - angle (number) angle in degrees
     = (number) cos
    \*/
    Snap.cos = function (angle) {
        return math.cos(Snap.rad(angle));
    };
    /*\
     * Snap.asin
     [ method ]
     **
     * Equivalent to `Math.asin()` only works with degrees, not radians.
     - num (number) value
     = (number) asin in degrees
    \*/
    Snap.asin = function (num) {
        return Snap.deg(math.asin(num));
    };
    /*\
     * Snap.acos
     [ method ]
     **
     * Equivalent to `Math.acos()` only works with degrees, not radians.
     - num (number) value
     = (number) acos in degrees
    \*/
    Snap.acos = function (num) {
        return Snap.deg(math.acos(num));
    };
    /*\
     * Snap.atan
     [ method ]
     **
     * Equivalent to `Math.atan()` only works with degrees, not radians.
     - num (number) value
     = (number) atan in degrees
    \*/
    Snap.atan = function (num) {
        return Snap.deg(math.atan(num));
    };
    /*\
     * Snap.atan2
     [ method ]
     **
     * Equivalent to `Math.atan2()` only works with degrees, not radians.
     - num (number) value
     = (number) atan2 in degrees
    \*/
    Snap.atan2 = function (num) {
        return Snap.deg(math.atan2(num));
    };
    /*\
     * Snap.angle
     [ method ]
     **
     * Returns an angle between two or three points
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees
    \*/
    Snap.angle = angle;
    /*\
     * Snap.len
     [ method ]
     **
     * Returns distance between two points
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     = (number) distance
    \*/
    Snap.len = function (x1, y1, x2, y2) {
        return Math.sqrt(Snap.len2(x1, y1, x2, y2));
    };
    /*\
     * Snap.len2
     [ method ]
     **
     * Returns squared distance between two points
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     = (number) distance
    \*/
    Snap.len2 = function (x1, y1, x2, y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    };
    /*\
     * Snap.closestPoint
     [ method ]
     **
     * Returns closest point to a given one on a given path.
     - path (Element) path element
     - x (number) x coord of a point
     - y (number) y coord of a point
     = (object) in format
     {
        x (number) x coord of the point on the path
        y (number) y coord of the point on the path
        length (number) length of the path to the point
        distance (number) distance from the given point to the path
     }
    \*/
    // Copied from http://bl.ocks.org/mbostock/8027637
    Snap.closestPoint = function (path, x, y) {
        function distance2(p) {
            var dx = p.x - x,
                dy = p.y - y;
            return dx * dx + dy * dy;
        }
        var pathNode = path.node,
            pathLength = pathNode.getTotalLength(),
            precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
            best,
            bestLength,
            bestDistance = Infinity;

        // linear scan for coarse approximation
        for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
            if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
                best = scan;
                bestLength = scanLength;
                bestDistance = scanDistance;
            }
        }

        // binary search for precise estimate
        precision *= .5;
        while (precision > .5) {
            var before, after, beforeLength, afterLength, beforeDistance, afterDistance;
            if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
                best = before;
                bestLength = beforeLength;
                bestDistance = beforeDistance;
            } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
                best = after;
                bestLength = afterLength;
                bestDistance = afterDistance;
            } else {
                precision *= .5;
            }
        }

        best = {
            x: best.x,
            y: best.y,
            length: bestLength,
            distance: Math.sqrt(bestDistance)
        };
        return best;
    };
    /*\
     * Snap.is
     [ method ]
     **
     * Handy replacement for the `typeof` operator
     - o () any object or primitive
     - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
     = (boolean) `true` if given value is of given type
    \*/
    Snap.is = is;
    /*\
     * Snap.snapTo
     [ method ]
     **
     * Snaps given value to given grid
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
     = (number) adjusted value
    \*/
    Snap.snapTo = function (values, value, tolerance) {
        tolerance = is(tolerance, "finite") ? tolerance : 10;
        if (is(values, "array")) {
            var i = values.length;
            while (i--) {
                if (abs(values[i] - value) <= tolerance) {
                    return values[i];
                }
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };
    // Colour
    /*\
     * Snap.getRGB
     [ method ]
     **
     * Parses color string as RGB object
     - color (string) color string in one of the following formats:
     # <ul>
     #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
     #     <li>#  shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
     #     <li>#  full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
     #     <li>rgba(, , , )  also with opacity</li>
     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
     #     <li>rgba(%, %, %, %)  also with opacity</li>
     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
     #     <li>hsba(, , , )  also with opacity</li>
     #     <li>hsb(%, %, %)  same as above, but in %</li>
     #     <li>hsba(%, %, %, %)  also with opacity</li>
     #     <li>hsl(, , )  hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
     #     <li>hsla(, , , )  also with opacity</li>
     #     <li>hsl(%, %, %)  same as above, but in %</li>
     #     <li>hsla(%, %, %, %)  also with opacity</li>
     # </ul>
     * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
     = (object) RGB object in the following format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) true if string can't be parsed
     o }
    \*/
    Snap.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
        }
        if (colour == "none") {
            return { r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString };
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = _toHex(colour));
        if (!colour) {
            return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
        }
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4].split(commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5].split(commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red /= 100);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green /= 100);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue /= 100);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return Snap.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6].split(commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red /= 100);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green /= 100);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue /= 100);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return Snap.hsl2rgb(red, green, blue, opacity);
            }
            red = mmin(math.round(red), 255);
            green = mmin(math.round(green), 255);
            blue = mmin(math.round(blue), 255);
            opacity = mmin(mmax(opacity, 0), 1);
            rgb = { r: red, g: green, b: blue, toString: rgbtoString };
            rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
            rgb.opacity = is(opacity, "finite") ? opacity : 1;
            return rgb;
        }
        return { r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString };
    }, Snap);
    /*\
     * Snap.hsb
     [ method ]
     **
     * Converts HSB values to a hex representation of the color
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the color
    \*/
    Snap.hsb = cacher(function (h, s, b) {
        return Snap.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Snap.hsl
     [ method ]
     **
     * Converts HSL values to a hex representation of the color
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the color
    \*/
    Snap.hsl = cacher(function (h, s, l) {
        return Snap.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Snap.rgb
     [ method ]
     **
     * Converts RGB values to a hex representation of the color
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the color
    \*/
    Snap.rgb = cacher(function (r, g, b, o) {
        if (is(o, "finite")) {
            var round = math.round;
            return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
        }
        return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
    });
    var _toHex = function toHex(color) {
        var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
            red = "rgb(255, 0, 0)";
        _toHex = cacher(function (color) {
            if (color.toLowerCase() == "red") {
                return red;
            }
            i.style.color = red;
            i.style.color = color;
            var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            return out == red ? null : out;
        });
        return _toHex(color);
    },
        hsbtoString = function hsbtoString() {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
        hsltoString = function hsltoString() {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
        rgbtoString = function rgbtoString() {
        return this.opacity == 1 || this.opacity == null ? this.hex : "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
    },
        prepareRGB = function prepareRGB(r, g, b) {
        if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && is(r, string)) {
            var clr = Snap.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }

        return [r, g, b];
    },
        packageRGB = function packageRGB(r, g, b, o) {
        r = math.round(r * 255);
        g = math.round(g * 255);
        b = math.round(b * 255);
        var rgb = {
            r: r,
            g: g,
            b: b,
            opacity: is(o, "finite") ? o : 1,
            hex: Snap.rgb(r, g, b),
            toString: rgbtoString
        };
        is(o, "finite") && (rgb.opacity = o);
        return rgb;
    };
    /*\
     * Snap.color
     [ method ]
     **
     * Parses the color string and returns an object featuring the color's component values
     - clr (string) color string in one of the supported formats (see @Snap.getRGB)
     = (object) Combined RGB/HSB object in the following format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) `true` if string can't be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    Snap.color = function (clr) {
        var rgb;
        if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = Snap.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.opacity = 1;
            clr.hex = rgb.hex;
        } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = Snap.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.opacity = 1;
            clr.hex = rgb.hex;
        } else {
            if (is(clr, "string")) {
                clr = Snap.getRGB(clr);
            }
            if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
                rgb = Snap.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = Snap.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = { hex: "none" };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
                clr.error = 1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Snap.hsb2rgb
     [ method ]
     **
     * Converts HSB values to an RGB object
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in the following format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    Snap.hsb2rgb = function (h, s, v, o) {
        if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        var R, G, B, X, C;
        h = h % 360 / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Snap.hsl2rgb
     [ method ]
     **
     * Converts HSL values to an RGB object
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in the following format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    Snap.hsl2rgb = function (h, s, l, o) {
        if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = h % 360 / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Snap.rgb2hsb
     [ method ]
     **
     * Converts RGB values to an HSB object
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in the following format:
     o {
     o     h (number) hue,
     o     s (number) saturation,
     o     b (number) brightness
     o }
    \*/
    Snap.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return { h: H, s: S, b: V, toString: hsbtoString };
    };
    /*\
     * Snap.rgb2hsl
     [ method ]
     **
     * Converts RGB values to an HSL object
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in the following format:
     o {
     o     h (number) hue,
     o     s (number) saturation,
     o     l (number) luminosity
     o }
    \*/
    Snap.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        L = (M + m) / 2;
        S = C == 0 ? 0 : L < .5 ? C / (2 * L) : C / (2 - 2 * L);
        return { h: H, s: S, l: L, toString: hsltoString };
    };

    // Transformations
    /*\
     * Snap.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments
     - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
     = (array) array of segments
    \*/
    Snap.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = Snap.path(pathString);
        if (pth.arr) {
            return Snap.path.clone(pth.arr);
        }

        var paramCounts = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 },
            data = [];
        if (is(pathString, "array") && is(pathString[0], "array")) {
            // rough assumption
            data = Snap.path.clone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b].concat(params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "o" && params.length == 1) {
                    data.push([b, params[0]]);
                }
                if (name == "r") {
                    data.push([b].concat(params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b].concat(params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = Snap.path.toString;
        pth.arr = Snap.path.clone(data);
        return data;
    };
    /*\
     * Snap.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given transform string into an array of transformations
     - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
     = (array) array of transformations
    \*/
    var parseTransformString = Snap.parseTransformString = function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = { r: 3, s: 4, t: 2, m: 6 },
            data = [];
        if (is(TString, "array") && is(TString[0], "array")) {
            // rough assumption
            data = Snap.path.clone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b].concat(params));
            });
        }
        data.toString = Snap.path.toString;
        return data;
    };
    function svgTransform2string(tstr) {
        var res = [];
        tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
            params = params.split(/\s*,\s*|\s+/);
            if (name == "rotate" && params.length == 1) {
                params.push(0, 0);
            }
            if (name == "scale") {
                if (params.length > 2) {
                    params = params.slice(0, 2);
                } else if (params.length == 2) {
                    params.push(0, 0);
                }
                if (params.length == 1) {
                    params.push(params[0], 0, 0);
                }
            }
            if (name == "skewX") {
                res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
            } else if (name == "skewY") {
                res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
            } else {
                res.push([name.charAt(0)].concat(params));
            }
            return all;
        });
        return res;
    }
    Snap._.svgTransform2string = svgTransform2string;
    Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
    function transform2matrix(tstr, bbox) {
        var tdata = parseTransformString(tstr),
            m = new Snap.Matrix();
        if (tdata) {
            for (var i = 0, ii = tdata.length; i < ii; i++) {
                var t = tdata[i],
                    tlen = t.length,
                    command = Str(t[0]).toLowerCase(),
                    absolute = t[0] != command,
                    inver = absolute ? m.invert() : 0,
                    x1,
                    y1,
                    x2,
                    y2,
                    bb;
                if (command == "t" && tlen == 2) {
                    m.translate(t[1], 0);
                } else if (command == "t" && tlen == 3) {
                    if (absolute) {
                        x1 = inver.x(0, 0);
                        y1 = inver.y(0, 0);
                        x2 = inver.x(t[1], t[2]);
                        y2 = inver.y(t[1], t[2]);
                        m.translate(x2 - x1, y2 - y1);
                    } else {
                        m.translate(t[1], t[2]);
                    }
                } else if (command == "r") {
                    if (tlen == 2) {
                        bb = bb || bbox;
                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    } else if (tlen == 4) {
                        if (absolute) {
                            x2 = inver.x(t[2], t[3]);
                            y2 = inver.y(t[2], t[3]);
                            m.rotate(t[1], x2, y2);
                        } else {
                            m.rotate(t[1], t[2], t[3]);
                        }
                    }
                } else if (command == "s") {
                    if (tlen == 2 || tlen == 3) {
                        bb = bb || bbox;
                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    } else if (tlen == 4) {
                        if (absolute) {
                            x2 = inver.x(t[2], t[3]);
                            y2 = inver.y(t[2], t[3]);
                            m.scale(t[1], t[1], x2, y2);
                        } else {
                            m.scale(t[1], t[1], t[2], t[3]);
                        }
                    } else if (tlen == 5) {
                        if (absolute) {
                            x2 = inver.x(t[3], t[4]);
                            y2 = inver.y(t[3], t[4]);
                            m.scale(t[1], t[2], x2, y2);
                        } else {
                            m.scale(t[1], t[2], t[3], t[4]);
                        }
                    }
                } else if (command == "m" && tlen == 7) {
                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                }
            }
        }
        return m;
    }
    Snap._.transform2matrix = transform2matrix;
    Snap._unit2px = unit2px;
    var contains = glob.doc.contains || glob.doc.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType == 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a == bup || !!(bup && bup.nodeType == 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function (a, b) {
        if (b) {
            while (b) {
                b = b.parentNode;
                if (b == a) {
                    return true;
                }
            }
        }
        return false;
    };
    function getSomeDefs(el) {
        var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || el.node.parentNode && wrap(el.node.parentNode) || Snap.select("svg") || Snap(0, 0),
            pdefs = p.select("defs"),
            defs = pdefs == null ? false : pdefs.node;
        if (!defs) {
            defs = make("defs", p.node).node;
        }
        return defs;
    }
    function getSomeSVG(el) {
        return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
    }
    Snap._.getSomeDefs = getSomeDefs;
    Snap._.getSomeSVG = getSomeSVG;
    function unit2px(el, name, value) {
        var svg = getSomeSVG(el).node,
            out = {},
            mgr = svg.querySelector(".svg---mgr");
        if (!mgr) {
            mgr = $("rect");
            $(mgr, { x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none" });
            svg.appendChild(mgr);
        }
        function getW(val) {
            if (val == null) {
                return E;
            }
            if (val == +val) {
                return val;
            }
            $(mgr, { width: val });
            try {
                return mgr.getBBox().width;
            } catch (e) {
                return 0;
            }
        }
        function getH(val) {
            if (val == null) {
                return E;
            }
            if (val == +val) {
                return val;
            }
            $(mgr, { height: val });
            try {
                return mgr.getBBox().height;
            } catch (e) {
                return 0;
            }
        }
        function set(nam, f) {
            if (name == null) {
                out[nam] = f(el.attr(nam) || 0);
            } else if (nam == name) {
                out = f(value == null ? el.attr(nam) || 0 : value);
            }
        }
        switch (el.type) {
            case "rect":
                set("rx", getW);
                set("ry", getH);
            case "image":
                set("width", getW);
                set("height", getH);
            case "text":
                set("x", getW);
                set("y", getH);
                break;
            case "circle":
                set("cx", getW);
                set("cy", getH);
                set("r", getW);
                break;
            case "ellipse":
                set("cx", getW);
                set("cy", getH);
                set("rx", getW);
                set("ry", getH);
                break;
            case "line":
                set("x1", getW);
                set("x2", getW);
                set("y1", getH);
                set("y2", getH);
                break;
            case "marker":
                set("refX", getW);
                set("markerWidth", getW);
                set("refY", getH);
                set("markerHeight", getH);
                break;
            case "radialGradient":
                set("fx", getW);
                set("fy", getH);
                break;
            case "tspan":
                set("dx", getW);
                set("dy", getH);
                break;
            default:
                set(name, getW);
        }
        svg.removeChild(mgr);
        return out;
    }
    /*\
     * Snap.select
     [ method ]
     **
     * Wraps a DOM element specified by CSS selector as @Element
     - query (string) CSS selector of the element
     = (Element) the current element
    \*/
    Snap.select = function (query) {
        query = Str(query).replace(/([^\\]):/g, "$1\\:");
        return wrap(glob.doc.querySelector(query));
    };
    /*\
     * Snap.selectAll
     [ method ]
     **
     * Wraps DOM elements specified by CSS selector as set or array of @Element
     - query (string) CSS selector of the element
     = (Element) the current element
    \*/
    Snap.selectAll = function (query) {
        var nodelist = glob.doc.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };

    function add2group(list) {
        if (!is(list, "array")) {
            list = Array.prototype.slice.call(arguments, 0);
        }
        var i = 0,
            j = 0,
            node = this.node;
        while (this[i]) {
            delete this[i++];
        }for (i = 0; i < list.length; i++) {
            if (list[i].type == "set") {
                list[i].forEach(function (el) {
                    node.appendChild(el.node);
                });
            } else {
                node.appendChild(list[i].node);
            }
        }
        var children = node.childNodes;
        for (i = 0; i < children.length; i++) {
            this[j++] = wrap(children[i]);
        }
        return this;
    }
    // Hub garbage collector every 10s
    setInterval(function () {
        for (var key in hub) {
            if (hub[has](key)) {
                var el = hub[key],
                    node = el.node;
                if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
                    delete hub[key];
                }
            }
        }
    }, 1e4);
    function Element(el) {
        if (el.snap in hub) {
            return hub[el.snap];
        }
        var svg;
        try {
            svg = el.ownerSVGElement;
        } catch (e) {}
        /*\
         * Element.node
         [ property (object) ]
         **
         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
         > Usage
         | // draw a circle at coordinate 10,10 with radius of 10
         | var c = paper.circle(10, 10, 10);
         | c.node.onclick = function () {
         |     c.attr("fill", "red");
         | };
        \*/
        this.node = el;
        if (svg) {
            this.paper = new Paper(svg);
        }
        /*\
         * Element.type
         [ property (string) ]
         **
         * SVG tag name of the given element.
        \*/
        this.type = el.tagName || el.nodeName;
        var id = this.id = ID(this);
        this.anims = {};
        this._ = {
            transform: []
        };
        el.snap = id;
        hub[id] = this;
        if (this.type == "g") {
            this.add = add2group;
        }
        if (this.type in { g: 1, mask: 1, pattern: 1, symbol: 1 }) {
            for (var method in Paper.prototype) {
                if (Paper.prototype[has](method)) {
                    this[method] = Paper.prototype[method];
                }
            }
        }
    }
    /*\
      * Element.attr
      [ method ]
      **
      * Gets or sets given attributes of the element.
      **
      - params (object) contains key-value pairs of attributes you want to set
      * or
      - param (string) name of the attribute
      = (Element) the current element
      * or
      = (string) value of attribute
      > Usage
      | el.attr({
      |     fill: "#fc0",
      |     stroke: "#000",
      |     strokeWidth: 2, // CamelCase...
      |     "fill-opacity": 0.5, // or dash-separated names
      |     width: "*=2" // prefixed values
      | });
      | console.log(el.attr("fill")); // #fc0
      * Prefixed values in format `"+=10"` supported. All four operations
      * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
      * and `-`: `"+=2em"`.
     \*/
    Element.prototype.attr = function (params, value) {
        var el = this,
            node = el.node;
        if (!params) {
            if (node.nodeType != 1) {
                return {
                    text: node.nodeValue
                };
            }
            var attr = node.attributes,
                out = {};
            for (var i = 0, ii = attr.length; i < ii; i++) {
                out[attr[i].nodeName] = attr[i].nodeValue;
            }
            return out;
        }
        if (is(params, "string")) {
            if (arguments.length > 1) {
                var json = {};
                json[params] = value;
                params = json;
            } else {
                return eve("snap.util.getattr." + params, el).firstDefined();
            }
        }
        for (var att in params) {
            if (params[has](att)) {
                eve("snap.util.attr." + att, el, params[att]);
            }
        }
        return el;
    };
    /*\
     * Snap.parse
     [ method ]
     **
     * Parses SVG fragment and converts it into a @Fragment
     **
     - svg (string) SVG string
     = (Fragment) the @Fragment
    \*/
    Snap.parse = function (svg) {
        var f = glob.doc.createDocumentFragment(),
            full = true,
            div = glob.doc.createElement("div");
        svg = Str(svg);
        if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
            svg = "<svg>" + svg + "</svg>";
            full = false;
        }
        div.innerHTML = svg;
        svg = div.getElementsByTagName("svg")[0];
        if (svg) {
            if (full) {
                f = svg;
            } else {
                while (svg.firstChild) {
                    f.appendChild(svg.firstChild);
                }
            }
        }
        return new Fragment(f);
    };
    function Fragment(frag) {
        this.node = frag;
    }
    /*\
     * Snap.fragment
     [ method ]
     **
     * Creates a DOM fragment from a given list of elements or strings
     **
     - varargs () SVG string
     = (Fragment) the @Fragment
    \*/
    Snap.fragment = function () {
        var args = Array.prototype.slice.call(arguments, 0),
            f = glob.doc.createDocumentFragment();
        for (var i = 0, ii = args.length; i < ii; i++) {
            var item = args[i];
            if (item.node && item.node.nodeType) {
                f.appendChild(item.node);
            }
            if (item.nodeType) {
                f.appendChild(item);
            }
            if (typeof item == "string") {
                f.appendChild(Snap.parse(item).node);
            }
        }
        return new Fragment(f);
    };

    function make(name, parent) {
        var res = $(name);
        parent.appendChild(res);
        var el = wrap(res);
        return el;
    }
    function Paper(w, h) {
        var res,
            desc,
            defs,
            proto = Paper.prototype;
        if (w && w.tagName && w.tagName.toLowerCase() == "svg") {
            if (w.snap in hub) {
                return hub[w.snap];
            }
            var doc = w.ownerDocument;
            res = new Element(w);
            desc = w.getElementsByTagName("desc")[0];
            defs = w.getElementsByTagName("defs")[0];
            if (!desc) {
                desc = $("desc");
                desc.appendChild(doc.createTextNode("Created with Snap"));
                res.node.appendChild(desc);
            }
            if (!defs) {
                defs = $("defs");
                res.node.appendChild(defs);
            }
            res.defs = defs;
            for (var key in proto) {
                if (proto[has](key)) {
                    res[key] = proto[key];
                }
            }res.paper = res.root = res;
        } else {
            res = make("svg", glob.doc.body);
            $(res.node, {
                height: h,
                version: 1.1,
                width: w,
                xmlns: xmlns
            });
        }
        return res;
    }
    function wrap(dom) {
        if (!dom) {
            return dom;
        }
        if (dom instanceof Element || dom instanceof Fragment) {
            return dom;
        }
        if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
            return new Paper(dom);
        }
        if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
            return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
        }
        return new Element(dom);
    }

    Snap._.make = make;
    Snap._.wrap = wrap;
    /*\
     * Paper.el
     [ method ]
     **
     * Creates an element on paper with a given name and no attributes
     **
     - name (string) tag name
     - attr (object) attributes
     = (Element) the current element
     > Usage
     | var c = paper.circle(10, 10, 10); // is the same as...
     | var c = paper.el("circle").attr({
     |     cx: 10,
     |     cy: 10,
     |     r: 10
     | });
     | // and the same as
     | var c = paper.el("circle", {
     |     cx: 10,
     |     cy: 10,
     |     r: 10
     | });
    \*/
    Paper.prototype.el = function (name, attr) {
        var el = make(name, this.node);
        attr && el.attr(attr);
        return el;
    };
    /*\
     * Element.children
     [ method ]
     **
     * Returns array of all the children of the element.
     = (array) array of Elements
    \*/
    Element.prototype.children = function () {
        var out = [],
            ch = this.node.childNodes;
        for (var i = 0, ii = ch.length; i < ii; i++) {
            out[i] = Snap(ch[i]);
        }
        return out;
    };
    function jsonFiller(root, o) {
        for (var i = 0, ii = root.length; i < ii; i++) {
            var item = {
                type: root[i].type,
                attr: root[i].attr()
            },
                children = root[i].children();
            o.push(item);
            if (children.length) {
                jsonFiller(children, item.childNodes = []);
            }
        }
    }
    /*\
     * Element.toJSON
     [ method ]
     **
     * Returns object representation of the given element and all its children.
     = (object) in format
     o {
     o     type (string) this.type,
     o     attr (object) attributes map,
     o     childNodes (array) optional array of children in the same format
     o }
    \*/
    Element.prototype.toJSON = function () {
        var out = [];
        jsonFiller([this], out);
        return out[0];
    };
    // default
    eve.on("snap.util.getattr", function () {
        var att = eve.nt();
        att = att.substring(att.lastIndexOf(".") + 1);
        var css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
        if (cssAttr[has](css)) {
            return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
        } else {
            return $(this.node, att);
        }
    });
    var cssAttr = {
        "alignment-baseline": 0,
        "baseline-shift": 0,
        "clip": 0,
        "clip-path": 0,
        "clip-rule": 0,
        "color": 0,
        "color-interpolation": 0,
        "color-interpolation-filters": 0,
        "color-profile": 0,
        "color-rendering": 0,
        "cursor": 0,
        "direction": 0,
        "display": 0,
        "dominant-baseline": 0,
        "enable-background": 0,
        "fill": 0,
        "fill-opacity": 0,
        "fill-rule": 0,
        "filter": 0,
        "flood-color": 0,
        "flood-opacity": 0,
        "font": 0,
        "font-family": 0,
        "font-size": 0,
        "font-size-adjust": 0,
        "font-stretch": 0,
        "font-style": 0,
        "font-variant": 0,
        "font-weight": 0,
        "glyph-orientation-horizontal": 0,
        "glyph-orientation-vertical": 0,
        "image-rendering": 0,
        "kerning": 0,
        "letter-spacing": 0,
        "lighting-color": 0,
        "marker": 0,
        "marker-end": 0,
        "marker-mid": 0,
        "marker-start": 0,
        "mask": 0,
        "opacity": 0,
        "overflow": 0,
        "pointer-events": 0,
        "shape-rendering": 0,
        "stop-color": 0,
        "stop-opacity": 0,
        "stroke": 0,
        "stroke-dasharray": 0,
        "stroke-dashoffset": 0,
        "stroke-linecap": 0,
        "stroke-linejoin": 0,
        "stroke-miterlimit": 0,
        "stroke-opacity": 0,
        "stroke-width": 0,
        "text-anchor": 0,
        "text-decoration": 0,
        "text-rendering": 0,
        "unicode-bidi": 0,
        "visibility": 0,
        "word-spacing": 0,
        "writing-mode": 0
    };

    eve.on("snap.util.attr", function (value) {
        var att = eve.nt(),
            attr = {};
        att = att.substring(att.lastIndexOf(".") + 1);
        attr[att] = value;
        var style = att.replace(/-(\w)/gi, function (all, letter) {
            return letter.toUpperCase();
        }),
            css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
        if (cssAttr[has](css)) {
            this.node.style[style] = value == null ? E : value;
        } else {
            $(this.node, attr);
        }
    });
    (function (proto) {})(Paper.prototype);

    // simple ajax
    /*\
     * Snap.ajax
     [ method ]
     **
     * Simple implementation of Ajax
     **
     - url (string) URL
     - postData (object|string) data for post request
     - callback (function) callback
     - scope (object) #optional scope of callback
     * or
     - url (string) URL
     - callback (function) callback
     - scope (object) #optional scope of callback
     = (XMLHttpRequest) the XMLHttpRequest object, just in case
    \*/
    Snap.ajax = function (url, postData, callback, scope) {
        var req = new XMLHttpRequest(),
            id = ID();
        if (req) {
            if (is(postData, "function")) {
                scope = callback;
                callback = postData;
                postData = null;
            } else if (is(postData, "object")) {
                var pd = [];
                for (var key in postData) {
                    if (postData.hasOwnProperty(key)) {
                        pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
                    }
                }postData = pd.join("&");
            }
            req.open(postData ? "POST" : "GET", url, true);
            if (postData) {
                req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            }
            if (callback) {
                eve.once("snap.ajax." + id + ".0", callback);
                eve.once("snap.ajax." + id + ".200", callback);
                eve.once("snap.ajax." + id + ".304", callback);
            }
            req.onreadystatechange = function () {
                if (req.readyState != 4) return;
                eve("snap.ajax." + id + "." + req.status, scope, req);
            };
            if (req.readyState == 4) {
                return req;
            }
            req.send(postData);
            return req;
        }
    };
    /*\
     * Snap.load
     [ method ]
     **
     * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
     **
     - url (string) URL
     - callback (function) callback
     - scope (object) #optional scope of callback
    \*/
    Snap.load = function (url, callback, scope) {
        Snap.ajax(url, function (req) {
            var f = Snap.parse(req.responseText);
            scope ? callback.call(scope, f) : callback(f);
        });
    };
    var getOffset = function getOffset(elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Snap.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Snap element object
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    Snap.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = glob.doc.elementFromPoint(x, y);
        if (glob.win.opera && target.tagName == "svg") {
            var so = getOffset(target),
                sr = target.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = target.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        return wrap(target);
    };
    /*\
     * Snap.plugin
     [ method ]
     **
     * Let you write plugins. You pass in a function with five arguments, like this:
     | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
     |     Snap.newmethod = function () {};
     |     Element.prototype.newmethod = function () {};
     |     Paper.prototype.newmethod = function () {};
     | });
     * Inside the function you have access to all main objects (and their
     * prototypes). This allow you to extend anything you want.
     **
     - f (function) your plugin body
    \*/
    Snap.plugin = function (f) {
        f(Snap, Element, Paper, glob, Fragment);
    };
    glob.win.Snap = Snap;
    return Snap;
}(window || undefined);

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        unit2px = Snap._unit2px,
        $ = Snap._.$,
        make = Snap._.make,
        getSomeDefs = Snap._.getSomeDefs,
        has = "hasOwnProperty",
        wrap = Snap._.wrap;
    /*\
     * Element.getBBox
     [ method ]
     **
     * Returns the bounding box descriptor for the given element
     **
     = (object) bounding box descriptor:
     o {
     o     cx: (number) x of the center,
     o     cy: (number) x of the center,
     o     h: (number) height,
     o     height: (number) height,
     o     path: (string) path command for the box,
     o     r0: (number) radius of a circle that fully encloses the box,
     o     r1: (number) radius of the smallest circle that can be enclosed,
     o     r2: (number) radius of the largest circle that can be enclosed,
     o     vb: (string) box as a viewbox command,
     o     w: (number) width,
     o     width: (number) width,
     o     x2: (number) x of the right side,
     o     x: (number) x of the left side,
     o     y2: (number) y of the bottom edge,
     o     y: (number) y of the top edge
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.type == "tspan") {
            return Snap._.box(this.node.getClientRects().item(0));
        }
        if (!Snap.Matrix || !Snap.path) {
            return this.node.getBBox();
        }
        var el = this,
            m = new Snap.Matrix();
        if (el.removed) {
            return Snap._.box();
        }
        while (el.type == "use") {
            if (!isWithoutTransform) {
                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
            }
            if (el.original) {
                el = el.original;
            } else {
                var href = el.attr("xlink:href");
                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
            }
        }
        var _ = el._,
            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
        try {
            if (isWithoutTransform) {
                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                return Snap._.box(_.bboxwt);
            } else {
                el.realPath = pathfinder(el);
                el.matrix = el.transform().localMatrix;
                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                return Snap._.box(_.bbox);
            }
        } catch (e) {
            // Firefox doesnt give you bbox of hidden element
            return Snap._.box();
        }
    };
    var propString = function propString() {
        return this.string;
    };
    function extractTransform(el, tstr) {
        if (tstr == null) {
            var doReturn = true;
            if (el.type == "linearGradient" || el.type == "radialGradient") {
                tstr = el.node.getAttribute("gradientTransform");
            } else if (el.type == "pattern") {
                tstr = el.node.getAttribute("patternTransform");
            } else {
                tstr = el.node.getAttribute("transform");
            }
            if (!tstr) {
                return new Snap.Matrix();
            }
            tstr = Snap._.svgTransform2string(tstr);
        } else {
            if (!Snap._.rgTransform.test(tstr)) {
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
            }
            if (is(tstr, "array")) {
                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
            }
            el._.transform = tstr;
        }
        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
        if (doReturn) {
            return m;
        } else {
            el.matrix = m;
        }
    }
    /*\
     * Element.transform
     [ method ]
     **
     * Gets or sets transformation of the element
     **
     - tstr (string) transform string in Snap or SVG format
     = (Element) the current element
     * or
     = (object) transformation descriptor:
     o {
     o     string (string) transform string,
     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
     o     localMatrix (Matrix) matrix of transformations applied only to the element,
     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
     o     global (string) global transformation as string,
     o     local (string) local transformation as string,
     o     toString (function) returns `string` property
     o }
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            var papa = this,
                global = new Snap.Matrix(this.node.getCTM()),
                local = extractTransform(this),
                ms = [local],
                m = new Snap.Matrix(),
                i,
                localString = local.toTransformString(),
                string = Str(local) == Str(this.matrix) ? Str(_.transform) : localString;
            while (papa.type != "svg" && (papa = papa.parent())) {
                ms.push(extractTransform(papa));
            }
            i = ms.length;
            while (i--) {
                m.add(ms[i]);
            }
            return {
                string: string,
                globalMatrix: global,
                totalMatrix: m,
                localMatrix: local,
                diffMatrix: global.clone().add(local.invert()),
                global: global.toTransformString(),
                total: m.toTransformString(),
                local: localString,
                toString: propString
            };
        }
        if (tstr instanceof Snap.Matrix) {
            this.matrix = tstr;
            this._.transform = tstr.toTransformString();
        } else {
            extractTransform(this, tstr);
        }

        if (this.node) {
            if (this.type == "linearGradient" || this.type == "radialGradient") {
                $(this.node, { gradientTransform: this.matrix });
            } else if (this.type == "pattern") {
                $(this.node, { patternTransform: this.matrix });
            } else {
                $(this.node, { transform: this.matrix });
            }
        }

        return this;
    };
    /*\
     * Element.parent
     [ method ]
     **
     * Returns the element's parent
     **
     = (Element) the parent element
    \*/
    elproto.parent = function () {
        return wrap(this.node.parentNode);
    };
    /*\
     * Element.append
     [ method ]
     **
     * Appends the given element to current one
     **
     - el (Element|Set) element to append
     = (Element) the parent element
    \*/
    /*\
     * Element.add
     [ method ]
     **
     * See @Element.append
    \*/
    elproto.append = elproto.add = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    it.add(el);
                });
                return this;
            }
            el = wrap(el);
            this.node.appendChild(el.node);
            el.paper = this.paper;
        }
        return this;
    };
    /*\
     * Element.appendTo
     [ method ]
     **
     * Appends the current element to the given one
     **
     - el (Element) parent element to append to
     = (Element) the child element
    \*/
    elproto.appendTo = function (el) {
        if (el) {
            el = wrap(el);
            el.append(this);
        }
        return this;
    };
    /*\
     * Element.prepend
     [ method ]
     **
     * Prepends the given element to the current one
     **
     - el (Element) element to prepend
     = (Element) the parent element
    \*/
    elproto.prepend = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this,
                    first;
                el.forEach(function (el) {
                    if (first) {
                        first.after(el);
                    } else {
                        it.prepend(el);
                    }
                    first = el;
                });
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.insertBefore(el.node, this.node.firstChild);
            this.add && this.add();
            el.paper = this.paper;
            this.parent() && this.parent().add();
            parent && parent.add();
        }
        return this;
    };
    /*\
     * Element.prependTo
     [ method ]
     **
     * Prepends the current element to the given one
     **
     - el (Element) parent element to prepend to
     = (Element) the child element
    \*/
    elproto.prependTo = function (el) {
        el = wrap(el);
        el.prepend(this);
        return this;
    };
    /*\
     * Element.before
     [ method ]
     **
     * Inserts given element before the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.before = function (el) {
        if (el.type == "set") {
            var it = this;
            el.forEach(function (el) {
                var parent = el.parent();
                it.node.parentNode.insertBefore(el.node, it.node);
                parent && parent.add();
            });
            this.parent().add();
            return this;
        }
        el = wrap(el);
        var parent = el.parent();
        this.node.parentNode.insertBefore(el.node, this.node);
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.after
     [ method ]
     **
     * Inserts given element after the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.after = function (el) {
        el = wrap(el);
        var parent = el.parent();
        if (this.node.nextSibling) {
            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
        } else {
            this.node.parentNode.appendChild(el.node);
        }
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertBefore = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertAfter = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the DOM
     = (Element) the detached element
    \*/
    elproto.remove = function () {
        var parent = this.parent();
        this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.paper;
        this.removed = true;
        parent && parent.add();
        return this;
    };
    /*\
     * Element.select
     [ method ]
     **
     * Gathers the nested @Element matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Element) result of query selection
    \*/
    elproto.select = function (query) {
        return wrap(this.node.querySelector(query));
    };
    /*\
     * Element.selectAll
     [ method ]
     **
     * Gathers nested @Element objects matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Set|array) result of query selection
    \*/
    elproto.selectAll = function (query) {
        var nodelist = this.node.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };
    /*\
     * Element.asPX
     [ method ]
     **
     * Returns given attribute of the element as a `px` value (not %, em, etc.)
     **
     - attr (string) attribute name
     - value (string) #optional attribute value
     = (Element) result of query selection
    \*/
    elproto.asPX = function (attr, value) {
        if (value == null) {
            value = this.attr(attr);
        }
        return +unit2px(this, attr, value);
    };
    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
    /*\
     * Element.use
     [ method ]
     **
     * Creates a `<use>` element linked to the current element
     **
     = (Element) the `<use>` element
    \*/
    elproto.use = function () {
        var use,
            id = this.node.id;
        if (!id) {
            id = this.id;
            $(this.node, {
                id: id
            });
        }
        if (this.type == "linearGradient" || this.type == "radialGradient" || this.type == "pattern") {
            use = make(this.type, this.node.parentNode);
        } else {
            use = make("use", this.node.parentNode);
        }
        $(use.node, {
            "xlink:href": "#" + id
        });
        use.original = this;
        return use;
    };
    function fixids(el) {
        var els = el.selectAll("*"),
            it,
            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
            ids = [],
            uses = {};
        function urltest(it, name) {
            var val = $(it.node, name);
            val = val && val.match(url);
            val = val && val[2];
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    var attr = {};
                    attr[name] = Snap.url(id);
                    $(it.node, attr);
                });
            }
        }
        function linktest(it) {
            var val = $(it.node, "xlink:href");
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    it.attr("xlink:href", "#" + id);
                });
            }
        }
        for (var i = 0, ii = els.length; i < ii; i++) {
            it = els[i];
            urltest(it, "fill");
            urltest(it, "stroke");
            urltest(it, "filter");
            urltest(it, "mask");
            urltest(it, "clip-path");
            linktest(it);
            var oldid = $(it.node, "id");
            if (oldid) {
                $(it.node, { id: it.id });
                ids.push({
                    old: oldid,
                    id: it.id
                });
            }
        }
        for (i = 0, ii = ids.length; i < ii; i++) {
            var fs = uses[ids[i].old];
            if (fs) {
                for (var j = 0, jj = fs.length; j < jj; j++) {
                    fs[j](ids[i].id);
                }
            }
        }
    }
    /*\
     * Element.clone
     [ method ]
     **
     * Creates a clone of the element and inserts it after the element
     **
     = (Element) the clone
    \*/
    elproto.clone = function () {
        var clone = wrap(this.node.cloneNode(true));
        if ($(clone.node, "id")) {
            $(clone.node, { id: clone.id });
        }
        fixids(clone);
        clone.insertAfter(this);
        return clone;
    };
    /*\
     * Element.toDefs
     [ method ]
     **
     * Moves element to the shared `<defs>` area
     **
     = (Element) the element
    \*/
    elproto.toDefs = function () {
        var defs = getSomeDefs(this);
        defs.appendChild(this.node);
        return this;
    };
    /*\
     * Element.toPattern
     [ method ]
     **
     * Creates a `<pattern>` element from the current element
     **
     * To create a pattern you have to specify the pattern rect:
     - x (string|number)
     - y (string|number)
     - width (string|number)
     - height (string|number)
     = (Element) the `<pattern>` element
     * You can use pattern later on as an argument for `fill` attribute:
     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
     |         fill: "none",
     |         stroke: "#bada55",
     |         strokeWidth: 5
     |     }).pattern(0, 0, 10, 10),
     |     c = paper.circle(200, 200, 100);
     | c.attr({
     |     fill: p
     | });
    \*/
    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
        var p = make("pattern", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        $(p.node, {
            x: x,
            y: y,
            width: width,
            height: height,
            patternUnits: "userSpaceOnUse",
            id: p.id,
            viewBox: [x, y, width, height].join(" ")
        });
        p.node.appendChild(this.node);
        return p;
    };
    // SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
    // SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
    /*\
     * Element.marker
     [ method ]
     **
     * Creates a `<marker>` element from the current element
     **
     * To create a marker you have to specify the bounding rect and reference point:
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - refX (number)
     - refY (number)
     = (Element) the `<marker>` element
     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
    \*/
    // TODO add usage for markers
    elproto.marker = function (x, y, width, height, refX, refY) {
        var p = make("marker", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            refX = x.refX || x.cx;
            refY = x.refY || x.cy;
            x = x.x;
        }
        $(p.node, {
            viewBox: [x, y, width, height].join(" "),
            markerWidth: width,
            markerHeight: height,
            orient: "auto",
            refX: refX || 0,
            refY: refY || 0,
            id: p.id
        });
        p.node.appendChild(this.node);
        return p;
    };
    var eldata = {};
    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key. (Dont confuse
     * with `data-` attributes)
     *
     * See also @Element.removeData
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            eve("snap.data.get." + this.id, this, data, null);
            return data;
        }
        if (arguments.length == 1) {
            if (Snap.is(key, "object")) {
                for (var i in key) {
                    if (key[has](i)) {
                        this.data(i, key[i]);
                    }
                }return this;
            }
            eve("snap.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("snap.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.outerSVG
     [ method ]
     **
     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
     *
     * See also @Element.innerSVG
     = (string) SVG code for the element
    \*/
    /*\
     * Element.toString
     [ method ]
     **
     * See @Element.outerSVG
    \*/
    elproto.outerSVG = elproto.toString = toString(1);
    /*\
     * Element.innerSVG
     [ method ]
     **
     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
     = (string) SVG code for the element
    \*/
    elproto.innerSVG = toString();
    function toString(type) {
        return function () {
            var res = type ? "<" + this.type : "",
                attr = this.node.attributes,
                chld = this.node.childNodes;
            if (type) {
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    res += " " + attr[i].name + '="' + attr[i].value.replace(/"/g, '\\"') + '"';
                }
            }
            if (chld.length) {
                type && (res += ">");
                for (i = 0, ii = chld.length; i < ii; i++) {
                    if (chld[i].nodeType == 3) {
                        res += chld[i].nodeValue;
                    } else if (chld[i].nodeType == 1) {
                        res += wrap(chld[i]).toString();
                    }
                }
                type && (res += "</" + this.type + ">");
            } else {
                type && (res += "/>");
            }
            return res;
        };
    }
    elproto.toDataURL = function () {
        if (window && window.btoa) {
            var bb = this.getBBox(),
                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                x: +bb.x.toFixed(3),
                y: +bb.y.toFixed(3),
                width: +bb.width.toFixed(3),
                height: +bb.height.toFixed(3),
                contents: this.outerSVG()
            });
            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
        }
    };
    /*\
     * Fragment.select
     [ method ]
     **
     * See @Element.select
    \*/
    Fragment.prototype.select = elproto.select;
    /*\
     * Fragment.selectAll
     [ method ]
     **
     * See @Element.selectAll
    \*/
    Fragment.prototype.selectAll = elproto.selectAll;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var objectToString = Object.prototype.toString,
        Str = String,
        math = Math,
        E = "";
    function Matrix(a, b, c, d, e, f) {
        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.d = a.d;
            this.e = a.e;
            this.f = a.f;
            return;
        }
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds the given matrix to existing one
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + b * this.c,
                bNew = a * this.b + b * this.d;
            this.e += e * this.a + f * this.c;
            this.f += e * this.b + f * this.d;
            this.c = c * this.a + d * this.c;
            this.d = c * this.b + d * this.d;

            this.a = aNew;
            this.b = bNew;
            return this;
        };
        /*\
         * Matrix.multLeft
         [ method ]
         **
         * Multiplies a passed affine transform to the left: M * this.
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        Matrix.prototype.multLeft = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + c * this.b,
                cNew = a * this.c + c * this.d,
                eNew = a * this.e + c * this.f + e;
            this.b = b * this.a + d * this.b;
            this.d = b * this.c + d * this.d;
            this.f = b * this.e + d * this.f + f;

            this.a = aNew;
            this.c = cNew;
            this.e = eNew;
            return this;
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns an inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns a copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         - x (number) horizontal offset distance
         - y (number) vertical offset distance
        \*/
        matrixproto.translate = function (x, y) {
            this.e += x * this.a + y * this.c;
            this.f += x * this.b + y * this.d;
            return this;
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         - x (number) amount to be scaled, with `1` resulting in no change
         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
         - cx (number) #optional horizontal origin point from which to scale
         - cy (number) #optional vertical origin point from which to scale
         * Default cx, cy is the middle point of the element.
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.translate(cx, cy);
            this.a *= x;
            this.b *= x;
            this.c *= y;
            this.d *= y;
            (cx || cy) && this.translate(-cx, -cy);
            return this;
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         - a (number) angle of rotation, in degrees
         - x (number) horizontal origin point from which to rotate
         - y (number) vertical origin point from which to rotate
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = Snap.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            return this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.skewX
         [ method ]
         **
         * Skews the matrix along the x-axis
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skewX = function (x) {
            return this.skew(x, 0);
        };
        /*\
         * Matrix.skewY
         [ method ]
         **
         * Skews the matrix along the y-axis
         - y (number) Angle to skew along the y-axis (in degrees).
        \*/
        matrixproto.skewY = function (y) {
            return this.skew(0, y);
        };
        /*\
         * Matrix.skew
         [ method ]
         **
         * Skews the matrix
         - y (number) Angle to skew along the y-axis (in degrees).
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skew = function (x, y) {
            x = x || 0;
            y = y || 0;
            x = Snap.rad(x);
            y = Snap.rad(y);
            var c = math.tan(x).toFixed(9);
            var b = math.tan(y).toFixed(9);
            return this.add(1, b, c, 1, 0, 0);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.determinant
         [ method ]
         **
         * Finds determinant of the given matrix.
         = (number) determinant
        \*/
        matrixproto.determinant = function () {
            return this.a * this.d - this.b * this.c;
        };
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.b], [this.c, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            if (this.determinant() < 0) {
                out.scalex = -out.scalex;
            }

            // rotation
            var sin = row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = Snap.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = Snap.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Returns transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this.split();
            if (!+s.shear.toFixed(9)) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) + (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E) + (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);
    /*\
     * Snap.Matrix
     [ method ]
     **
     * Matrix constructor, extend on your own risk.
     * To create matrices use @Snap.matrix.
    \*/
    Snap.Matrix = Matrix;
    /*\
     * Snap.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns a matrix based on the given parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     * or
     - svgMatrix (SVGMatrix)
     = (object) @Matrix
    \*/
    Snap.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var has = "hasOwnProperty",
        make = Snap._.make,
        wrap = Snap._.wrap,
        is = Snap.is,
        getSomeDefs = Snap._.getSomeDefs,
        reURLValue = /^url\((['"]?)([^)]+)\1\)$/,
        $ = Snap._.$,
        URL = Snap.url,
        Str = String,
        separator = Snap._.separator,
        E = "";
    /*\
     * Snap.deurl
     [ method ]
     **
     * Unwraps path from `"url(<path>)"`.
     - value (string) url path
     = (string) unwrapped path
    \*/
    Snap.deurl = function (value) {
        var res = String(value).match(reURLValue);
        return res ? res[2] : value;
    };
    // Attributes event handlers
    eve.on("snap.util.attr.mask", function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value.type == "mask") {
                var mask = value;
            } else {
                mask = make("mask", getSomeDefs(this));
                mask.node.appendChild(value.node);
            }
            !mask.node.id && $(mask.node, {
                id: mask.id
            });
            $(this.node, {
                mask: URL(mask.id)
            });
        }
    });
    (function (clipIt) {
        eve.on("snap.util.attr.clip", clipIt);
        eve.on("snap.util.attr.clip-path", clipIt);
        eve.on("snap.util.attr.clipPath", clipIt);
    })(function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            var clip,
                node = value.node;
            while (node) {
                if (node.nodeName === "clipPath") {
                    clip = new Element(node);
                    break;
                }
                if (node.nodeName === "svg") {
                    clip = undefined;
                    break;
                }
                node = node.parentNode;
            }
            if (!clip) {
                clip = make("clipPath", getSomeDefs(this));
                clip.node.appendChild(value.node);
                !clip.node.id && $(clip.node, {
                    id: clip.id
                });
            }
            $(this.node, {
                "clip-path": URL(clip.node.id || clip.id)
            });
        }
    });
    function fillStroke(name) {
        return function (value) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1 && (value.node.firstChild.tagName == "radialGradient" || value.node.firstChild.tagName == "linearGradient" || value.node.firstChild.tagName == "pattern")) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value instanceof Element) {
                if (value.type == "radialGradient" || value.type == "linearGradient" || value.type == "pattern") {
                    if (!value.node.id) {
                        $(value.node, {
                            id: value.id
                        });
                    }
                    var fill = URL(value.node.id);
                } else {
                    fill = value.attr(name);
                }
            } else {
                fill = Snap.color(value);
                if (fill.error) {
                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                    if (grad) {
                        if (!grad.node.id) {
                            $(grad.node, {
                                id: grad.id
                            });
                        }
                        fill = URL(grad.node.id);
                    } else {
                        fill = value;
                    }
                } else {
                    fill = Str(fill);
                }
            }
            var attrs = {};
            attrs[name] = fill;
            $(this.node, attrs);
            this.node.style[name] = E;
        };
    }
    eve.on("snap.util.attr.fill", fillStroke("fill"));
    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
    eve.on("snap.util.grad.parse", function parseGrad(string) {
        string = Str(string);
        var tokens = string.match(gradrg);
        if (!tokens) {
            return null;
        }
        var type = tokens[1],
            params = tokens[2],
            stops = tokens[3];
        params = params.split(/\s*,\s*/).map(function (el) {
            return +el == el ? +el : el;
        });
        if (params.length == 1 && params[0] == 0) {
            params = [];
        }
        stops = stops.split("-");
        stops = stops.map(function (el) {
            el = el.split(":");
            var out = {
                color: el[0]
            };
            if (el[1]) {
                out.offset = parseFloat(el[1]);
            }
            return out;
        });
        var len = stops.length,
            start = 0,
            j = 0;
        function seed(i, end) {
            var step = (end - start) / (i - j);
            for (var k = j; k < i; k++) {
                stops[k].offset = +(+start + step * (k - j)).toFixed(2);
            }
            j = i;
            start = end;
        }
        len--;
        for (var i = 0; i < len; i++) {
            if ("offset" in stops[i]) {
                seed(i, stops[i].offset);
            }
        }stops[len].offset = stops[len].offset || 100;
        seed(len, stops[len].offset);
        return {
            type: type,
            params: params,
            stops: stops
        };
    });

    eve.on("snap.util.attr.d", function (value) {
        eve.stop();
        if (is(value, "array") && is(value[0], "array")) {
            value = Snap.path.toString.call(value);
        }
        value = Str(value);
        if (value.match(/[ruo]/i)) {
            value = Snap.path.toAbsolute(value);
        }
        $(this.node, { d: value });
    })(-1);
    eve.on("snap.util.attr.#text", function (value) {
        eve.stop();
        value = Str(value);
        var txt = glob.doc.createTextNode(value);
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
        this.node.appendChild(txt);
    })(-1);
    eve.on("snap.util.attr.path", function (value) {
        eve.stop();
        this.attr({ d: value });
    })(-1);
    eve.on("snap.util.attr.class", function (value) {
        eve.stop();
        this.node.className.baseVal = value;
    })(-1);
    eve.on("snap.util.attr.viewBox", function (value) {
        var vb;
        if (is(value, "object") && "x" in value) {
            vb = [value.x, value.y, value.width, value.height].join(" ");
        } else if (is(value, "array")) {
            vb = value.join(" ");
        } else {
            vb = value;
        }
        $(this.node, {
            viewBox: vb
        });
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.transform", function (value) {
        this.transform(value);
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.r", function (value) {
        if (this.type == "rect") {
            eve.stop();
            $(this.node, {
                rx: value,
                ry: value
            });
        }
    })(-1);
    eve.on("snap.util.attr.textpath", function (value) {
        eve.stop();
        if (this.type == "text") {
            var id, tp, node;
            if (!value && this.textPath) {
                tp = this.textPath;
                while (tp.node.firstChild) {
                    this.node.appendChild(tp.node.firstChild);
                }
                tp.remove();
                delete this.textPath;
                return;
            }
            if (is(value, "string")) {
                var defs = getSomeDefs(this),
                    path = wrap(defs.parentNode).path(value);
                defs.appendChild(path.node);
                id = path.id;
                path.attr({ id: id });
            } else {
                value = wrap(value);
                if (value instanceof Element) {
                    id = value.attr("id");
                    if (!id) {
                        id = value.id;
                        value.attr({ id: id });
                    }
                }
            }
            if (id) {
                tp = this.textPath;
                node = this.node;
                if (tp) {
                    tp.attr({ "xlink:href": "#" + id });
                } else {
                    tp = $("textPath", {
                        "xlink:href": "#" + id
                    });
                    while (node.firstChild) {
                        tp.appendChild(node.firstChild);
                    }
                    node.appendChild(tp);
                    this.textPath = wrap(tp);
                }
            }
        }
    })(-1);
    eve.on("snap.util.attr.text", function (value) {
        if (this.type == "text") {
            var i = 0,
                node = this.node,
                tuner = function tuner(chunk) {
                var out = $("tspan");
                if (is(chunk, "array")) {
                    for (var i = 0; i < chunk.length; i++) {
                        out.appendChild(tuner(chunk[i]));
                    }
                } else {
                    out.appendChild(glob.doc.createTextNode(chunk));
                }
                out.normalize && out.normalize();
                return out;
            };
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var tuned = tuner(value);
            while (tuned.firstChild) {
                node.appendChild(tuned.firstChild);
            }
        }
        eve.stop();
    })(-1);
    function setFontSize(value) {
        eve.stop();
        if (value == +value) {
            value += "px";
        }
        this.node.style.fontSize = value;
    }
    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
    eve.on("snap.util.attr.font-size", setFontSize)(-1);

    eve.on("snap.util.getattr.transform", function () {
        eve.stop();
        return this.transform();
    })(-1);
    eve.on("snap.util.getattr.textpath", function () {
        eve.stop();
        return this.textPath;
    })(-1);
    // Markers
    (function () {
        function getter(end) {
            return function () {
                eve.stop();
                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                if (style == "none") {
                    return style;
                } else {
                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                }
            };
        }
        function setter(end) {
            return function (value) {
                eve.stop();
                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                if (value == "" || !value) {
                    this.node.style[name] = "none";
                    return;
                }
                if (value.type == "marker") {
                    var id = value.node.id;
                    if (!id) {
                        $(value.node, { id: value.id });
                    }
                    this.node.style[name] = URL(id);
                    return;
                }
            };
        }
        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
    })();
    eve.on("snap.util.getattr.r", function () {
        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
            eve.stop();
            return $(this.node, "rx");
        }
    })(-1);
    function textExtract(node) {
        var out = [];
        var children = node.childNodes;
        for (var i = 0, ii = children.length; i < ii; i++) {
            var chi = children[i];
            if (chi.nodeType == 3) {
                out.push(chi.nodeValue);
            }
            if (chi.tagName == "tspan") {
                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                    out.push(chi.firstChild.nodeValue);
                } else {
                    out.push(textExtract(chi));
                }
            }
        }
        return out;
    }
    eve.on("snap.util.getattr.text", function () {
        if (this.type == "text" || this.type == "tspan") {
            eve.stop();
            var out = textExtract(this.node);
            return out.length == 1 ? out[0] : out;
        }
    })(-1);
    eve.on("snap.util.getattr.#text", function () {
        return this.node.textContent;
    })(-1);
    eve.on("snap.util.getattr.fill", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.fill", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.stroke", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.stroke", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.viewBox", function () {
        eve.stop();
        var vb = $(this.node, "viewBox");
        if (vb) {
            vb = vb.split(separator);
            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.points", function () {
        var p = $(this.node, "points");
        eve.stop();
        if (p) {
            return p.split(separator);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.path", function () {
        var p = $(this.node, "d");
        eve.stop();
        return p;
    })(-1);
    eve.on("snap.util.getattr.class", function () {
        return this.node.className.baseVal;
    })(-1);
    function getFontSize() {
        eve.stop();
        return this.node.style.fontSize;
    }
    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var rgNotSpace = /\S+/g,
        rgBadSpace = /[\t\r\n\f]/g,
        rgTrim = /(^\s+|\s+$)/g,
        Str = String,
        elproto = Element.prototype;
    /*\
     * Element.addClass
     [ method ]
     **
     * Adds given class name or list of class names to the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.addClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;

        if (classes.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (!~pos) {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.removeClass
     [ method ]
     **
     * Removes given class name or list of class names from the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.removeClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        if (curClasses.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.hasClass
     [ method ]
     **
     * Checks if the element has a given class name in the list of class names applied to it.
     - value (string) class name
     **
     = (boolean) `true` if the element has given class
    \*/
    elproto.hasClass = function (value) {
        var elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [];
        return !!~curClasses.indexOf(value);
    };
    /*\
     * Element.toggleClass
     [ method ]
     **
     * Add or remove one or more classes from the element, depending on either
     * the classs presence or the value of the `flag` argument.
     - value (string) class name or space separated list of class names
     - flag (boolean) value to determine whether the class should be added or removed
     **
     = (Element) original element.
    \*/
    elproto.toggleClass = function (value, flag) {
        if (flag != null) {
            if (flag) {
                return this.addClass(value);
            } else {
                return this.removeClass(value);
            }
        }
        var classes = (value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        j = 0;
        while (clazz = classes[j++]) {
            pos = curClasses.indexOf(clazz);
            if (~pos) {
                curClasses.splice(pos, 1);
            } else {
                curClasses.push(clazz);
            }
        }

        finalValue = curClasses.join(" ");
        if (className != finalValue) {
            elem.className.baseVal = finalValue;
        }
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var operators = {
        "+": function _(x, y) {
            return x + y;
        },
        "-": function _(x, y) {
            return x - y;
        },
        "/": function _(x, y) {
            return x / y;
        },
        "*": function _(x, y) {
            return x * y;
        }
    },
        Str = String,
        reUnit = /[a-z]+$/i,
        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    eve.on("snap.util.attr", function (val) {
        var plus = Str(val).match(reAddon);
        if (plus) {
            var evnt = eve.nt(),
                name = evnt.substring(evnt.lastIndexOf(".") + 1),
                a = this.attr(name),
                atr = {};
            eve.stop();
            var unit = plus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[plus[1]];
            if (aUnit && aUnit == unit) {
                val = op(parseFloat(a), +plus[2]);
            } else {
                a = this.asPX(name);
                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
            }
            if (isNaN(a) || isNaN(val)) {
                return;
            }
            atr[name] = val;
            this.attr(atr);
        }
    })(-10);
    eve.on("snap.util.equal", function (name, b) {
        var A,
            B,
            a = Str(this.attr(name) || ""),
            el = this,
            bplus = Str(b).match(reAddon);
        if (bplus) {
            eve.stop();
            var unit = bplus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[bplus[1]];
            if (aUnit && aUnit == unit) {
                return {
                    from: parseFloat(a),
                    to: op(parseFloat(a), +bplus[2]),
                    f: getUnit(aUnit)
                };
            } else {
                a = this.asPX(name);
                return {
                    from: a,
                    to: op(a, this.asPX(name, bplus[2] + unit)),
                    f: getNumber
                };
            }
        }
    })(-10);
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var proto = Paper.prototype,
        is = Snap.is;
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - rx (number) #optional horizontal radius for rounded corners, default is 0
     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
     = (object) the `rect` element
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    proto.rect = function (x, y, w, h, rx, ry) {
        var attr;
        if (ry == null) {
            ry = rx;
        }
        if (is(x, "object") && x == "[object Object]") {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                width: w,
                height: h
            };
            if (rx != null) {
                attr.rx = rx;
                attr.ry = ry;
            }
        }
        return this.el("rect", attr);
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) the `circle` element
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    proto.circle = function (cx, cy, r) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                r: r
            };
        }
        return this.el("circle", attr);
    };

    var preload = function () {
        function onerror() {
            this.parentNode.removeChild(this);
        }
        return function (src, f) {
            var img = glob.doc.createElement("img"),
                body = glob.doc.body;
            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
            img.onload = function () {
                f.call(img);
                img.onload = img.onerror = null;
                body.removeChild(img);
            };
            img.onerror = onerror;
            body.appendChild(img);
            img.src = src;
        };
    }();

    /*\
     * Paper.image
     [ method ]
     **
     * Places an image on the surface
     **
     - src (string) URI of the source image
     - x (number) x offset position
     - y (number) y offset position
     - width (number) width of the image
     - height (number) height of the image
     = (object) the `image` element
     * or
     = (object) Snap element object with type `image`
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    proto.image = function (src, x, y, width, height) {
        var el = this.el("image");
        if (is(src, "object") && "src" in src) {
            el.attr(src);
        } else if (src != null) {
            var set = {
                "xlink:href": src,
                preserveAspectRatio: "none"
            };
            if (x != null && y != null) {
                set.x = x;
                set.y = y;
            }
            if (width != null && height != null) {
                set.width = width;
                set.height = height;
            } else {
                preload(src, function () {
                    Snap._.$(el.node, {
                        width: this.offsetWidth,
                        height: this.offsetHeight
                    });
                });
            }
            Snap._.$(el.node, set);
        }
        return el;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) the `ellipse` element
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    proto.ellipse = function (cx, cy, rx, ry) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                rx: rx,
                ry: ry
            };
        }
        return this.el("ellipse", attr);
    };
    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a `<path>` element using the given string as the path's definition
     - pathString (string) #optional path string in SVG format
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
     | "M10,20L30,40"
     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
     * Note: there is a special case when a path consists of only three commands: `M10,10Rz`. In this case the path connects back to its starting point.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
    \*/
    proto.path = function (d) {
        var attr;
        if (is(d, "object") && !is(d, "array")) {
            attr = d;
        } else if (d) {
            attr = { d: d };
        }
        return this.el("path", attr);
    };
    /*\
     * Paper.g
     [ method ]
     **
     * Creates a group element
     **
     - varargs () #optional elements to nest within the group
     = (object) the `g` element
     **
     > Usage
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g(c2, c1); // note that the order of elements is different
     * or
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g();
     | g.add(c2, c1);
    \*/
    /*\
     * Paper.group
     [ method ]
     **
     * See @Paper.g
    \*/
    proto.group = proto.g = function (first) {
        var attr,
            el = this.el("g");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.svg
     [ method ]
     **
     * Creates a nested SVG element.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `svg` element
     **
    \*/
    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
        var attrs = {};
        if (is(x, "object") && y == null) {
            attrs = x;
        } else {
            if (x != null) {
                attrs.x = x;
            }
            if (y != null) {
                attrs.y = y;
            }
            if (width != null) {
                attrs.width = width;
            }
            if (height != null) {
                attrs.height = height;
            }
            if (vbx != null && vby != null && vbw != null && vbh != null) {
                attrs.viewBox = [vbx, vby, vbw, vbh];
            }
        }
        return this.el("svg", attrs);
    };
    /*\
     * Paper.mask
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except its a mask.
     **
     = (object) the `mask` element
     **
    \*/
    proto.mask = function (first) {
        var attr,
            el = this.el("mask");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.ptrn
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except its a pattern.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `pattern` element
     **
    \*/
    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
        if (is(x, "object")) {
            var attr = x;
        } else {
            attr = { patternUnits: "userSpaceOnUse" };
            if (x) {
                attr.x = x;
            }
            if (y) {
                attr.y = y;
            }
            if (width != null) {
                attr.width = width;
            }
            if (height != null) {
                attr.height = height;
            }
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            } else {
                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
            }
        }
        return this.el("pattern", attr);
    };
    /*\
     * Paper.use
     [ method ]
     **
     * Creates a <use> element.
     - id (string) @optional id of element to link
     * or
     - id (Element) @optional element to link
     **
     = (object) the `use` element
     **
    \*/
    proto.use = function (id) {
        if (id != null) {
            if (id instanceof Element) {
                if (!id.attr("id")) {
                    id.attr({ id: Snap._.id(id) });
                }
                id = id.attr("id");
            }
            if (String(id).charAt() == "#") {
                id = id.substring(1);
            }
            return this.el("use", { "xlink:href": "#" + id });
        } else {
            return Element.prototype.use.call(this);
        }
    };
    /*\
     * Paper.symbol
     [ method ]
     **
     * Creates a <symbol> element.
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     = (object) the `symbol` element
     **
    \*/
    proto.symbol = function (vx, vy, vw, vh) {
        var attr = {};
        if (vx != null && vy != null && vw != null && vh != null) {
            attr.viewBox = [vx, vy, vw, vh];
        }

        return this.el("symbol", attr);
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
     = (object) the `text` element
     **
     > Usage
     | var t1 = paper.text(50, 50, "Snap");
     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
     | // Text path usage
     | t1.attr({textpath: "M10,10L100,100"});
     | // or
     | var pth = paper.path("M10,10L100,100");
     | t1.attr({textpath: pth});
    \*/
    proto.text = function (x, y, text) {
        var attr = {};
        if (is(x, "object")) {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                text: text || ""
            };
        }
        return this.el("text", attr);
    };
    /*\
     * Paper.line
     [ method ]
     **
     * Draws a line
     **
     - x1 (number) x coordinate position of the start
     - y1 (number) y coordinate position of the start
     - x2 (number) x coordinate position of the end
     - y2 (number) y coordinate position of the end
     = (object) the `line` element
     **
     > Usage
     | var t1 = paper.line(50, 50, 100, 100);
    \*/
    proto.line = function (x1, y1, x2, y2) {
        var attr = {};
        if (is(x1, "object")) {
            attr = x1;
        } else if (x1 != null) {
            attr = {
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            };
        }
        return this.el("line", attr);
    };
    /*\
     * Paper.polyline
     [ method ]
     **
     * Draws a polyline
     **
     - points (array) array of points
     * or
     - varargs () points
     = (object) the `polyline` element
     **
     > Usage
     | var p1 = paper.polyline([10, 10, 100, 100]);
     | var p2 = paper.polyline(10, 10, 100, 100);
    \*/
    proto.polyline = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = { points: points };
        }
        return this.el("polyline", attr);
    };
    /*\
     * Paper.polygon
     [ method ]
     **
     * Draws a polygon. See @Paper.polyline
    \*/
    proto.polygon = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = { points: points };
        }
        return this.el("polygon", attr);
    };
    // gradients
    (function () {
        var $ = Snap._.$;
        // gradients' helpers
        /*\
         * Element.stops
         [ method ]
         **
         * Only for gradients!
         * Returns array of gradient stops elements.
         = (array) the stops array.
        \*/
        function Gstops() {
            return this.selectAll("stop");
        }
        /*\
         * Element.addStop
         [ method ]
         **
         * Only for gradients!
         * Adds another stop to the gradient.
         - color (string) stops color
         - offset (number) stops offset 0..100
         = (object) gradient element
        \*/
        function GaddStop(color, offset) {
            var stop = $("stop"),
                attr = {
                offset: +offset + "%"
            };
            color = Snap.color(color);
            attr["stop-color"] = color.hex;
            if (color.opacity < 1) {
                attr["stop-opacity"] = color.opacity;
            }
            $(stop, attr);
            var stops = this.stops(),
                inserted;
            for (var i = 0; i < stops.length; i++) {
                var stopOffset = parseFloat(stops[i].attr("offset"));
                if (stopOffset > offset) {
                    this.node.insertBefore(stop, stops[i].node);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                this.node.appendChild(stop);
            }
            return this;
        }
        function GgetBBox() {
            if (this.type == "linearGradient") {
                var x1 = $(this.node, "x1") || 0,
                    x2 = $(this.node, "x2") || 1,
                    y1 = $(this.node, "y1") || 0,
                    y2 = $(this.node, "y2") || 0;
                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
            } else {
                var cx = this.node.cx || .5,
                    cy = this.node.cy || .5,
                    r = this.node.r || 0;
                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
            }
        }
        /*\
         * Element.setStops
         [ method ]
         **
         * Only for gradients!
         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient
         - str (string) gradient descriptor part after `()`.
         = (object) gradient element
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         | g.setStops("#fff-#000-#f00-#fc0");
        \*/
        function GsetStops(str) {
            var grad = str,
                stops = this.stops();
            if (typeof str == "string") {
                grad = eve("snap.util.grad.parse", null, "l(0,0,0,1)" + str).firstDefined().stops;
            }
            if (!Snap.is(grad, "array")) {
                return;
            }
            for (var i = 0; i < stops.length; i++) {
                if (grad[i]) {
                    var color = Snap.color(grad[i].color),
                        attr = { "offset": grad[i].offset + "%" };
                    attr["stop-color"] = color.hex;
                    if (color.opacity < 1) {
                        attr["stop-opacity"] = color.opacity;
                    }
                    stops[i].attr(attr);
                } else {
                    stops[i].remove();
                }
            }
            for (i = stops.length; i < grad.length; i++) {
                this.addStop(grad[i].color, grad[i].offset);
            }
            return this;
        }
        function gradient(defs, str) {
            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                el;
            if (!grad) {
                return null;
            }
            grad.params.unshift(defs);
            if (grad.type.toLowerCase() == "l") {
                el = gradientLinear.apply(0, grad.params);
            } else {
                el = gradientRadial.apply(0, grad.params);
            }
            if (grad.type != grad.type.toLowerCase()) {
                $(el.node, {
                    gradientUnits: "userSpaceOnUse"
                });
            }
            var stops = grad.stops,
                len = stops.length;
            for (var i = 0; i < len; i++) {
                var stop = stops[i];
                el.addStop(stop.color, stop.offset);
            }
            return el;
        }
        function gradientLinear(defs, x1, y1, x2, y2) {
            var el = Snap._.make("linearGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            el.setStops = GsetStops;
            if (x1 != null) {
                $(el.node, {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                });
            }
            return el;
        }
        function gradientRadial(defs, cx, cy, r, fx, fy) {
            var el = Snap._.make("radialGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            if (cx != null) {
                $(el.node, {
                    cx: cx,
                    cy: cy,
                    r: r
                });
            }
            if (fx != null && fy != null) {
                $(el.node, {
                    fx: fx,
                    fy: fy
                });
            }
            return el;
        }
        /*\
         * Paper.gradient
         [ method ]
         **
         * Creates a gradient element
         **
         - gradient (string) gradient descriptor
         > Gradient Descriptor
         * The gradient descriptor is an expression formatted as
         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
         * either linear or radial.  The uppercase `L` or `R` letters
         * indicate absolute coordinates offset from the SVG surface.
         * Lowercase `l` or `r` letters indicate coordinates
         * calculated relative to the element to which the gradient is
         * applied.  Coordinates specify a linear gradient vector as
         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
         * `r` and optional `fx`, `fy` specifying a focal point away
         * from the center of the circle. Specify `<colors>` as a list
         * of dash-separated CSS color values.  Each color may be
         * followed by a custom offset value, separated with a colon
         * character.
         > Examples
         * Linear gradient, relative from top-left corner to bottom-right
         * corner, from black through red to white:
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         * Linear gradient, absolute from (0, 0) to (100, 100), from black
         * through red at 25% to white:
         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
         * Radial gradient, relative from the center of the element with radius
         * half the width, from black to white:
         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
         * To apply the gradient:
         | paper.circle(50, 50, 40).attr({
         |     fill: g
         | });
         = (object) the `gradient` element
        \*/
        proto.gradient = function (str) {
            return gradient(this.defs, str);
        };
        proto.gradientLinear = function (x1, y1, x2, y2) {
            return gradientLinear(this.defs, x1, y1, x2, y2);
        };
        proto.gradientRadial = function (cx, cy, r, fx, fy) {
            return gradientRadial(this.defs, cx, cy, r, fx, fy);
        };
        /*\
         * Paper.toString
         [ method ]
         **
         * Returns SVG code for the @Paper
         = (string) SVG code for the @Paper
        \*/
        proto.toString = function () {
            var doc = this.node.ownerDocument,
                f = doc.createDocumentFragment(),
                d = doc.createElement("div"),
                svg = this.node.cloneNode(true),
                res;
            f.appendChild(d);
            d.appendChild(svg);
            Snap._.$(svg, { xmlns: "http://www.w3.org/2000/svg" });
            res = d.innerHTML;
            f.removeChild(f.firstChild);
            return res;
        };
        /*\
         * Paper.toDataURL
         [ method ]
         **
         * Returns SVG code for the @Paper as Data URI string.
         = (string) Data URI string
        \*/
        proto.toDataURL = function () {
            if (window && window.btoa) {
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
            }
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Removes all child nodes of the paper, except <defs>.
        \*/
        proto.clear = function () {
            var node = this.node.firstChild,
                next;
            while (node) {
                next = node.nextSibling;
                if (node.tagName != "defs") {
                    node.parentNode.removeChild(node);
                } else {
                    proto.clear.call({ node: node });
                }
                node = next;
            }
        };
    })();
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        is = Snap.is,
        clone = Snap._.clone,
        has = "hasOwnProperty",
        p2s = /,?([a-z]),?/gi,
        toFloat = parseFloat,
        math = Math,
        PI = math.PI,
        mmin = math.min,
        mmax = math.max,
        pow = math.pow,
        abs = math.abs;
    function paths(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) {
                if (p[has](key) && key != ps) {
                    p[key].sleep--;
                    !p[key].sleep && delete p[key];
                }
            }
        });
        return p[ps];
    }
    function box(x, y, width, height) {
        if (x == null) {
            x = y = width = height = 0;
        }
        if (y == null) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        return {
            x: x,
            y: y,
            width: width,
            w: width,
            height: height,
            h: height,
            x2: x + width,
            y2: y + height,
            cx: x + width / 2,
            cy: y + height / 2,
            r1: math.min(width, height) / 2,
            r2: math.max(width, height) / 2,
            r0: math.sqrt(width * width + height * height) / 2,
            path: rectPath(x, y, width, height),
            vb: [x, y, width, height].join(" ")
        };
    }
    function toString() {
        return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
        var res = clone(pathArray);
        res.toString = toString;
        return res;
    }
    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    }
    function getLengthFactory(istotal, subpath) {
        function O(val) {
            return +(+val).toFixed(3);
        }
        return Snap._.cacher(function (path, length, onlystart) {
            if (path instanceof Element) {
                path = path.attr("d");
            }
            path = path2curve(path);
            var x,
                y,
                p,
                l,
                sp = "",
                subpaths = {},
                point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + O(point.start.x), O(point.start.y), O(point.m.x), O(point.m.y), O(point.x), O(point.y)];
                            if (onlystart) {
                                return sp;
                            }
                            subpaths.start = sp;
                            sp = ["M" + O(point.x), O(point.y) + "C" + O(point.n.x), O(point.n.y), O(point.end.x), O(point.end.y), O(p[5]), O(p[6])].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return point;
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            return point;
        }, null, Snap._.clone);
    }
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        // (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: { x: mx, y: my },
            n: { x: nx, y: ny },
            start: { x: ax, y: ay },
            end: { x: cx, y: cy },
            alpha: alpha
        };
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Snap.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
    }
    function isPointInsideBBox(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-.1252, .1252, -.3678, .3678, -.5873, .5873, -.7699, .7699, -.9041, .9041, -.9816, .9816],
            Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
            return;
        }
        return { x: px, y: py };
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1),
            bbox2 = bezierBBox(bez2);
        if (!isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 8),
            n2 = ~~(l2 / 8),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
            dots1.push({ x: p.x, y: p.y, t: i / n1 });
        }
        for (i = 0; i < n2 + 1; i++) {
            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
            dots2.push({ x: p.x, y: p.y, t: i / n2 });
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
    }
    function pathIntersectionNumber(path1, path2) {
        return interPathHelper(path1, path2, 1);
    }
    function interPathHelper(path1, path2, justCount) {
        path1 = path2curve(path1);
        path2 = path2curve(path2);
        var x1,
            y1,
            x2,
            y2,
            x1m,
            y1m,
            x2m,
            y2m,
            bez1,
            bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    function isPointInsidePath(path, x, y) {
        var bbox = pathBBox(path);
        return isPointInsideBBox(bbox, x, y) && interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    }
    function pathBBox(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return box();
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin.apply(0, X),
            ymin = mmin.apply(0, Y),
            xmax = mmax.apply(0, X),
            ymax = mmax.apply(0, Y),
            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
        pth.bbox = clone(bb);
        return bb;
    }
    function rectPath(x, y, w, h, r) {
        if (r) {
            return [["M", +x + +r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
        }
        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        res.toString = toString;
        return res;
    }
    function ellipsePath(x, y, rx, ry, a) {
        if (a == null && ry == null) {
            ry = rx;
        }
        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;
        if (a != null) {
            var rad = Math.PI / 180,
                x1 = x + rx * Math.cos(-ry * rad),
                x2 = x + rx * Math.cos(-a * rad),
                y1 = y + rx * Math.sin(-ry * rad),
                y2 = y + rx * Math.sin(-a * rad),
                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
            res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        }
        res.toString = toString;
        return res;
    }
    var unit2px = Snap._unit2px,
        getPath = {
        path: function path(el) {
            return el.attr("path");
        },
        circle: function circle(el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.r);
        },
        ellipse: function ellipse(el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
        },
        rect: function rect(el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
        },
        image: function image(el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
        },
        line: function line(el) {
            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
        },
        polyline: function polyline(el) {
            return "M" + el.attr("points");
        },
        polygon: function polygon(el) {
            return "M" + el.attr("points") + "z";
        },
        deflt: function deflt(el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    function pathToRelative(pathArray) {
        var pth = paths(pathArray),
            lowerCase = String.prototype.toLowerCase;
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
            pathArray = Snap.parsePathString(pathArray);
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
                pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = toString;
        pth.rel = pathClone(res);
        return res;
    }
    function pathToAbsolute(pathArray) {
        var pth = paths(pathArray);
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) {
            // rough assumption
            pathArray = Snap.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            return [["M", 0, 0]];
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0,
            pa0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            pa0 = pa[0];
            if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +pa[6] + x;
                        r[7] = +pa[7] + y;
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y].concat(pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res.concat(catmullRom2bezier(dots, crz));
                        break;
                    case "O":
                        res.pop();
                        dots = ellipsePath(x, y, pa[1], pa[2]);
                        dots.push(dots[0]);
                        res = res.concat(dots);
                        break;
                    case "U":
                        res.pop();
                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                        r = ["U"].concat(res[res.length - 1].slice(-2));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + (j % 2 ? x : y);
                        }
                }
            } else if (pa0 == "R") {
                dots = [x, y].concat(pa.slice(1));
                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                r = ["R"].concat(pa.slice(-2));
            } else if (pa0 == "O") {
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
            } else if (pa0 == "U") {
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ["U"].concat(res[res.length - 1].slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            pa0 = pa0.toUpperCase();
            if (pa0 != "O") {
                switch (r[0]) {
                    case "Z":
                        x = +mx;
                        y = +my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
        }
        res.toString = toString;
        pth.abs = pathClone(res);
        return res;
    }
    function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }
    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
    }
    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = Snap._.cacher(function (x, y, rad) {
            var X = x * math.cos(rad) - y * math.sin(rad),
                Y = x * math.sin(rad) + y * math.cos(rad);
            return { x: X, y: Y };
        });
        if (!rx || !ry) {
            return [x1, y1, x2, y2, x2, y2];
        }
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4].concat(res);
        } else {
            res = [m2, m3, m4].concat(res).join().split(",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }
    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    }

    // Returns bounding box of cubic bezier curve.
    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    // Original version: NISHIO Hirokazu
    // Modifications: https://github.com/timo22345
    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [],
            bounds = [[], []],
            a,
            b,
            c,
            t,
            t1,
            t2,
            b2ac,
            sqrtb2ac;
        for (var i = 0; i < 2; ++i) {
            if (i == 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
                if (abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = math.sqrt(b2ac);
            if (b2ac < 0) {
                continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }

        var x,
            y,
            j = tvalues.length,
            jlen = j,
            mt;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;

        return {
            min: { x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1]) },
            max: { x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1]) }
        };
    }

    function path2curve(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
            attrs2 = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null },
            processPath = function processPath(path, d, pcom) {
            var nx, ny;
            if (!path) {
                return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
            }
            !(path[0] in { T: 1, Q: 1 }) && (d.qx = d.qy = null);
            switch (path[0]) {
                case "M":
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case "A":
                    path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                    break;
                case "S":
                    if (pcom == "C" || pcom == "S") {
                        // In "S" case we have to take into account, if the previous command is C/S.
                        nx = d.x * 2 - d.bx; // And reflect the previous
                        ny = d.y * 2 - d.by; // command's control point relative to the current point.
                    } else {
                        // or some else or nothing
                        nx = d.x;
                        ny = d.y;
                    }
                    path = ["C", nx, ny].concat(path.slice(1));
                    break;
                case "T":
                    if (pcom == "Q" || pcom == "T") {
                        // In "T" case we have to take into account, if the previous command is Q/T.
                        d.qx = d.x * 2 - d.qx; // And make a reflection similar
                        d.qy = d.y * 2 - d.qy; // to case "S".
                    } else {
                        // or something else or nothing
                        d.qx = d.x;
                        d.qy = d.y;
                    }
                    path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case "Q":
                    d.qx = path[1];
                    d.qy = path[2];
                    path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case "L":
                    path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                    break;
                case "H":
                    path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                    break;
                case "V":
                    path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                    break;
                case "Z":
                    path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        },
            fixArc = function fixArc(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                var pi = pp[i];
                while (pi.length) {
                    pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                    p2 && (pcoms2[i] = "A"); // the same as above
                    pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        },
            fixM = function fixM(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                path2.splice(i, 0, ["M", a2.x, a2.y]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        },
            pcoms1 = [],
            // path commands of original path p
        pcoms2 = [],
            // path commands of original path p2
        pfirst = "",
            // temporary holder for original path command
        pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
                {
                    pcoms1[i] = pfirst; // Save current path command
                    i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
                }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) {
                // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C") {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i] != "A" && pfirst == "C") {
                    pcoms2[i] = "C";
                }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }
    function mapPath(path, matrix) {
        if (!matrix) {
            return path;
        }
        var x, y, i, j, ii, jj, pathi;
        path = path2curve(path);
        for (i = 0, ii = path.length; i < ii; i++) {
            pathi = path[i];
            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    }

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [{ x: +crp[i - 2], y: +crp[i - 1] }, { x: +crp[i], y: +crp[i + 1] }, { x: +crp[i + 2], y: +crp[i + 3] }, { x: +crp[i + 4], y: +crp[i + 5] }];
            if (z) {
                if (!i) {
                    p[0] = { x: +crp[iLen - 2], y: +crp[iLen - 1] };
                } else if (iLen - 4 == i) {
                    p[3] = { x: +crp[0], y: +crp[1] };
                } else if (iLen - 2 == i) {
                    p[2] = { x: +crp[0], y: +crp[1] };
                    p[3] = { x: +crp[2], y: +crp[3] };
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = { x: +crp[i], y: +crp[i + 1] };
                }
            }
            d.push(["C", (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
        }

        return d;
    }

    // export
    Snap.path = paths;

    /*\
     * Snap.path.getTotalLength
     [ method ]
     **
     * Returns the length of the given path in pixels
     **
     - path (string) SVG path string
     **
     = (number) length
    \*/
    Snap.path.getTotalLength = getTotalLength;
    /*\
     * Snap.path.getPointAtLength
     [ method ]
     **
     * Returns the coordinates of the point located at the given length along the given path
     **
     - path (string) SVG path string
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    Snap.path.getPointAtLength = getPointAtLength;
    /*\
     * Snap.path.getSubpath
     [ method ]
     **
     * Returns the subpath of a given path between given start and end lengths
     **
     - path (string) SVG path string
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    Snap.path.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns the length of the path in pixels (only works for `path` elements)
     = (number) length
    \*/
    elproto.getTotalLength = function () {
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
    };
    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
     **
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        return getPointAtLength(this.attr("d"), length);
    };
    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
     **
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        return Snap.path.getSubpath(this.attr("d"), from, to);
    };
    Snap._.box = box;
    /*\
     * Snap.path.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Finds dot coordinates on the given cubic bezir curve at the given t
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point,
     o     y: (number) y coordinate of the point,
     o     m: {
     o         x: (number) x coordinate of the left anchor,
     o         y: (number) y coordinate of the left anchor
     o     },
     o     n: {
     o         x: (number) x coordinate of the right anchor,
     o         y: (number) y coordinate of the right anchor
     o     },
     o     start: {
     o         x: (number) x coordinate of the start of the curve,
     o         y: (number) y coordinate of the start of the curve
     o     },
     o     end: {
     o         x: (number) x coordinate of the end of the curve,
     o         y: (number) y coordinate of the end of the curve
     o     },
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    Snap.path.findDotsAtSegment = findDotsAtSegment;
    /*\
     * Snap.path.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given cubic bezir curve
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezir curve
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.bezierBBox = bezierBBox;
    /*\
     * Snap.path.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding box
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point is inside
    \*/
    Snap.path.isPointInsideBBox = isPointInsideBBox;
    Snap.closest = function (x, y, X, Y) {
        var r = 100,
            b = box(x - r / 2, y - r / 2, r, r),
            inside = [],
            getter = X[0].hasOwnProperty("x") ? function (i) {
            return {
                x: X[i].x,
                y: X[i].y
            };
        } : function (i) {
            return {
                x: X[i],
                y: Y[i]
            };
        },
            found = 0;
        while (r <= 1e6 && !found) {
            for (var i = 0, ii = X.length; i < ii; i++) {
                var xy = getter(i);
                if (isPointInsideBBox(b, xy.x, xy.y)) {
                    found++;
                    inside.push(xy);
                    break;
                }
            }
            if (!found) {
                r *= 2;
                b = box(x - r / 2, y - r / 2, r, r);
            }
        }
        if (r == 1e6) {
            return;
        }
        var len = Infinity,
            res;
        for (i = 0, ii = inside.length; i < ii; i++) {
            var l = Snap.len(x, y, inside[i].x, inside[i].y);
            if (len > l) {
                len = l;
                inside[i].len = l;
                res = inside[i];
            }
        }
        return res;
    };
    /*\
     * Snap.path.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if bounding boxes intersect
    \*/
    Snap.path.isBBoxIntersect = isBBoxIntersect;
    /*\
     * Snap.path.intersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point,
     o         y: (number) y coordinate of the point,
     o         t1: (number) t value for segment of path1,
     o         t2: (number) t value for segment of path2,
     o         segment1: (number) order number for segment of path1,
     o         segment2: (number) order number for segment of path2,
     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1,
     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
     o     }
     o ]
    \*/
    Snap.path.intersection = pathIntersection;
    Snap.path.intersectionNumber = pathIntersectionNumber;
    /*\
     * Snap.path.isPointInside
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     *
     * Note: fill mode doesnt affect the result of this method.
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) `true` if point is inside the path
    \*/
    Snap.path.isPointInside = isPointInsidePath;
    /*\
     * Snap.path.getBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given path
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.getBBox = pathBBox;
    Snap.path.get = getPath;
    /*\
     * Snap.path.toRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into relative values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toRelative = pathToRelative;
    /*\
     * Snap.path.toAbsolute
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into absolute values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toAbsolute = pathToAbsolute;
    /*\
     * Snap.path.toCubic
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezir curves
     - pathString (string|array) path string or array of segments
     = (array) array of segments
    \*/
    Snap.path.toCubic = path2curve;
    /*\
     * Snap.path.map
     [ method ]
     **
     * Transform the path string with the given matrix
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \*/
    Snap.path.map = mapPath;
    Snap.path.toString = toString;
    Snap.path.clone = pathClone;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var mmax = Math.max,
        mmin = Math.min;

    // Set
    var Set = function Set(items) {
        this.items = [];
        this.bindings = {};
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i]) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
        setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set
     = (object) original element
    \*/
    setproto.push = function () {
        var item, len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set
     *
     * If the function returns `false`, the loop stops running.
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    /*\
     * Set.animate
     [ method ]
     **
     * Animates each element in set in sync.
     *
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     * or
     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
     > Usage
     | // animate all elements in set to radius 10
     | set.animate({r: 10}, 500, mina.easein);
     | // or
     | // animate first element to radius 10, but second to radius 20 and in different time
     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
     = (Element) the current element
    \*/
    setproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Snap._.Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = easing.dur;
            attrs = attrs.attr;
        }
        var args = arguments;
        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
            var each = true;
        }
        var begin,
            handler = function handler() {
            if (begin) {
                this.b = begin;
            } else {
                begin = this.b;
            }
        },
            cb = 0,
            set = this,
            callbacker = callback && function () {
            if (++cb == set.length) {
                callback.call(this);
            }
        };
        return this.forEach(function (el, i) {
            eve.once("snap.animcreated." + el.id, handler);
            if (each) {
                args[i] && el.animate.apply(el, args[i]);
            } else {
                el.animate(attrs, ms, easing, callbacker);
            }
        });
    };
    /*\
     * Set.remove
     [ method ]
     **
     * Removes all children of the set.
     *
     = (object) Set object
    \*/
    setproto.remove = function () {
        while (this.length) {
            this.pop().remove();
        }
        return this;
    };
    /*\
     * Set.bind
     [ method ]
     **
     * Specifies how to handle a specific attribute when applied
     * to a set.
     *
     **
     - attr (string) attribute name
     - callback (function) function to run
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     - eattr (string) attribute on the element to bind the attribute to
     = (object) Set object
    \*/
    setproto.bind = function (attr, a, b) {
        var data = {};
        if (typeof a == "function") {
            this.bindings[attr] = a;
        } else {
            var aname = b || attr;
            this.bindings[attr] = function (v) {
                data[aname] = v;
                a.attr(data);
            };
        }
        return this;
    };
    /*\
     * Set.attr
     [ method ]
     **
     * Equivalent of @Element.attr.
     = (object) Set object
    \*/
    setproto.attr = function (value) {
        var unbound = {};
        for (var k in value) {
            if (this.bindings[k]) {
                this.bindings[k](value[k]);
            } else {
                unbound[k] = value[k];
            }
        }
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(unbound);
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes range of elements from the set
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     - element (object) element to remove
     = (boolean) `true` if object was found and removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (this[i] == el) {
                this.splice(i, 1);
                return true;
            }
        }return false;
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Inserts set elements after given element.
     **
     - element (object) set will be inserted after this element
     = (object) Set object
    \*/
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    /*\
     * Set.getBBox
     [ method ]
     **
     * Union of all bboxes of the set. See @Element.getBBox.
     = (object) bounding box descriptor. See @Element.getBBox.
    \*/
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) {
            if (!this.items[i].removed) {
                var box = this.items[i].getBBox();
                x.push(box.x);
                y.push(box.y);
                x2.push(box.x + box.width);
                y2.push(box.y + box.height);
            }
        }x = mmin.apply(0, x);
        y = mmin.apply(0, y);
        x2 = mmax.apply(0, x2);
        y2 = mmax.apply(0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y,
            cx: x + (x2 - x) / 2,
            cy: y + (y2 - y) / 2
        };
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Creates a clone of the set.
     **
     = (object) New Set object
    \*/
    setproto.clone = function (s) {
        s = new Set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Snap\u2018s set";
    };
    setproto.type = "set";
    // export
    /*\
     * Snap.Set
     [ property ]
     **
     * Set constructor.
    \*/
    Snap.Set = Set;
    /*\
     * Snap.set
     [ method ]
     **
     * Creates a set and fills it with list of arguments.
     **
     = (object) New Set object
     | var r = paper.rect(0, 0, 10, 10),
     |     s1 = Snap.set(), // empty set
     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set
    \*/
    Snap.set = function () {
        var set = new Set();
        if (arguments.length) {
            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
        }
        return set;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var names = {},
        reUnit = /[%a-z]+$/i,
        Str = String;
    names.stroke = names.fill = "colour";
    function getEmpty(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t":
                return [l, 0, 0];
            case "m":
                return [l, 1, 0, 0, 1, 0, 0];
            case "r":
                if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
            case "s":
                if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
        }
    }
    function equaliseTransform(t1, t2, getBBox) {
        t1 = t1 || new Snap.Matrix();
        t2 = t2 || new Snap.Matrix();
        t1 = Snap.parseTransformString(t1.toTransformString()) || [];
        t2 = Snap.parseTransformString(t2.toTransformString()) || [];
        var maxlength = Math.max(t1.length, t2.length),
            from = [],
            to = [],
            i = 0,
            j,
            jj,
            tt1,
            tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) {
                t1 = Snap._.transform2matrix(t1, getBBox());
                t2 = Snap._.transform2matrix(t2, getBBox());
                from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                break;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: path2array(from),
            to: path2array(to),
            f: getPath(from)
        };
    }
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    function getViewBox(val) {
        return val.join(" ");
    }
    function getColour(clr) {
        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);
    }
    function getPath(path) {
        var k = 0,
            i,
            ii,
            j,
            jj,
            out,
            a,
            b = [];
        for (i = 0, ii = path.length; i < ii; i++) {
            out = "[";
            a = ['"' + path[i][0] + '"'];
            for (j = 1, jj = path[i].length; j < jj; j++) {
                a[j] = "val[" + k++ + "]";
            }
            out += a + "]";
            b[i] = out;
        }
        return Function("val", "return Snap.path.toString.call([" + b + "])");
    }
    function path2array(path) {
        var out = [];
        for (var i = 0, ii = path.length; i < ii; i++) {
            for (var j = 1, jj = path[i].length; j < jj; j++) {
                out.push(path[i][j]);
            }
        }
        return out;
    }
    function isNumeric(obj) {
        return isFinite(obj);
    }
    function arrayEqual(arr1, arr2) {
        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
            return false;
        }
        return arr1.toString() == arr2.toString();
    }
    Element.prototype.equal = function (name, b) {
        return eve("snap.util.equal", this, name, b).firstDefined();
    };
    eve.on("snap.util.equal", function (name, b) {
        var A,
            B,
            a = Str(this.attr(name) || ""),
            el = this;
        if (names[name] == "colour") {
            A = Snap.color(a);
            B = Snap.color(b);
            return {
                from: [A.r, A.g, A.b, A.opacity],
                to: [B.r, B.g, B.b, B.opacity],
                f: getColour
            };
        }
        if (name == "viewBox") {
            A = this.attr(name).vb.split(" ").map(Number);
            B = b.split(" ").map(Number);
            return {
                from: A,
                to: B,
                f: getViewBox
            };
        }
        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
            if (typeof b == "string") {
                b = Str(b).replace(/\.{3}|\u2026/g, a);
            }
            a = this.matrix;
            if (!Snap._.rgTransform.test(b)) {
                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());
            } else {
                b = Snap._.transform2matrix(b, this.getBBox());
            }
            return equaliseTransform(a, b, function () {
                return el.getBBox(1);
            });
        }
        if (name == "d" || name == "path") {
            A = Snap.path.toCubic(a, b);
            return {
                from: path2array(A[0]),
                to: path2array(A[1]),
                f: getPath(A[0])
            };
        }
        if (name == "points") {
            A = Str(a).split(Snap._.separator);
            B = Str(b).split(Snap._.separator);
            return {
                from: A,
                to: B,
                f: function f(val) {
                    return val;
                }
            };
        }
        if (isNumeric(a) && isNumeric(b)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getNumber
            };
        }
        var aUnit = a.match(reUnit),
            bUnit = Str(b).match(reUnit);
        if (aUnit && arrayEqual(aUnit, bUnit)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getUnit(aUnit)
            };
        } else {
            return {
                from: this.asPX(name),
                to: this.asPX(name, b),
                f: getNumber
            };
        }
    });
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        has = "hasOwnProperty",
        supportsTouch = "createTouch" in glob.doc,
        events = ["click", "dblclick", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"],
        touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
        getScroll = function getScroll(xy, el) {
        var name = xy == "y" ? "scrollTop" : "scrollLeft",
            doc = el && el.node ? el.node.ownerDocument : glob.doc;
        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
    },
        preventDefault = function preventDefault() {
        this.returnValue = false;
    },
        preventTouch = function preventTouch() {
        return this.originalEvent.preventDefault();
    },
        stopPropagation = function stopPropagation() {
        this.cancelBubble = true;
    },
        stopTouch = function stopTouch() {
        return this.originalEvent.stopPropagation();
    },
        addEvent = function addEvent(obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
            f = function f(e) {
            var scrollY = getScroll("y", element),
                scrollX = getScroll("x", element);
            if (supportsTouch && touchMap[has](type)) {
                for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                    if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                        var olde = e;
                        e = e.targetTouches[i];
                        e.originalEvent = olde;
                        e.preventDefault = preventTouch;
                        e.stopPropagation = stopTouch;
                        break;
                    }
                }
            }
            var x = e.clientX + scrollX,
                y = e.clientY + scrollY;
            return fn.call(element, e, x, y);
        };

        if (type !== realName) {
            obj.addEventListener(type, f, false);
        }

        obj.addEventListener(realName, f, false);

        return function () {
            if (type !== realName) {
                obj.removeEventListener(type, f, false);
            }

            obj.removeEventListener(realName, f, false);
            return true;
        };
    },
        drag = [],
        dragMove = function dragMove(e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = getScroll("y"),
            scrollX = getScroll("x"),
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches && e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            // glob.win.opera && parent.removeChild(node);
            // node.style.display = "none";
            // o = dragi.el.paper.getElementByPoint(x, y);
            // node.style.display = display;
            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
        dragUp = function dragUp(e) {
        Snap.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            eve.off("snap.drag.*." + dragi.el.id);
        }
        drag = [];
    };
    /*\
     * Element.click
     [ method ]
     **
     * Adds a click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes a click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds a double click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes a double click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds a mousedown event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes a mousedown event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds a mousemove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes a mousemove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds a mouseout event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes a mouseout event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds a mouseover event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes a mouseover event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds a mouseup event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes a mouseup event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds a touchstart event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes a touchstart event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds a touchmove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes a touchmove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds a touchend event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes a touchend event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds a touchcancel event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes a touchcancel event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            Snap[eventName] = elproto[eventName] = function (fn, scope) {
                if (Snap.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
                    });
                } else {
                    for (var i = 0, ii = this.events.length; i < ii; i++) {
                        if (this.events[i].name == eventName) {
                            try {
                                this.events[i].f.call(this);
                            } catch (e) {}
                        }
                    }
                }
                return this;
            };
            Snap["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) {
                    if (events[l].name == eventName && (events[l].f == fn || !fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                        return this;
                    }
                }return this;
            };
        })(events[i]);
    }
    /*\
     * Element.hover
     [ method ]
     **
     * Adds hover event handlers to the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes hover event handlers from the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for an element's drag gesture
     **
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
     * `drag.over.<id>` fires as well.
     *
     * Start event and start handler are called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler are called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler are called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        var el = this;
        if (!arguments.length) {
            var origTransform;
            return el.drag(function (dx, dy) {
                this.attr({
                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                });
            }, function () {
                origTransform = this.transform().local;
            });
        }
        function start(e, x, y) {
            (e.originalEvent || e).preventDefault();
            el._drag.x = x;
            el._drag.y = y;
            el._drag.id = e.identifier;
            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
            drag.push({ el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope });
            onstart && eve.on("snap.drag.start." + el.id, onstart);
            onmove && eve.on("snap.drag.move." + el.id, onmove);
            onend && eve.on("snap.drag.end." + el.id, onend);
            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
        }
        function init(e, x, y) {
            eve("snap.draginit." + el.id, el, e, x, y);
        }
        eve.on("snap.draginit." + el.id, start);
        el._drag = {};
        draggable.push({ el: el, start: start, init: init });
        el.mousedown(init);
        return el;
    };
    /*
     * Element.onDragOver
     [ method ]
     **
     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    // elproto.onDragOver = function (f) {
    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
    // };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from the given element
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) {
            if (draggable[i].el == this) {
                this.unmousedown(draggable[i].init);
                draggable.splice(i, 1);
                eve.unbind("snap.drag.*." + this.id);
                eve.unbind("snap.draginit." + this.id);
            }
        }!draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        pproto = Paper.prototype,
        rgurl = /^\s*url\((.+)\)/,
        Str = String,
        $ = Snap._.$;
    Snap.filter = {};
    /*\
     * Paper.filter
     [ method ]
     **
     * Creates a `<filter>` element
     **
     - filstr (string) SVG fragment of filter provided as a string
     = (object) @Element
     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
     > Usage
     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    pproto.filter = function (filstr) {
        var paper = this;
        if (paper.type != "svg") {
            paper = paper.paper;
        }
        var f = Snap.parse(Str(filstr)),
            id = Snap._.id(),
            width = paper.node.offsetWidth,
            height = paper.node.offsetHeight,
            filter = $("filter");
        $(filter, {
            id: id,
            filterUnits: "userSpaceOnUse"
        });
        filter.appendChild(f.node);
        paper.defs.appendChild(filter);
        return new Element(filter);
    };

    eve.on("snap.util.getattr.filter", function () {
        eve.stop();
        var p = $(this.node, "filter");
        if (p) {
            var match = Str(p).match(rgurl);
            return match && Snap.select(match[1]);
        }
    });
    eve.on("snap.util.attr.filter", function (value) {
        if (value instanceof Element && value.type == "filter") {
            eve.stop();
            var id = value.node.id;
            if (!id) {
                $(value.node, { id: value.id });
                id = value.id;
            }
            $(this.node, {
                filter: Snap.url(id)
            });
        }
        if (!value || value == "none") {
            eve.stop();
            this.node.removeAttribute("filter");
        }
    });
    /*\
     * Snap.filter.blur
     [ method ]
     **
     * Returns an SVG markup string for the blur filter
     **
     - x (number) amount of horizontal blur, in pixels
     - y (number) #optional amount of vertical blur, in pixels
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.blur(5, 10)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.blur = function (x, y) {
        if (x == null) {
            x = 2;
        }
        var def = y == null ? x : [x, y];
        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
            def: def
        });
    };
    Snap.filter.blur.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.shadow
     [ method ]
     **
     * Returns an SVG markup string for the shadow filter
     **
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - blur (number) #optional amount of blur
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * which makes blur default to `4`. Or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - opacity (number) #optional `0..1` opacity of the shadow
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
        if (opacity == null) {
            if (color == null) {
                opacity = blur;
                blur = 4;
                color = "#000";
            } else {
                opacity = color;
                color = blur;
                blur = 4;
            }
        }
        if (blur == null) {
            blur = 4;
        }
        if (opacity == null) {
            opacity = 1;
        }
        if (dx == null) {
            dx = 0;
            dy = 2;
        }
        if (dy == null) {
            dy = dx;
        }
        color = Snap.color(color);
        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
            color: color,
            dx: dx,
            dy: dy,
            blur: blur,
            opacity: opacity
        });
    };
    Snap.filter.shadow.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.grayscale
     [ method ]
     **
     * Returns an SVG markup string for the grayscale filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.grayscale = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    };
    Snap.filter.grayscale.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.sepia
     [ method ]
     **
     * Returns an SVG markup string for the sepia filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.sepia = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    };
    Snap.filter.sepia.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.saturate
     [ method ]
     **
     * Returns an SVG markup string for the saturate filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.saturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
            amount: 1 - amount
        });
    };
    Snap.filter.saturate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.hueRotate
     [ method ]
     **
     * Returns an SVG markup string for the hue-rotate filter
     **
     - angle (number) angle of rotation
     = (string) filter representation
    \*/
    Snap.filter.hueRotate = function (angle) {
        angle = angle || 0;
        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
            angle: angle
        });
    };
    Snap.filter.hueRotate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.invert
     [ method ]
     **
     * Returns an SVG markup string for the invert filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.invert = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        //        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: 1 - amount
        });
    };
    Snap.filter.invert.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.brightness
     [ method ]
     **
     * Returns an SVG markup string for the brightness filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.brightness = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
            amount: amount
        });
    };
    Snap.filter.brightness.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.contrast
     [ method ]
     **
     * Returns an SVG markup string for the contrast filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.contrast = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: .5 - amount / 2
        });
    };
    Snap.filter.contrast.toString = function () {
        return this();
    };
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var box = Snap._.box,
        is = Snap.is,
        firstLetter = /^[^a-z]*([tbmlrc])/i,
        toString = function toString() {
        return "T" + this.dx + "," + this.dy;
    };
    /*\
     * Element.getAlign
     [ method ]
     **
     * Returns shift needed to align the element relatively to given element.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
     > Usage
     | el.transform(el.getAlign(el2, "top"));
     * or
     | var dy = el.getAlign(el2, "top").dy;
    \*/
    Element.prototype.getAlign = function (el, way) {
        if (way == null && is(el, "string")) {
            way = el;
            el = null;
        }
        el = el || this.paper;
        var bx = el.getBBox ? el.getBBox() : box(el),
            bb = this.getBBox(),
            out = {};
        way = way && way.match(firstLetter);
        way = way ? way[1].toLowerCase() : "c";
        switch (way) {
            case "t":
                out.dx = 0;
                out.dy = bx.y - bb.y;
                break;
            case "b":
                out.dx = 0;
                out.dy = bx.y2 - bb.y2;
                break;
            case "m":
                out.dx = 0;
                out.dy = bx.cy - bb.cy;
                break;
            case "l":
                out.dx = bx.x - bb.x;
                out.dy = 0;
                break;
            case "r":
                out.dx = bx.x2 - bb.x2;
                out.dy = 0;
                break;
            default:
                out.dx = bx.cx - bb.cx;
                out.dy = 0;
                break;
        }
        out.toString = toString;
        return out;
    };
    /*\
     * Element.align
     [ method ]
     **
     * Aligns the element relatively to given one via transformation.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object) this element
     > Usage
     | el.align(el2, "top");
     * or
     | el.align("middle");
    \*/
    Element.prototype.align = function (el, way) {
        return this.transform("..." + this.getAlign(el, way));
    };
});

// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        has = "hasOwnProperty";
    function slice(from, to, f) {
        return function (arr) {
            var res = arr.slice(from, to);
            if (res.length == 1) {
                res = res[0];
            }
            return f ? f(res) : res;
        };
    }
    var Animation = function Animation(attr, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        this.attr = attr;
        this.dur = ms;
        easing && (this.easing = easing);
        callback && (this.callback = callback);
    };
    Snap._.Animation = Animation;
    /*\
     * Snap.animation
     [ method ]
     **
     * Creates an animation object
     **
     - attr (object) attributes of final destination
     - duration (number) duration of the animation, in milliseconds
     - easing (function) #optional one of easing functions of @mina or custom one
     - callback (function) #optional callback function that fires when animation ends
     = (object) animation object
    \*/
    Snap.animation = function (attr, ms, easing, callback) {
        return new Animation(attr, ms, easing, callback);
    };
    /*\
     * Element.inAnim
     [ method ]
     **
     * Returns a set of animations that may be able to manipulate the current element
     **
     = (object) in format:
     o {
     o     anim (object) animation object,
     o     mina (object) @mina object,
     o     curStatus (number) 0..1  status of the animation: 0  just started, 1  just finished,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
    \*/
    elproto.inAnim = function () {
        var el = this,
            res = [];
        for (var id in el.anims) {
            if (el.anims[has](id)) {
                (function (a) {
                    res.push({
                        anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                        mina: a,
                        curStatus: a.status(),
                        status: function status(val) {
                            return a.status(val);
                        },
                        stop: function stop() {
                            a.stop();
                        }
                    });
                })(el.anims[id]);
            }
        }return res;
    };
    /*\
     * Snap.animate
     [ method ]
     **
     * Runs generic animation of one number into another with a caring function
     **
     - from (number|array) number or array of numbers
     - to (number|array) number or array of numbers
     - setter (function) caring function that accepts one number argument
     - duration (number) duration, in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function to execute when animation ends
     = (object) animation object in @mina format
     o {
     o     id (string) animation id, consider it read-only,
     o     duration (function) gets or sets the duration of the animation,
     o     easing (function) easing,
     o     speed (function) gets or sets the speed of the animation,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
     | var rect = Snap().rect(0, 0, 10, 10);
     | Snap.animate(0, 10, function (val) {
     |     rect.attr({
     |         x: val
     |     });
     | }, 1000);
     | // in given context is equivalent to
     | rect.animate({x: 10}, 1000);
    \*/
    Snap.animate = function (from, to, setter, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        var now = mina.time(),
            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
        callback && eve.once("mina.finish." + anim.id, callback);
        return anim;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops all the animations for the current element
     **
     = (Element) the current element
    \*/
    elproto.stop = function () {
        var anims = this.inAnim();
        for (var i = 0, ii = anims.length; i < ii; i++) {
            anims[i].stop();
        }
        return this;
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Animates the given attributes of the element
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     = (Element) the current element
    \*/
    elproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = attrs.dur;
            attrs = attrs.attr;
        }
        var fkeys = [],
            tkeys = [],
            keys = {},
            from,
            to,
            f,
            eq,
            el = this;
        for (var key in attrs) {
            if (attrs[has](key)) {
                if (el.equal) {
                    eq = el.equal(key, Str(attrs[key]));
                    from = eq.from;
                    to = eq.to;
                    f = eq.f;
                } else {
                    from = +el.attr(key);
                    to = +attrs[key];
                }
                var len = is(from, "array") ? from.length : 1;
                keys[key] = slice(fkeys.length, fkeys.length + len, f);
                fkeys = fkeys.concat(from);
                tkeys = tkeys.concat(to);
            }
        }var now = mina.time(),
            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
            var attr = {};
            for (var key in keys) {
                if (keys[has](key)) {
                    attr[key] = keys[key](val);
                }
            }el.attr(attr);
        }, easing);
        el.anims[anim.id] = anim;
        anim._attrs = attrs;
        anim._callback = callback;
        eve("snap.animcreated." + el.id, anim);
        eve.once("mina.finish." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
            callback && callback.call(el);
        });
        eve.once("mina.stop." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
        });
        return el;
    };
});

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    // Colours are from https://www.materialui.co
    var red = "#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000",
        pink = "#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162",
        purple = "#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF",
        deeppurple = "#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA",
        indigo = "#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE",
        blue = "#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF",
        lightblue = "#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA",
        cyan = "#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4",
        teal = "#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5",
        green = "#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853",
        lightgreen = "#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17",
        lime = "#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00",
        yellow = "#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600",
        amber = "#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00",
        orange = "#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00",
        deeporange = "#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00",
        brown = "#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723",
        grey = "#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121",
        bluegrey = "#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238";
    /*\
     * Snap.mui
     [ property ]
     **
     * Contain Material UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.mui = {};
    /*\
     * Snap.flat
     [ property ]
     **
     * Contain Flat UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.flat = {};
    function saveColor(colors) {
        colors = colors.split(/(?=#)/);
        var color = new String(colors[5]);
        color[50] = colors[0];
        color[100] = colors[1];
        color[200] = colors[2];
        color[300] = colors[3];
        color[400] = colors[4];
        color[500] = colors[5];
        color[600] = colors[6];
        color[700] = colors[7];
        color[800] = colors[8];
        color[900] = colors[9];
        if (colors[10]) {
            color.A100 = colors[10];
            color.A200 = colors[11];
            color.A400 = colors[12];
            color.A700 = colors[13];
        }
        return color;
    }
    Snap.mui.red = saveColor(red);
    Snap.mui.pink = saveColor(pink);
    Snap.mui.purple = saveColor(purple);
    Snap.mui.deeppurple = saveColor(deeppurple);
    Snap.mui.indigo = saveColor(indigo);
    Snap.mui.blue = saveColor(blue);
    Snap.mui.lightblue = saveColor(lightblue);
    Snap.mui.cyan = saveColor(cyan);
    Snap.mui.teal = saveColor(teal);
    Snap.mui.green = saveColor(green);
    Snap.mui.lightgreen = saveColor(lightgreen);
    Snap.mui.lime = saveColor(lime);
    Snap.mui.yellow = saveColor(yellow);
    Snap.mui.amber = saveColor(amber);
    Snap.mui.orange = saveColor(orange);
    Snap.mui.deeporange = saveColor(deeporange);
    Snap.mui.brown = saveColor(brown);
    Snap.mui.grey = saveColor(grey);
    Snap.mui.bluegrey = saveColor(bluegrey);
    Snap.flat.turquoise = "#1abc9c";
    Snap.flat.greensea = "#16a085";
    Snap.flat.sunflower = "#f1c40f";
    Snap.flat.orange = "#f39c12";
    Snap.flat.emerland = "#2ecc71";
    Snap.flat.nephritis = "#27ae60";
    Snap.flat.carrot = "#e67e22";
    Snap.flat.pumpkin = "#d35400";
    Snap.flat.peterriver = "#3498db";
    Snap.flat.belizehole = "#2980b9";
    Snap.flat.alizarin = "#e74c3c";
    Snap.flat.pomegranate = "#c0392b";
    Snap.flat.amethyst = "#9b59b6";
    Snap.flat.wisteria = "#8e44ad";
    Snap.flat.clouds = "#ecf0f1";
    Snap.flat.silver = "#bdc3c7";
    Snap.flat.wetasphalt = "#34495e";
    Snap.flat.midnightblue = "#2c3e50";
    Snap.flat.concrete = "#95a5a6";
    Snap.flat.asbestos = "#7f8c8d";
    /*\
     * Snap.importMUIColors
     [ method ]
     **
     * Imports Material UI colours into global object.
     | Snap.importMUIColors();
     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.importMUIColors = function () {
        for (var color in Snap.mui) {
            if (Snap.mui.hasOwnProperty(color)) {
                window[color] = Snap.mui[color];
            }
        }
    };
});

module.exports = Snap;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.5.4 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\

(function (glob) {
    var version = "0.5.4",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        numsort = function numsort(a, b) {
        return a - b;
    },
        current_event,
        stop,
        events = { n: {} },
        firstDefined = function firstDefined() {
        for (var i = 0, ii = this.length; i < ii; i++) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        lastDefined = function lastDefined() {
        var i = this.length;
        while (--i) {
            if (typeof this[i] != "undefined") {
                return this[i];
            }
        }
    },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
        return ar instanceof Array || objtos.call(ar) == "[object Array]";
    },

    /*\
     * eve
     [ method ]
      * Fires event with given `name`, given scope and other parameters.
      - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers
      = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
    eve = function eve(name, scope) {
        var oldstop = stop,
            args = Array.prototype.slice.call(arguments, 2),
            listeners = eve.listeners(name),
            z = 0,
            l,
            indexed = [],
            queue = {},
            out = [],
            ce = current_event;
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for (var i = 0, ii = listeners.length; i < ii; i++) {
            if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
        }indexed.sort(numsort);
        while (indexed[z] < 0) {
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for (i = 0; i < ii; i++) {
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                    } while (l);
                } else {
                    queue[l.zIndex] = l;
                }
            } else {
                out.push(l.apply(scope, args));
                if (stop) {
                    break;
                }
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
     * eve.listeners
     [ method ]
      * Internal method which gives you array of all event handlers that will be triggered by the given `name`.
      - name (string) name of the event, dot (`.`) or slash (`/`) separated
      = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]
      * If for some reasons you dont like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.
      - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards `*` for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you dont want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = { n: {} });
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) {
                    if (e.f[i] == f) {
                        exist = true;
                        break;
                    }
                }!exist && e.f.push(f);
            })(names[i]);
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     - event (string) event name
     - varargs () and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current events name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = { n: {} };
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i,
            ii,
            j,
            jj,
            cur = [events],
            inodes = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                        inodes.unshift({
                            n: e,
                            name: names[i]
                        });
                    }
                } else {
                    for (key in e) {
                        if (e[has](key)) {
                            splice.push(e[key]);
                            inodes.unshift({
                                n: e,
                                name: key
                            });
                        }
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) {
                            if (e.f[j] == f) {
                                e.f.splice(j, 1);
                                break;
                            }
                        }!e.f.length && delete e.f;
                    }
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            var funcs = e.n[key].f;
                            for (j = 0, jj = funcs.length; j < jj; j++) {
                                if (funcs[j] == f) {
                                    funcs.splice(j, 1);
                                    break;
                                }
                            }!funcs.length && delete e.n[key].f;
                        }
                    }
                } else {
                    delete e.f;
                    for (key in e.n) {
                        if (e.n[has](key) && e.n[key].f) {
                            delete e.n[key].f;
                        }
                    }
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for (i = 0, ii = inodes.length; i < ii; i++) {
            e = inodes[i];
            for (key in e.n[e.name].f) {
                // not empty (has listeners)
                continue prune;
            }
            for (key in e.n[e.name].n) {
                // not empty (has children)
                continue prune;
            }
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function f2() {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    glob.eve = eve;
    typeof module != "undefined" && module.exports ? module.exports = eve :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return eve;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : glob.eve = eve;
})(typeof window != "undefined" ? window : undefined);

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _snapsvgImporter = __webpack_require__(11);

var _snapsvgImporter2 = _interopRequireDefault(_snapsvgImporter);

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  svg: {
    lib: _snapsvgImporter2['default'],
    pathInitial: 'M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z',
    pathOpen: 'M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z',
    animate: function animate(path) {
      var pos = 0;
      var steps = this.pathOpen.split(';');
      var stepsTotal = steps.length;
      var mina = window.mina;

      var nextStep = function nextStep() {
        if (pos > stepsTotal - 1) return;

        path.animate({ path: steps[pos] }, pos === 0 ? 400 : 500, pos === 0 ? mina.easein : mina.elastic, function () {
          nextStep();
        });

        pos++;
      };

      nextStep();
    }
  },

  morphShape: function morphShape(isOpen, width, right) {
    return {
      position: 'absolute',
      width: '100%',
      height: '100%',
      right: right ? 'inherit' : 0,
      left: right ? 0 : 'inherit',
      MozTransform: right ? 'rotateY(180deg)' : 'rotateY(0deg)',
      MsTransform: right ? 'rotateY(180deg)' : 'rotateY(0deg)',
      OTransform: right ? 'rotateY(180deg)' : 'rotateY(0deg)',
      WebkitTransform: right ? 'rotateY(180deg)' : 'rotateY(0deg)',
      transform: right ? 'rotateY(180deg)' : 'rotateY(0deg)'
    };
  },

  menuWrap: function menuWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      MsTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      OTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      WebkitTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(100%, 0, 0)' : 'translate3d(-100%, 0, 0)',
      transition: isOpen ? 'transform 0.4s 0s' : 'transform 0.4s'
    };
  },

  menu: function menu(isOpen, width, right) {
    width -= 140;
    return {
      position: 'fixed',
      MozTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transition: isOpen ? 'opacity 0.1s 0.4s cubic-bezier(.17, .67, .1, 1.27), transform 0.1s 0.4s cubic-bezier(.17, .67, .1, 1.27)' : 'opacity 0s 0.3s cubic-bezier(.17, .67, .1, 1.27), transform 0s 0.3s cubic-bezier(.17, .67, .1, 1.27)',
      opacity: isOpen ? 1 : 0
    };
  },

  item: function item(isOpen, width, right, nthChild) {
    width -= 140;
    return {
      MozTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      MsTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      OTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      WebkitTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transition: isOpen ? 'opacity 0.3s 0.4s, transform 0.3s 0.4s' : 'opacity 0s 0.3s cubic-bezier(.17, .67, .1, 1.27), transform 0s 0.3s cubic-bezier(.17, .67, .1, 1.27)',
      opacity: isOpen ? 1 : 0
    };
  },

  closeButton: function closeButton(isOpen, width, right) {
    width -= 140;
    return {
      MozTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      MsTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      OTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      WebkitTransform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transform: isOpen ? 'translate3d(0, 0, 0)' : right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)',
      transition: isOpen ? 'opacity 0.3s 0.4s cubic-bezier(.17, .67, .1, 1.27), transform 0.3s 0.4s cubic-bezier(.17, .67, .1, 1.27)' : 'opacity 0s 0.3s cubic-bezier(.17, .67, .1, 1.27), transform 0s 0.3s cubic-bezier(.17, .67, .1, 1.27)',
      opacity: isOpen ? 1 : 0
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transition: 'all 0.5s'
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0) rotateY(15deg)' : 'translate3d(' + width + ', 0, 0) rotateY(-15deg)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0) rotateY(15deg)' : 'translate3d(' + width + ', 0, 0) rotateY(-15deg)',
      OTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0) rotateY(15deg)' : 'translate3d(' + width + ', 0, 0) rotateY(-15deg)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0) rotateY(15deg)' : 'translate3d(' + width + ', 0, 0) rotateY(-15deg)',
      transform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0) rotateY(15deg)' : 'translate3d(' + width + ', 0, 0) rotateY(-15deg)',
      transformOrigin: right ? '100% 50%' : '0% 50%',
      transformStyle: 'preserve-3d',
      transition: 'all 0.5s'
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      perspective: '1500px',
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  pageWrap: function pageWrap(isOpen, width) {
    return {
      MozTransform: isOpen ? '' : 'translate3d(0, 0, -' + width + ')',
      MsTransform: isOpen ? '' : 'translate3d(0, 0, -' + width + ')',
      OTransform: isOpen ? '' : 'translate3d(0, 0, -' + width + ')',
      WebkitTransform: isOpen ? '' : 'translate3d(0, 0, -' + width + ')',
      transform: isOpen ? '' : 'translate3d(0, 0, -' + width + ')',
      transformOrigin: '100%',
      transformStyle: 'preserve-3d',
      transition: 'all 0.5s'
    };
  },

  outerContainer: function outerContainer() {
    return {
      perspective: '1500px'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, -600px) rotateY(20deg)' : 'translate3d(100px, 0, -600px) rotateY(-20deg)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, -600px) rotateY(20deg)' : 'translate3d(100px, 0, -600px) rotateY(-20deg)',
      OTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, -600px) rotateY(20deg)' : 'translate3d(100px, 0, -600px) rotateY(-20deg)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-100px, 0, -600px) rotateY(20deg)' : 'translate3d(100px, 0, -600px) rotateY(-20deg)',
      transform: isOpen ? '' : right ? 'translate3d(-100px, 0, -600px) rotateY(20deg)' : 'translate3d(100px, 0, -600px) rotateY(-20deg)',
      transformStyle: 'preserve-3d',
      transition: 'all 0.5s',
      overflow: isOpen ? '' : 'hidden'
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      perspective: '1500px',
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  menuWrap: function menuWrap(isOpen) {
    return {
      MozTransform: isOpen ? '' : 'translate3d(0, -100%, 0)',
      MsTransform: isOpen ? '' : 'translate3d(0, -100%, 0)',
      OTransform: isOpen ? '' : 'translate3d(0, -100%, 0)',
      WebkitTransform: isOpen ? '' : 'translate3d(0, -100%, 0)',
      transform: isOpen ? '' : 'translate3d(0, -100%, 0)',
      transition: 'all 0.5s ease-in-out'
    };
  },

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transition: 'all 0.5s'
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      perspective: '1500px',
      perspectiveOrigin: '0% 50%',
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var _menuFactory = __webpack_require__(0);

var _menuFactory2 = _interopRequireDefault(_menuFactory);

var styles = {

  menuWrap: function menuWrap(isOpen, width, right) {
    return {
      visibility: isOpen ? 'visible' : 'hidden',
      MozTransform: 'translate3d(0, 0, 0)',
      MsTransform: 'translate3d(0, 0, 0)',
      OTransform: 'translate3d(0, 0, 0)',
      WebkitTransform: 'translate3d(0, 0, 0)',
      transform: 'translate3d(0, 0, 0)',
      zIndex: 1
    };
  },

  overlay: function overlay(isOpen, width, right) {
    return {
      zIndex: 4,
      MozTransform: isOpen ? right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      MsTransform: isOpen ? right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      OTransform: isOpen ? right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      WebkitTransform: isOpen ? right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      transform: isOpen ? right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      transition: 'all 0.5s',
      visibility: isOpen ? 'visible' : 'hidden'
    };
  },

  pageWrap: function pageWrap(isOpen, width, right) {
    return {
      MozTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      MsTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      OTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      WebkitTransform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transform: isOpen ? '' : right ? 'translate3d(-' + width + ', 0, 0)' : 'translate3d(' + width + ', 0, 0)',
      transition: 'all 0.5s',
      zIndex: 2,
      position: 'relative'
    };
  },

  burgerIcon: function burgerIcon(isOpen, width, right) {
    return {
      MozTransform: isOpen ? right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      MsTransform: isOpen ? right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      OTransform: isOpen ? right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      WebkitTransform: isOpen ? right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      transform: isOpen ? right ? 'translate3d(' + width + ', 0, 0)' : 'translate3d(-' + width + ', 0, 0)' : 'translate3d(0, 0, 0)',
      transition: 'all 0.1s',
      position: 'relative',
      zIndex: 3
    };
  },

  outerContainer: function outerContainer(isOpen) {
    return {
      overflow: isOpen ? '' : 'hidden'
    };
  }
};

exports['default'] = (0, _menuFactory2['default'])(styles);
module.exports = exports['default'];

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var isTouchDevice = window.innerWidth < 769;

function NavUrls() {
	var arrayOfNavLinks = [];
	var navElement = document.querySelector('[data-nav]');
	var links = navElement.getElementsByTagName('a');

	for (var i = 0; i < links.length; i++) {
		arrayOfNavLinks.push({ href: links[i].href, text: links[i].innerText });
	}

	return arrayOfNavLinks;
}

exports.default = NavUrls;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzYxNGVhNDg0YWNiOWUzZTQ2OTgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9zbmFwc3ZnSW1wb3J0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL21vYmlsZU1lbnUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9CdXJnZXJNZW51LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvc2xpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9iYXNlU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvQnVyZ2VySWNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL0Nyb3NzSWNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL3N0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvZWxhc3RpYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc25hcHN2Zy1janMvZGlzdC9zbmFwLnN2Zy1janMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZS9ldmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9idWJibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9wdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvcHVzaFJvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL3NjYWxlRG93bi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL3NjYWxlUm90YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvZmFsbERvd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9yZXZlYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWxzL25hdlVybHMuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZ2V0IiwiZ2V0IiwiX3gzIiwiX3g0IiwiX3g1IiwiX2FnYWluIiwiX2Z1bmN0aW9uIiwib2JqZWN0IiwicHJvcGVydHkiLCJyZWNlaXZlciIsIkZ1bmN0aW9uIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInVuZGVmaW5lZCIsInBhcmVudCIsImdldFByb3RvdHlwZU9mIiwiZ2V0dGVyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlYWN0MiIsIl9yZWFjdERvbSIsIl9yZWFjdERvbTIiLCJfcHJvcFR5cGVzIiwiX3Byb3BUeXBlczIiLCJfYmFzZVN0eWxlcyIsIl9iYXNlU3R5bGVzMiIsIl9CdXJnZXJJY29uIiwiX0J1cmdlckljb24yIiwiX0Nyb3NzSWNvbiIsIl9Dcm9zc0ljb24yIiwic3R5bGVzIiwiTWVudSIsIl9Db21wb25lbnQiLCJzdGF0ZSIsImlzT3BlbiIsInRvZ2dsZU1lbnUiLCJfdGhpcyIsIm9wdGlvbnMiLCJub1N0YXRlQ2hhbmdlIiwibmV3U3RhdGUiLCJhcHBseVdyYXBwZXJTdHlsZXMiLCJzZXRTdGF0ZSIsIm9uU3RhdGVDaGFuZ2UiLCJ0aW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwic2V0IiwiYm9keUNsYXNzTmFtZSIsImJvZHkiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJwYWdlV3JhcCIsInBhZ2VXcmFwSWQiLCJoYW5kbGVFeHRlcm5hbFdyYXBwZXIiLCJvdXRlckNvbnRhaW5lciIsIm91dGVyQ29udGFpbmVySWQiLCJpZCIsIndyYXBwZXJTdHlsZXMiLCJodG1sIiwid3JhcHBlciIsImdldEVsZW1lbnRCeUlkIiwiY29uc29sZSIsImVycm9yIiwiYnVpbHRTdHlsZXMiLCJnZXRTdHlsZSIsInByb3AiLCJzdHlsZSIsImZvckVhY2giLCJlbGVtZW50IiwiZ2V0U3R5bGVzIiwiZWwiLCJpbmRleCIsImlubGluZSIsInByb3BOYW1lIiwicmVwbGFjZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwib3V0cHV0Iiwid2lkdGgiLCJyaWdodCIsImxpc3RlbkZvckNsb3NlIiwiZSIsIndpbmRvdyIsImV2ZW50Iiwia2V5Q29kZSIsInNob3VsZERpc2FibGVPdmVybGF5Q2xpY2siLCJkaXNhYmxlT3ZlcmxheUNsaWNrIiwiY29tcG9uZW50V2lsbE1vdW50IiwiRXJyb3IiLCJjb21wb25lbnREaWRNb3VudCIsIm9ua2V5ZG93biIsImJpbmQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsIl90aGlzMiIsInN2ZyIsIm1vcnBoU2hhcGUiLCJmaW5kRE9NTm9kZSIsInBhdGgiLCJsaWIiLCJzZWxlY3QiLCJhbmltYXRlIiwiYXR0ciIsInBhdGhJbml0aWFsIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm5leHRQcm9wcyIsInJlbmRlciIsIl90aGlzMyIsImNyZWF0ZUVsZW1lbnQiLCJub092ZXJsYXkiLCJjbGFzc05hbWUiLCJvdmVybGF5Q2xhc3NOYW1lIiwib25DbGljayIsIm1vcnBoU2hhcGVDbGFzc05hbWUiLCJoZWlnaHQiLCJ2aWV3Qm94IiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImQiLCJtZW51Q2xhc3NOYW1lIiwiaXRlbUxpc3RDbGFzc05hbWUiLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkcmVuIiwiaXRlbSIsImV4dHJhUHJvcHMiLCJjbG9uZUVsZW1lbnQiLCJjdXN0b21Dcm9zc0ljb24iLCJjdXN0b21JY29uIiwiY3Jvc3NCdXR0b25DbGFzc05hbWUiLCJjcm9zc0NsYXNzTmFtZSIsImN1c3RvbUJ1cmdlckljb24iLCJidXJnZXJCdXR0b25DbGFzc05hbWUiLCJiYXJDbGFzc05hbWUiLCJidXJnZXJCYXJDbGFzc05hbWUiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJvbmVPZlR5cGUiLCJvbmVPZiIsImJvb2wiLCJmdW5jIiwiaXNSZXF1aXJlZCIsIm51bWJlciIsImRlZmF1bHRQcm9wcyIsIm1vZHVsZSIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwiZW1wdHlGdW5jdGlvbiIsInRoYXRSZXR1cm5zIiwidGhhdFJldHVybnNGYWxzZSIsInRoYXRSZXR1cm5zVHJ1ZSIsInRoYXRSZXR1cm5zTnVsbCIsInRoYXRSZXR1cm5zVGhpcyIsInRoYXRSZXR1cm5zQXJndW1lbnQiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImEiLCJiIiwiYyIsImYiLCJhcmdzIiwiYXJnSW5kZXgiLCJuYW1lIiwiZnJhbWVzVG9Qb3AiLCJ3YXJuaW5nIiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsIm1lc3NhZ2UiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJhcHBseSIsImNvbmNhdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidmFsIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJrZXlzIiwiZXJyIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwiY2hlY2tEQ0UiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiU25hcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJtZW51RWxlbWVudCIsIl9hc3NpZ24iLCJSZWFjdFZlcnNpb24iLCJoYXNTeW1ib2wiLCJSRUFDVF9DQUxMX1RZUEUiLCJSRUFDVF9SRVRVUk5fVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImRpc3BsYXlOYW1lIiwid2FybmluZ0tleSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiaXNNb3VudGVkIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiY2FsbGJhY2siLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImNvbnRleHQiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJmb3JjZVVwZGF0ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwibWV0aG9kTmFtZSIsImluZm8iLCJmbk5hbWUiLCJQdXJlQ29tcG9uZW50IiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJBc3luY0NvbXBvbmVudCIsImFzeW5jQ29tcG9uZW50UHJvdG90eXBlIiwidW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50IiwiUmVhY3RDdXJyZW50T3duZXIiLCJjdXJyZW50IiwiUkVTRVJWRURfUFJPUFMiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nUmVmIiwiUmVhY3RFbGVtZW50IiwidHlwZSIsInNlbGYiLCJvd25lciIsIl9vd25lciIsIl9zdG9yZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwiX3NlbGYiLCJfc291cmNlIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImdldEN1cnJlbnRTdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJpbXBsIiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZXNjYXBlIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsIm1hdGNoIiwiZGlkV2FybkFib3V0TWFwcyIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwidGV4dCIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJrZXlQcmVmaXgiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJwb3AiLCJyZXN1bHQiLCJjb3VudCIsInJlbGVhc2VUcmF2ZXJzZUNvbnRleHQiLCJwdXNoIiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsImlzQXJyYXkiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJpaSIsIm5leHQiLCJkb25lIiwiYWRkZW5kdW0iLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJjb21wb25lbnQiLCJ0b1N0cmluZyIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImFycmF5IiwicHJlZml4IiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiY291bnRDaGlsZHJlbiIsInRvQXJyYXkiLCJvbmx5Q2hpbGQiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldERpc3BsYXlOYW1lIiwiVkFMSURfRlJBR01FTlRfUFJPUFMiLCJNYXAiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bSIsImVsZW1lbnRQcm9wcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwibm9kZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJQcm9wVHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImhhcyIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJSZWFjdCIsIm9ubHkiLCJ1bnN0YWJsZV9Bc3luY0NvbXBvbmVudCIsIkZyYWdtZW50IiwiY3JlYXRlRmFjdG9yeSIsInZlcnNpb24iLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiZGVmYXVsdCIsIlJlYWN0JDMiLCJyZWFjdCIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiRXZlbnRMaXN0ZW5lciIsImdldEFjdGl2ZUVsZW1lbnQiLCJzaGFsbG93RXF1YWwiLCJjb250YWluc05vZGUiLCJmb2N1c05vZGUiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoZWNrZWQiLCJpbm5lckhUTUwiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJNVVNUX1VTRV9QUk9QRVJUWSIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsInByb3BlcnRpZXMiLCJsb3dlckNhc2VkIiwidG9Mb3dlckNhc2UiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsInByb3BlcnR5TmFtZSIsIm11dGF0aW9uTWV0aG9kIiwibXVzdFVzZVByb3BlcnR5IiwiaGFzQm9vbGVhblZhbHVlIiwiaGFzTnVtZXJpY1ZhbHVlIiwiaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUiLCJoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIiwiaGFzU3RyaW5nQm9vbGVhblZhbHVlIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwic2hvdWxkU2V0QXR0cmlidXRlIiwiaXNSZXNlcnZlZFByb3AiLCJzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUiLCJnZXRQcm9wZXJ0eUluZm8iLCJzbGljZSIsImluamVjdGlvbiIsIkhUTUxET01Qcm9wZXJ0eUNvbmZpZyIsImFsbG93RnVsbFNjcmVlbiIsImFzeW5jIiwiYXV0b0ZvY3VzIiwiYXV0b1BsYXkiLCJjYXB0dXJlIiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImZvcm1Ob1ZhbGlkYXRlIiwiaGlkZGVuIiwibG9vcCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub1ZhbGlkYXRlIiwib3BlbiIsInBsYXlzSW5saW5lIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm93cyIsInJvd1NwYW4iLCJzY29wZWQiLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZSIsInN0YXJ0Iiwic3BhbiIsInNwZWxsQ2hlY2siLCJ0YWJJbmRleCIsIml0ZW1TY29wZSIsImFjY2VwdENoYXJzZXQiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwicmVtb3ZlQXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidmFsaWRpdHkiLCJiYWRJbnB1dCIsIm93bmVyRG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEiLCJOUyIsInhsaW5rIiwieG1sIiwiQVRUUlMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsImF1dG9SZXZlcnNlIiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsInByZXNlcnZlQWxwaGEiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbExhbmciLCJ4bWxTcGFjZSIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwib3JpZ2luYWwiLCJyZWFjdE5hbWUiLCJSZWFjdEVycm9yVXRpbHMiLCJfY2F1Z2h0RXJyb3IiLCJfaGFzQ2F1Z2h0RXJyb3IiLCJfcmV0aHJvd0Vycm9yIiwiX2hhc1JldGhyb3dFcnJvciIsImluamVjdEVycm9yVXRpbHMiLCJpbmplY3RlZEVycm9yVXRpbHMiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJoYXNDYXVnaHRFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJyZXRocm93Q2F1Z2h0RXJyb3IiLCJmdW5jQXJncyIsImRpc3BhdGNoRXZlbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZGlkRXJyb3IiLCJjYWxsQ2FsbGJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0VHlwZSIsImRpZFNldEVycm9yIiwiaXNDcm9zc09yaWdpbkVycm9yIiwib25FcnJvciIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwbHVnaW5zIiwiZXh0cmFjdEV2ZW50cyIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50VHlwZXMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJkaXNwYXRjaENvbmZpZyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJpbmplY3Rpb24kMiIsImluamVjdENvbXBvbmVudFRyZWUiLCJJbmplY3RlZCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJzaW11bGF0ZWQiLCJsaXN0ZW5lciIsImluc3QiLCJjdXJyZW50VGFyZ2V0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsImFyciIsImNiIiwic2NvcGUiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwiaXNQZXJzaXN0ZW50IiwicmVsZWFzZSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsIiwiaXNJbnRlcmFjdGl2ZSIsInRhZyIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiaW5qZWN0aW9uJDEiLCJnZXRMaXN0ZW5lciIsInN0YXRlTm9kZSIsInRvcExldmVsVHlwZSIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJwcm9jZXNzaW5nRXZlbnRRdWV1ZSIsIkV2ZW50UGx1Z2luSHViIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiTWF0aCIsInJhbmRvbSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJwcmVjYWNoZUZpYmVyTm9kZSQxIiwiaG9zdEluc3QiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsInBhcmVudHMiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsImdldEluc3RhbmNlRnJvbU5vZGUkMSIsImdldE5vZGVGcm9tSW5zdGFuY2UkMSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSIsInVwZGF0ZUZpYmVyUHJvcHMkMSIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsInByZWNhY2hlRmliZXJOb2RlIiwidXBkYXRlRmliZXJQcm9wcyIsImdldFBhcmVudCIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaW5zdEEiLCJpbnN0QiIsImRlcHRoQSIsInRlbXBBIiwiZGVwdGhCIiwidGVtcEIiLCJkZXB0aCIsImFsdGVybmF0ZSIsImdldFBhcmVudEluc3RhbmNlIiwidHJhdmVyc2VUd29QaGFzZSIsImZuIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsIl90YXJnZXRJbnN0IiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJFdmVudFByb3BhZ2F0b3JzIiwiY29udGVudEtleSIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJjYW5Vc2VET00iLCJkb2N1bWVudEVsZW1lbnQiLCJjb21wb3NpdGlvblN0YXRlIiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwicmVzZXQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsIkVWRU5UX1BPT0xfU0laRSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJEYXRlIiwibm93IiwiZGVmYXVsdFByZXZlbnRlZCIsImlzVHJ1c3RlZCIsIlN5bnRoZXRpY0V2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJJbnRlcmZhY2UiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJkZXN0cnVjdG9yIiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsImF1Z21lbnRDbGFzcyIsIkNsYXNzIiwiU3VwZXIiLCJFIiwiYWRkRXZlbnRQb29saW5nVG8iLCJjb25zdHJ1Y3QiLCJ0aGF0IiwiZ2V0VmFsIiwiaXNGdW5jdGlvbiIsImFjdGlvbiIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwiZXZlbnRQb29sIiwicmVsZWFzZVBvb2xlZEV2ZW50IiwiZ2V0UG9vbGVkIiwiU3ludGhldGljRXZlbnQkMSIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJkYXRhIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsImRpc3BhdGNoTWFya2VyIiwiSW5wdXRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImRvY3VtZW50TW9kZSIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIm9wZXJhIiwicGFyc2VJbnQiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImJlZm9yZUlucHV0IiwiYnViYmxlZCIsImNhcHR1cmVkIiwiY29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJjdHJsS2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImdldENvbXBvc2l0aW9uRXZlbnRUeXBlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiaXNDb21wb3NpbmciLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImN1c3RvbURhdGEiLCJnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzIiwid2hpY2giLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImNoYXIiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJmaWJlckhvc3RDb21wb25lbnQiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50IiwiaG9zdENvbXBvbmVudEltcGwiLCJyZXN0b3JlVGFyZ2V0IiwicmVzdG9yZVF1ZXVlIiwicmVzdG9yZVN0YXRlT2ZUYXJnZXQiLCJpbnRlcm5hbEluc3RhbmNlIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSIsImluamVjdGlvbiQzIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicXVldWVkVGFyZ2V0cyIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudCIsImZpYmVyQmF0Y2hlZFVwZGF0ZXMiLCJib29ra2VlcGluZyIsImlzTmVzdGluZ0JhdGNoZWQiLCJiYXRjaGVkVXBkYXRlcyIsIlJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uIiwiaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyIsIl9iYXRjaGVkVXBkYXRlcyIsImluamVjdGlvbiQ0Iiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsImNvbG9yIiwiZGF0ZSIsImRhdGV0aW1lIiwiZW1haWwiLCJtb250aCIsInBhc3N3b3JkIiwicmFuZ2UiLCJzZWFyY2giLCJ0ZWwiLCJ0aW1lIiwidXJsIiwid2VlayIsImlzVGV4dElucHV0RWxlbWVudCIsImVsZW0iLCJub2RlTmFtZSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJzcmNFbGVtZW50IiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJub2RlVHlwZSIsInVzZUhhc0ZlYXR1cmUiLCJpbXBsZW1lbnRhdGlvbiIsImhhc0ZlYXR1cmUiLCJpc0V2ZW50U3VwcG9ydGVkIiwiZXZlbnROYW1lU3VmZml4IiwiaXNTdXBwb3J0ZWQiLCJpc0NoZWNrYWJsZSIsImdldFRyYWNrZXIiLCJfdmFsdWVUcmFja2VyIiwiZGV0YWNoVHJhY2tlciIsImdldFZhbHVlRnJvbU5vZGUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImN1cnJlbnRWYWx1ZSIsInRyYWNrZXIiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwidHJhY2siLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsImV2ZW50VHlwZXMkMSIsImNoYW5nZSIsImNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudCIsImFjdGl2ZUVsZW1lbnRJbnN0Iiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImF0dGFjaEV2ZW50IiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImRldGFjaEV2ZW50IiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiX3dyYXBwZXJTdGF0ZSIsImNvbnRyb2xsZWQiLCJnZXRBdHRyaWJ1dGUiLCJDaGFuZ2VFdmVudFBsdWdpbiIsIl9pc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJnZXRUYXJnZXRJbnN0RnVuYyIsImhhbmRsZUV2ZW50RnVuYyIsIkRPTUV2ZW50UGx1Z2luT3JkZXIiLCJVSUV2ZW50SW50ZXJmYWNlIiwidmlldyIsIlN5bnRoZXRpY1VJRXZlbnQiLCJtb2RpZmllcktleVRvUHJvcCIsIkFsdCIsIkNvbnRyb2wiLCJNZXRhIiwiU2hpZnQiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJnZXRNb2RpZmllclN0YXRlIiwia2V5UHJvcCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsIk1vdXNlRXZlbnRJbnRlcmZhY2UiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwiYnV0dG9uIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJldmVudFR5cGVzJDIiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIndpbiIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwicmVsYXRlZCIsImZyb21Ob2RlIiwidG9Ob2RlIiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsIlJlYWN0SW50ZXJuYWxzIiwiTm9FZmZlY3QiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkVyciIsIlJlZiIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsImlzRmliZXJNb3VudGVkSW1wbCIsImVmZmVjdFRhZyIsImlzRmliZXJNb3VudGVkIiwib3duZXJGaWJlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwicGFyZW50QSIsInBhcmVudEIiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFIiwiY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wiLCJmaW5kUm9vdENvbnRhaW5lck5vZGUiLCJjb250YWluZXJJbmZvIiwiZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwicmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsImhhbmRsZVRvcExldmVsSW1wbCIsImFuY2VzdG9yIiwicm9vdCIsIl9oYW5kbGVUb3BMZXZlbCIsIl9lbmFibGVkIiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJoYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJlbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsImhhbmRsZXJCYXNlTmFtZSIsImxpc3RlbiIsInRyYXBDYXB0dXJlZEV2ZW50IiwiUmVhY3RET01FdmVudExpc3RlbmVyIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInByZWZpeGVzIiwidmVuZG9yUHJlZml4ZXMiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJwcmVmaXhNYXAiLCJ0b3BMZXZlbFR5cGVzJDEiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQmx1ciIsInRvcENhbmNlbCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ2xvc2UiLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZCIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvZ2dsZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsIkJyb3dzZXJFdmVudENvbnN0YW50cyIsInRvcExldmVsVHlwZXMiLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0IiwibGlzdGVuVG8iLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiZ2V0TGVhZk5vZGUiLCJmaXJzdENoaWxkIiwiZ2V0U2libGluZ05vZGUiLCJuZXh0U2libGluZyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJvZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwidGV4dENvbnRlbnQiLCJnZXRPZmZzZXRzIiwib3V0ZXJOb2RlIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUkJDEiLCJmb2N1c09mZnNldCIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwiaW5kZXhXaXRoaW5BbmNob3IiLCJpbmRleFdpdGhpbkZvY3VzIiwib3V0ZXIiLCJub2RlVmFsdWUiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsIm1pbiIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiQxIiwicmVzdG9yZVNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJpbnB1dCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwiZXZlbnRUeXBlcyQzIiwiYWN0aXZlRWxlbWVudCQxIiwiYWN0aXZlRWxlbWVudEluc3QkMSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJTZWxlY3RFdmVudFBsdWdpbiIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJjaGFyQ29kZSIsIm5vcm1hbGl6ZUtleSIsIkVzYyIsIlNwYWNlYmFyIiwiTGVmdCIsIlVwIiwiUmlnaHQiLCJEb3duIiwiRGVsIiwiV2luIiwiQXBwcyIsIlNjcm9sbCIsIk1velByaW50YWJsZUtleSIsInRyYW5zbGF0ZVRvS2V5IiwiZ2V0RXZlbnRLZXkiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwicmVwZWF0IiwibG9jYWxlIiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIkRyYWdFdmVudEludGVyZmFjZSIsImRhdGFUcmFuc2ZlciIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJldmVudFR5cGVzJDQiLCJ0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWciLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsInRvcEV2ZW50Iiwia25vd25IVE1MVG9wTGV2ZWxUeXBlcyIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiZW5hYmxlQXN5bmNTdWJ0cmVlQVBJIiwiZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTSIsImVuYWJsZUNyZWF0ZVJvb3QiLCJlbmFibGVVc2VyVGltaW5nQVBJIiwiZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyIiwiZW5hYmxlTm9vcFJlY29uY2lsZXIiLCJlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciIsImRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiY3JlYXRlQ3Vyc29yIiwiY3Vyc29yIiwicmVzZXQkMSIsImRlc2NyaWJlRmliZXIiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIiLCJ3b3JrSW5Qcm9ncmVzcyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSIsIlJlYWN0RGVidWdDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtIiwicmVzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50UGhhc2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiY2xlYXJNYXJrcyIsIm1lYXN1cmUiLCJjbGVhck1lYXN1cmVzIiwiY3VycmVudEZpYmVyIiwiY3VycmVudFBoYXNlIiwiY3VycmVudFBoYXNlRmliZXIiLCJpc0NvbW1pdHRpbmciLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQiLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSIsImNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AiLCJlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCIsImlzV2FpdGluZ0ZvckNhbGxiYWNrIiwibGFiZWxzSW5DdXJyZW50Q29tbWl0IiwiU2V0IiwiZm9ybWF0TWFya05hbWUiLCJtYXJrTmFtZSIsImZvcm1hdExhYmVsIiwibGFiZWwiLCJ3YXJuaW5nJCQxIiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJiZWdpbkZpYmVyTWFyayIsIl9kZWJ1Z0lEIiwiYWRkIiwiY2xlYXJGaWJlck1hcmsiLCJlbmRGaWJlck1hcmsiLCJzaG91bGRJZ25vcmVGaWJlciIsImNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQiLCJwYXVzZVRpbWVycyIsIl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nIiwicmVzdW1lVGltZXJzUmVjdXJzaXZlbHkiLCJyZXN1bWVUaW1lcnMiLCJyZWNvcmRFZmZlY3QiLCJyZWNvcmRTY2hlZHVsZVVwZGF0ZSIsInN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIiLCJzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIiLCJkaWRFeHBpcmUiLCJzdGFydFdvcmtUaW1lciIsImNhbmNlbFdvcmtUaW1lciIsInN0b3BXb3JrVGltZXIiLCJzdG9wRmFpbGVkV29ya1RpbWVyIiwic3RhcnRQaGFzZVRpbWVyIiwic3RvcFBoYXNlVGltZXIiLCJzdGFydFdvcmtMb29wVGltZXIiLCJuZXh0VW5pdE9mV29yayIsInN0b3BXb3JrTG9vcFRpbWVyIiwiaW50ZXJydXB0ZWRCeSIsInN0YXJ0Q29tbWl0VGltZXIiLCJjbGVhciIsInN0b3BDb21taXRUaW1lciIsInN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciIsInByZXZpb3VzQ29udGV4dCIsImdldFVubWFza2VkQ29udGV4dCIsImhhc093bkNvbnRleHQiLCJpc0NvbnRleHRQcm92aWRlciIsImNhY2hlQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQiLCJnZXRNYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwiaGFzQ29udGV4dENoYW5nZWQiLCJpc0NvbnRleHRDb25zdW1lciIsImNoaWxkQ29udGV4dFR5cGVzIiwicG9wQ29udGV4dFByb3ZpZGVyIiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJyZXNldENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImV4cGlyYXRpb25UaW1lVG9NcyIsImV4cGlyYXRpb25UaW1lIiwiY2VpbGluZyIsIm51bSIsInByZWNpc2lvbiIsImNvbXB1dGVFeHBpcmF0aW9uQnVja2V0IiwiY3VycmVudFRpbWUiLCJleHBpcmF0aW9uSW5NcyIsImJ1Y2tldFNpemVNcyIsIk5vQ29udGV4dCIsIkFzeW5jVXBkYXRlcyIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiZGVidWdDb3VudGVyIiwiRmliZXJOb2RlIiwiaW50ZXJuYWxDb250ZXh0VGFnIiwicGVuZGluZ1Byb3BzIiwibWVtb2l6ZWRQcm9wcyIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRTdGF0ZSIsIm5leHRFZmZlY3QiLCJmaXJzdEVmZmVjdCIsImxhc3RFZmZlY3QiLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImVsZW1lbnRzIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsImNvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbUNhbGwiLCJoYW5kbGVyIiwiY3JlYXRlRmliZXJGcm9tUmV0dXJuIiwicmV0dXJuTm9kZSIsImNyZWF0ZUZpYmVyRnJvbVBvcnRhbCIsInBvcnRhbCIsInBlbmRpbmdDaGlsZHJlbiIsImNyZWF0ZUZpYmVyUm9vdCIsImh5ZHJhdGUiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsImlzUmVhZHlGb3JDb21taXQiLCJmaW5pc2hlZFdvcmsiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRTY2hlZHVsZWRSb290Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsImhhc0xvZ2dlZEVycm9yIiwiY2F0Y2hFcnJvcnMiLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0Iiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImNyZWF0ZVVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwicXVldWUiLCJmaXJzdCIsImxhc3QiLCJjYWxsYmFja0xpc3QiLCJoYXNGb3JjZVVwZGF0ZSIsImlzSW5pdGlhbGl6ZWQiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRRdWV1ZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiaXNSZXBsYWNlIiwiaXNGb3JjZWQiLCJfY2FsbGJhY2tMaXN0IiwiY29tbWl0Q2FsbGJhY2tzIiwiX2NhbGxiYWNrIiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQiLCJzY2hlZHVsZVdvcmsiLCJjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyIiwibWVtb2l6ZVByb3BzIiwibWVtb2l6ZVN0YXRlIiwibmV4dENhbGxiYWNrIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib2xkU3RhdGUiLCJuZXdDb250ZXh0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsIm5vR2V0SW5pdGlhbFN0YXRlT25FUzYiLCJnZXRJbml0aWFsU3RhdGUiLCJub0dldERlZmF1bHRQcm9wc09uRVM2Iiwibm9JbnN0YW5jZVByb3BUeXBlcyIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwicmVzZXRJbnB1dFBvaW50ZXJzIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJjdG9yIiwibmVlZHNDb250ZXh0IiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJpc0FycmF5JDEiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInN0cmluZ1JlZiIsIl9zdHJpbmdSZWYiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJyZXR1cm5GaWJlciIsIm5ld0NoaWxkIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ2FsbCIsInVwZGF0ZVJldHVybiIsInVwZGF0ZVBvcnRhbCIsInVwZGF0ZUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJwb3NzaWJsZU1hcCIsIl9uZXdDaGlsZHJlbiIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ3IiwicmVjb25jaWxlU2luZ2xlQ2FsbCIsInJlY29uY2lsZVNpbmdsZVJldHVybiIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiaXNPYmplY3QiLCJfaXNNb2NrRnVuY3Rpb24iLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsIndhcm5lZEFib3V0U3RhdGVsZXNzUmVmcyIsIlJlYWN0RmliZXJCZWdpbldvcmsiLCJob3N0Q29udGV4dCIsImh5ZHJhdGlvbkNvbnRleHQiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsInVzZVN5bmNTY2hlZHVsaW5nIiwic2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSIsInB1c2hIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGFpbmVyIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImRlYnVnU291cmNlIiwidXBkYXRlQ2FsbENvbXBvbmVudCIsIm5leHRDYWxsIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiYmFpbG91dE9uTG93UHJpb3JpdHkiLCJuZXh0U3RhdGUiLCJiZWdpbldvcmsiLCJiZWdpbkZhaWxlZFdvcmsiLCJSZWFjdEZpYmVyQ29tcGxldGVXb3JrIiwiY3JlYXRlSW5zdGFuY2UiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZXBhcmVVcGRhdGUiLCJtdXRhdGlvbiIsInBlcnNpc3RlbmNlIiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJwb3BIb3N0Q29udGV4dCIsImdldEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInBvcEh5ZHJhdGlvblN0YXRlIiwibWFya1VwZGF0ZSIsImFwcGVuZEFsbFJldHVybnMiLCJyZXR1cm5zIiwibW92ZUNhbGxUb0hhbmRsZXJQaGFzZSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZVBheWxvYWQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjdXJyZW50SG9zdENvbnRleHQiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJfY3VycmVudEhvc3RDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfaW5zdGFuY2UiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiIsImhhc0NhdWdodEVycm9yJDEiLCJjbGVhckNhdWdodEVycm9yJDEiLCJSZWFjdEZpYmVyQ29tbWl0V29yayIsImNhcHR1cmVFcnJvciIsImdldFB1YmxpY0luc3RhbmNlIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJjb21taXRMaWZlQ3ljbGVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImNvbW1pdE1vdW50IiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiY3VycmVudFJlZiIsImNvbW1pdFVubW91bnQiLCJjb21taXROZXN0ZWRVbm1vdW50cyIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiZGV0YWNoRmliZXIiLCJjb21taXRDb250YWluZXIiLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJlbXB0eUNoaWxkU2V0IiwiX3BlbmRpbmdDaGlsZHJlbiIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRVcGRhdGUiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0VGV4dFVwZGF0ZSIsImFwcGVuZENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsInJvb3RJbnN0YW5jZSIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJuZXh0Q29udGV4dCIsInJlc2V0SG9zdENvbnRhaW5lciIsIlJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0IiwiaHlkcmF0aW9uIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiaXNIeWRyYXRpbmciLCJwYXJlbnRJbnN0YW5jZSIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJwYXJlbnRQcm9wcyIsIl90eXBlIiwiX3Byb3BzIiwiX3RleHQiLCJ0cnlIeWRyYXRlIiwibmV4dEluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24iLCJkZWJ1Z1Rvb2wiLCJSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEiLCJkZWZhdWx0U2hvd0RpYWxvZyIsImNhcHR1cmVkRXJyb3IiLCJzaG93RGlhbG9nIiwibG9nQ2FwdHVyZWRFcnJvciIsImxvZ0Vycm9yIiwic3VwcHJlc3NMb2dnaW5nIiwic3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZyIsImNvbXBvbmVudFN0YWNrIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJlcnJvckJvdW5kYXJ5Rm91bmQiLCJ3aWxsUmV0cnkiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrIiwiY2FuY2VsRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJfY29tcG9uZW50U3RhY2siLCJfY29tcG9uZW50TmFtZSIsImVycm9yQm91bmRhcnkiLCJlZmZlY3RmdWxGaWJlciIsImNvbXB1dGVBc3luY0V4cGlyYXRpb24iLCJyZWNhbGN1bGF0ZUN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbk1zIiwic2NoZWR1bGVXb3JrSW1wbCIsImNoZWNrUm9vdE5lZWRzQ2xlYXJpbmciLCJpc0Vycm9yUmVjb3ZlcnkiLCJyZXF1ZXN0V29yayIsImRlZmVycmVkVXBkYXRlcyIsInByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQiLCJzeW5jVXBkYXRlcyIsImZpcnN0U2NoZWR1bGVkUm9vdCIsImxhc3RTY2hlZHVsZWRSb290IiwiY2FsbGJhY2tFeHBpcmF0aW9uVGltZSIsImNhbGxiYWNrSUQiLCJpc1JlbmRlcmluZyIsIm5leHRGbHVzaGVkUm9vdCIsIm5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUiLCJkZWFkbGluZURpZEV4cGlyZSIsImhhc1VuaGFuZGxlZEVycm9yIiwidW5oYW5kbGVkRXJyb3IiLCJkZWFkbGluZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiaXNVbmJhdGNoaW5nVXBkYXRlcyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrIiwic2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uIiwiY3VycmVudE1zIiwidGltZW91dCIsInBlcmZvcm1Bc3luY1dvcmsiLCJwZXJmb3JtV29ya09uUm9vdCIsInBlcmZvcm1Xb3JrIiwiZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QiLCJoaWdoZXN0UHJpb3JpdHlXb3JrIiwiaGlnaGVzdFByaW9yaXR5Um9vdCIsInByZXZpb3VzU2NoZWR1bGVkUm9vdCIsInByZXZpb3VzRmx1c2hlZFJvb3QiLCJkbCIsIm1pbkV4cGlyYXRpb25UaW1lIiwiX2Vycm9yNCIsIl9maW5pc2hlZFdvcmsiLCJ0aW1lUmVtYWluaW5nIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsInVuYmF0Y2hlZFVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQxIiwiX1JlYWN0RmliZXJTY2hlZHVsZXIiLCJzY2hlZHVsZVRvcExldmVsVXBkYXRlIiwiZmluZEhvc3RJbnN0YW5jZSIsImhvc3RGaWJlciIsImNyZWF0ZUNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lciIsIm9uTW91bnRDb250YWluZXIiLCJvblVubW91bnRDb250YWluZXIiLCJvblVwZGF0ZUNvbnRhaW5lciIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImNvbnRhaW5lckZpYmVyIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJkZXZUb29sc0NvbmZpZyIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQyIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMyIsInJlYWN0UmVjb25jaWxlciIsImNyZWF0ZVBvcnRhbCQxIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3ciLCJySUMiLCJjSUMiLCJmcmFtZUNhbGxiYWNrIiwiSW5maW5pdHkiLCJ0aW1lb3V0SUQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwic2NoZWR1bGVkUklDQ2FsbGJhY2siLCJpc0lkbGVTY2hlZHVsZWQiLCJ0aW1lb3V0VGltZSIsImlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQiLCJmcmFtZURlYWRsaW5lIiwicHJldmlvdXNGcmFtZVRpbWUiLCJhY3RpdmVGcmFtZVRpbWUiLCJmcmFtZURlYWRsaW5lT2JqZWN0IiwiZGlkVGltZW91dCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsInBvc3RNZXNzYWdlIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJSZWdFeHAiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImlzTmFOIiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsImV4cGVjdGVkIiwic3RyaW5nVmFsdWUiLCJnZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJkZWxldGVWYWx1ZUZvclByb3BlcnR5IiwibmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMiLCJoYXNSZWFkT25seVZhbHVlIiwiY2hlY2tib3giLCJpbWFnZSIsInJhZGlvIiwic3VibWl0Iiwib25DaGFuZ2UiLCJ0YWdOYW1lIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldEhvc3RQcm9wcyIsImhvc3RQcm9wcyIsIm1heCIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdFdyYXBwZXJTdGF0ZSIsInVwZGF0ZUNoZWNrZWQiLCJ1cGRhdGVXcmFwcGVyIiwidmFsdWVBc051bWJlciIsInBhcnNlRmxvYXQiLCJwb3N0TW91bnRXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxIiwidXBkYXRlTmFtZWRDb3VzaW5zIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJKU09OIiwic3RyaW5naWZ5Iiwib3RoZXJOb2RlIiwiZm9ybSIsIm90aGVyUHJvcHMiLCJmbGF0dGVuQ2hpbGRyZW4iLCJ2YWxpZGF0ZVByb3BzIiwicG9zdE1vdW50V3JhcHBlciQxIiwiZ2V0SG9zdFByb3BzJDEiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInVwZGF0ZU9wdGlvbnMiLCJwcm9wVmFsdWUiLCJzZXREZWZhdWx0U2VsZWN0ZWQiLCJzZWxlY3RlZFZhbHVlcyIsInNlbGVjdGVkVmFsdWUiLCJkZWZhdWx0U2VsZWN0ZWQiLCJfc2VsZWN0ZWRWYWx1ZSIsIl9pMiIsImdldEhvc3RQcm9wcyQyIiwiaW5pdFdyYXBwZXJTdGF0ZSQxIiwid2FzTXVsdGlwbGUiLCJwb3N0TW91bnRXcmFwcGVyJDIiLCJwb3N0VXBkYXRlV3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMiIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiZ2V0SG9zdFByb3BzJDMiLCJpbml0V3JhcHBlclN0YXRlJDIiLCJ1cGRhdGVXcmFwcGVyJDEiLCJuZXdWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIkMyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyIsIkhUTUxfTkFNRVNQQUNFJDEiLCJNQVRIX05BTUVTUEFDRSIsIlNWR19OQU1FU1BBQ0UiLCJOYW1lc3BhY2VzIiwibWF0aG1sIiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJwYXJlbnROYW1lc3BhY2UiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsIm5hbWVzcGFjZVVSSSIsInN2Z05vZGUiLCJzZXRUZXh0Q29udGVudCIsImxhc3RDaGlsZCIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiLCJwcmVmaXhLZXkiLCJzdWJzdHJpbmciLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaXNDdXN0b21Qcm9wZXJ0eSIsImlzRW1wdHkiLCJ0cmltIiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwic2V0UHJvcGVydHkiLCJvbWl0dGVkQ2xvc2VUYWdzIiwiYXJlYSIsImJhc2UiLCJiciIsImNvbCIsImVtYmVkIiwiaHIiLCJpbWciLCJrZXlnZW4iLCJsaW5rIiwibWV0YSIsInBhcmFtIiwid2JyIiwidm9pZEVsZW1lbnRUYWdzIiwibWVudWl0ZW0iLCJIVE1MJDEiLCJhc3NlcnRWYWxpZFByb3BzIiwiaXNDdXN0b21Db21wb25lbnQiLCJpcyIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwiZ2V0U3RhY2tBZGRlbmR1bSQxIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJkaXIiLCJlbmN0eXBlIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYW5nIiwibGlzdCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtZXRob2QiLCJtaW5sZW5ndGgiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicm9sZSIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2Nyb2xsaW5nIiwic2hhcGUiLCJzaXplcyIsInNwZWxsY2hlY2siLCJzcmMiLCJzcmNkb2MiLCJzcmNsYW5nIiwic3Jjc2V0Iiwic3VtbWFyeSIsInRhYmluZGV4IiwidGl0bGUiLCJ1c2VtYXAiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yaW50ZXJwb2xhdGlvbiIsImNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnMiLCJjb2xvcnByb2ZpbGUiLCJjb2xvcnJlbmRlcmluZyIsImNvbnRlbnRzY3JpcHR0eXBlIiwiY29udGVudHN0eWxldHlwZSIsImN4IiwiY3kiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrIiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNlZWQiLCJzaGFwZXJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyY29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRtZXRob2QiLCJzdGFydG9mZnNldCIsInN0ZGRldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2h0aWxlcyIsInN0b3Bjb2xvciIsInN0b3BvcGFjaXR5Iiwic3RyaWtldGhyb3VnaHBvc2l0aW9uIiwic3RyaWtldGhyb3VnaHRoaWNrbmVzcyIsInN0cm9rZSIsInN0cm9rZWRhc2hhcnJheSIsInN0cm9rZWRhc2hvZmZzZXQiLCJzdHJva2VsaW5lY2FwIiwic3Ryb2tlbGluZWpvaW4iLCJzdHJva2VtaXRlcmxpbWl0Iiwic3Ryb2tld2lkdGgiLCJzdHJva2VvcGFjaXR5Iiwic3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nIiwic3VwcHJlc3NoeWRyYXRpb253YXJuaW5nIiwic3VyZmFjZXNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyIsInRhcmdldHgiLCJ0YXJnZXR5IiwidGV4dGFuY2hvciIsInRleHRkZWNvcmF0aW9uIiwidGV4dGxlbmd0aCIsInRleHRyZW5kZXJpbmciLCJ0cmFuc2Zvcm0iLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJ0YWR2eSIsInZlcnRvcmlnaW54IiwidmVydG9yaWdpbnkiLCJ2aGFuZ2luZyIsInZpZGVvZ3JhcGhpYyIsInZpZXdib3giLCJ2aWV3dGFyZ2V0IiwidmlzaWJpbGl0eSIsInZtYXRoZW1hdGljYWwiLCJ2b2NhYiIsIndpZHRocyIsIndvcmRzcGFjaW5nIiwid3JpdGluZ21vZGUiLCJ4MSIsIngyIiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwiZ2V0U3RhY2tBZGRlbmR1bSQyIiwid2FybmVkUHJvcGVydGllcyQxIiwiaGFzT3duUHJvcGVydHkkMSIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiY2FuVXNlRXZlbnRTeXN0ZW0iLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiIsImRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uIiwiZGlkV2FyblNoYWR5RE9NIiwiREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwiLCJTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkciLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIiwiQVVUT0ZPQ1VTIiwiQ0hJTERSRU4iLCJTVFlMRSIsIkhUTUwiLCJIVE1MX05BTUVTUEFDRSIsIndhcm5lZFVua25vd25UYWdzIiwiZGlhbG9nIiwidmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCIsIk5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCIsIk5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCIsIm5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSIsIm1hcmt1cCIsIm1hcmt1cFN0cmluZyIsIndhcm5Gb3JUZXh0RGlmZmVyZW5jZSIsInNlcnZlclRleHQiLCJjbGllbnRUZXh0Iiwibm9ybWFsaXplZENsaWVudFRleHQiLCJub3JtYWxpemVkU2VydmVyVGV4dCIsIndhcm5Gb3JQcm9wRGlmZmVyZW5jZSIsInNlcnZlclZhbHVlIiwiY2xpZW50VmFsdWUiLCJub3JtYWxpemVkQ2xpZW50VmFsdWUiLCJub3JtYWxpemVkU2VydmVyVmFsdWUiLCJ3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzIiwiYXR0cmlidXRlTmFtZXMiLCJuYW1lcyIsIndhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciIsIm5vcm1hbGl6ZUhUTUwiLCJ0ZXN0RWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImVuc3VyZUxpc3RlbmluZ1RvIiwicm9vdENvbnRhaW5lckVsZW1lbnQiLCJpc0RvY3VtZW50T3JGcmFnbWVudCIsImdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lciIsIm1lZGlhRXZlbnRzIiwidHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQiLCJvbmNsaWNrIiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJwcm9wS2V5IiwibmV4dFByb3AiLCJuZXh0SHRtbCIsImNhblNldFRleHRDb250ZW50IiwidXBkYXRlRE9NUHJvcGVydGllcyIsIndhc0N1c3RvbUNvbXBvbmVudFRhZyIsImNyZWF0ZUVsZW1lbnQkMSIsImRpdiIsImNyZWF0ZVRleHROb2RlJDEiLCJjcmVhdGVUZXh0Tm9kZSIsInNldEluaXRpYWxQcm9wZXJ0aWVzJDEiLCJyYXdQcm9wcyIsInNoYWR5Um9vdCIsImRpZmZQcm9wZXJ0aWVzJDEiLCJsYXN0UmF3UHJvcHMiLCJuZXh0UmF3UHJvcHMiLCJsYXN0UHJvcHMiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJsYXN0UHJvcCIsImxhc3RIdG1sIiwidXBkYXRlUHJvcGVydGllcyQxIiwiZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxIiwiZXh0cmFBdHRyaWJ1dGVOYW1lcyIsImF0dHJpYnV0ZXMiLCJyYXdIdG1sIiwic2VydmVySFRNTCIsImV4cGVjdGVkSFRNTCIsImV4cGVjdGVkU3R5bGUiLCJvd25OYW1lc3BhY2UiLCJkaWZmSHlkcmF0ZWRUZXh0JDEiLCJ0ZXh0Tm9kZSIsImlzRGlmZmVyZW50Iiwid2FybkZvclVubWF0Y2hlZFRleHQkMSIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMSIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEiLCJSZWFjdERPTUZpYmVyQ29tcG9uZW50Iiwic2V0SW5pdGlhbFByb3BlcnRpZXMiLCJkaWZmUHJvcGVydGllcyIsInVwZGF0ZVByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzIiwiZGlmZkh5ZHJhdGVkVGV4dCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwidXBkYXRlZEFuY2VzdG9ySW5mbyQxIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwicGFyZW50VGFnIiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImRpZFdhcm4iLCJjaGlsZFRhZyIsImNoaWxkVGV4dCIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwiaW52YWxpZFBhcmVudE9yQW5jZXN0b3IiLCJhbmNlc3RvclRhZyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJ2YWxpZGF0ZURPTU5lc3RpbmckMSIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiZXZlbnRzRW5hYmxlZCIsInNlbGVjdGlvbkluZm9ybWF0aW9uIiwiaXNWYWxpZENvbnRhaW5lciIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50Iiwic2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCIsIkRPTVJlbmRlcmVyIiwidmFsaWRhdGVkVGFnIiwiX2FuY2VzdG9ySW5mbyIsInBhcmVudEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHREZXYiLCJfbmFtZXNwYWNlIiwiX2FuY2VzdG9ySW5mbzIiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJfX2h0bWwiLCJmb2N1cyIsImJlZm9yZUNoaWxkIiwid2FybmVkQWJvdXRIeWRyYXRlQVBJIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJfcmVhY3RSb290Q29udGFpbmVyIiwiaG9zdEluc3RhbmNlIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwic2hvdWxkSHlkcmF0ZSIsIndhcm5lZCIsInJvb3RTaWJsaW5nIiwibmV3Um9vdCIsImNyZWF0ZVBvcnRhbCIsIlJlYWN0Um9vdCIsInVubW91bnQiLCJSZWFjdERPTSIsImNvbXBvbmVudE9yRWxlbWVudCIsIndhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJjb250YWluZXJOb2RlIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCIsIl9yb290RWwiLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzIiwiY3JlYXRlUm9vdCIsImZvdW5kRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInByb3RvY29sIiwiUmVhY3RET00kMiIsIlJlYWN0RE9NJDMiLCJyZWFjdERvbSIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsInJlbW92ZSIsInJlZ2lzdGVyRGVmYXVsdCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImlzVGV4dE5vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNOb2RlIiwiTm9kZSIsImh5cGhlbmF0ZSIsIm1zUGF0dGVybiIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiY2FtZWxpemUiLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJuYXZVcmxzIiwibW9iaWxlV2lkdGgiLCJNb2JpbGVNZW51Iiwic2hvdWxkTWVudVJlbmRlciIsImlubmVyV2lkdGgiLCJibUJ1cmdlckJ1dHRvbiIsInBvc2l0aW9uIiwiYm1CdXJnZXJCYXJzIiwiYmFja2dyb3VuZCIsImJtQ3Jvc3NCdXR0b24iLCJibUNyb3NzIiwiYm1NZW51V3JhcCIsImJtTWVudSIsInBhZGRpbmciLCJmb250U2l6ZSIsImJtTW9ycGhTaGFwZSIsImJtSXRlbUxpc3QiLCJ0ZXh0QWxpZ24iLCJibU92ZXJsYXkiLCJpc01lbnVPcGVuIiwibmF2VXJsIiwic2xpZGUiLCJlbGFzdGljIiwiYnViYmxlIiwicHVzaFJvdGF0ZSIsInNjYWxlRG93biIsInNjYWxlUm90YXRlIiwiZmFsbERvd24iLCJyZXZlYWwiLCJfbWVudUZhY3RvcnkiLCJfbWVudUZhY3RvcnkyIiwiSVRFUkFUT1JfU1lNQk9MIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlciIsImluc3RhbmNlT2YiLCJjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyIiwiY3JlYXRlTm9kZUNoZWNrZXIiLCJvYmplY3RPZiIsImNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInByb2Nlc3MiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJlbnRyeSIsImlzU3ltYm9sIiwib3ZlcmxheSIsIk1velRyYW5zZm9ybSIsIk1zVHJhbnNmb3JtIiwiT1RyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsIm1lbnVXcmFwIiwibWVudSIsImJveFNpemluZyIsIml0ZW1MaXN0Iiwib3V0bGluZSIsImJ1cmdlckljb24iLCJfeCIsIl94MiIsIkJ1cmdlckljb24iLCJob3ZlciIsImdldExpbmVTdHlsZSIsImJ1dHRvblN0eWxlIiwibWFyZ2luIiwiYm9yZGVyIiwiYm1JY29uIiwiYmFyIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3V0IiwiQ3Jvc3NJY29uIiwiZ2V0Q3Jvc3NTdHlsZSIsImJ1dHRvbldyYXBwZXJTdHlsZSIsInRleHRJbmRlbnQiLCJudGhDaGlsZCIsIl9zbmFwc3ZnSW1wb3J0ZXIiLCJfc25hcHN2Z0ltcG9ydGVyMiIsInBhdGhPcGVuIiwibWluYSIsImVhc2Vpbm91dCIsIndoaXRlU3BhY2UiLCJldmUiLCJhbmltYXRpb25zIiwicmVxdWVzdEFuaW1GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImdldFRpbWUiLCJyZXF1ZXN0SUQiLCJpZGdlbiIsImlkcHJlZml4IiwiSUQiLCJkaWZmIiwiQSIsIkIiLCJyZXMiLCJkaWYiLCJiYiIsInRpbWVyIiwic3RhIiwiZHMiLCJzcGQiLCJkdXJhdGlvbiIsInN0b3BpdCIsInBhdXNlIiwicGRpZiIsInJlc3VtZSIsImZyYW1lIiwiaiIsImpqIiwiZWFzaW5nIiwibGVuIiwiYW5pbSIsImxpbmVhciIsInN0YXR1cyIsInN0b3AiLCJnZXRCeUlkIiwiZWFzZW91dCIsInBvdyIsImVhc2VpbiIsInEiLCJRIiwic3FydCIsIlgiLCJhYnMiLCJZIiwidCIsImJhY2tpbiIsImJhY2tvdXQiLCJzaW4iLCJQSSIsImJvdW5jZSIsInAiLCJsIiwidyIsImgiLCJFbGVtZW50IiwiZ2xvYiIsIlBhcGVyIiwiU3RyIiwidG9GbG9hdCIsInRvSW50IiwibWF0aCIsIm1tYXgiLCJtbWluIiwicm91bmQiLCJTIiwib2JqZWN0VG9TdHJpbmciLCJJU1VSTCIsImNvbG91clJlZ0V4cCIsImJlemllcnJnIiwic2VwYXJhdG9yIiwid2hpdGVzcGFjZSIsImNvbW1hU3BhY2VzIiwiaHNyZyIsImhzIiwicmciLCJwYXRoQ29tbWFuZCIsInRDb21tYW5kIiwicGF0aFZhbHVlcyIsImh1YiIsIlVSTCIsIiQiLCJjcmVhdGVDb21tZW50IiwiZ2V0QXR0cmlidXRlTlMiLCJnZXRBdHRycyIsImF0dHJzIiwib3V0IiwibyIsInRva2VuUmVnZXgiLCJvYmpOb3RhdGlvblJlZ2V4IiwicmVwbGFjZXIiLCJhbGwiLCJxdW90ZSIsInF1b3RlZE5hbWUiLCJpc0Z1bmMiLCJzdHIiLCJyZXB1c2giLCJzcGxpY2UiLCJjYWNoZXIiLCJwb3N0cHJvY2Vzc29yIiwibmV3ZiIsImNhY2hlIiwic2hpZnQiLCJhbmdsZSIsIngzIiwieTMiLCJhdGFuMiIsInJhZCIsImRlZyIsInhfeSIsInhfeV93X2giLCJ0YW4iLCJjb3MiLCJhc2luIiwiYWNvcyIsImF0YW4iLCJsZW4yIiwiY2xvc2VzdFBvaW50IiwiZGlzdGFuY2UyIiwicGF0aE5vZGUiLCJwYXRoTGVuZ3RoIiwiZ2V0VG90YWxMZW5ndGgiLCJwYXRoU2VnTGlzdCIsIm51bWJlck9mSXRlbXMiLCJiZXN0IiwiYmVzdExlbmd0aCIsImJlc3REaXN0YW5jZSIsInNjYW4iLCJzY2FuTGVuZ3RoIiwic2NhbkRpc3RhbmNlIiwiZ2V0UG9pbnRBdExlbmd0aCIsImFmdGVyIiwiYmVmb3JlTGVuZ3RoIiwiYWZ0ZXJMZW5ndGgiLCJiZWZvcmVEaXN0YW5jZSIsImFmdGVyRGlzdGFuY2UiLCJkaXN0YW5jZSIsInNuYXBUbyIsInRvbGVyYW5jZSIsInJlbSIsImdldFJHQiIsImNvbG91ciIsImciLCJoZXgiLCJyZ2J0b1N0cmluZyIsInRvSGV4IiwicmVkIiwiZ3JlZW4iLCJibHVlIiwicmdiIiwiaHNiMnJnYiIsImhzbDJyZ2IiLCJoc2IiLCJoc2wiLCJ0b0ZpeGVkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImhzYnRvU3RyaW5nIiwiaHNsdG9TdHJpbmciLCJwcmVwYXJlUkdCIiwiY2xyIiwicGFja2FnZVJHQiIsInJnYjJoc2wiLCJyZ2IyaHNiIiwidiIsIlIiLCJHIiwiQyIsIkgiLCJWIiwiTCIsIk0iLCJtIiwicGFyc2VQYXRoU3RyaW5nIiwicGF0aFN0cmluZyIsInB0aCIsInBhcmFtQ291bnRzIiwidSIsInBhcmFtcyIsInBhcnNlVHJhbnNmb3JtU3RyaW5nIiwiVFN0cmluZyIsInN2Z1RyYW5zZm9ybTJzdHJpbmciLCJ0c3RyIiwicmdUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0ybWF0cml4IiwidGRhdGEiLCJNYXRyaXgiLCJ0bGVuIiwiY29tbWFuZCIsImFic29sdXRlIiwiaW52ZXIiLCJpbnZlcnQiLCJ0cmFuc2xhdGUiLCJfdW5pdDJweCIsInVuaXQycHgiLCJhZG93biIsImJ1cCIsImdldFNvbWVEZWZzIiwib3duZXJTVkdFbGVtZW50IiwicGRlZnMiLCJkZWZzIiwibWFrZSIsImdldFNvbWVTVkciLCJtZ3IiLCJnZXRXIiwiZ2V0QkJveCIsImdldEgiLCJuYW0iLCJxdWVyeSIsInNlbGVjdEFsbCIsIm5vZGVsaXN0IiwiYWRkMmdyb3VwIiwiY2hpbGROb2RlcyIsInNldEludGVydmFsIiwic25hcCIsInBhcGVyIiwiYW5pbXMiLCJqc29uIiwiZmlyc3REZWZpbmVkIiwiYXR0IiwicGFyc2UiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZnVsbCIsImZyYWciLCJwcm90byIsImRvbSIsImNvbnRlbnREb2N1bWVudCIsImNoIiwianNvbkZpbGxlciIsInRvSlNPTiIsIm9uIiwibnQiLCJsYXN0SW5kZXhPZiIsImNzcyIsImNzc0F0dHIiLCJhamF4IiwicG9zdERhdGEiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsInBkIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2V0UmVxdWVzdEhlYWRlciIsIm9uY2UiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic2VuZCIsImxvYWQiLCJyZXNwb25zZVRleHQiLCJnZXRPZmZzZXQiLCJib3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkb2NFbGVtIiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJnZXRFbGVtZW50QnlQb2ludCIsImNhbnZhcyIsImVsZW1lbnRGcm9tUG9pbnQiLCJzbyIsInNyIiwiY3JlYXRlU1ZHUmVjdCIsImhpdHMiLCJnZXRJbnRlcnNlY3Rpb25MaXN0IiwicGx1Z2luIiwiZWxwcm90byIsImlzV2l0aG91dFRyYW5zZm9ybSIsImdldENsaWVudFJlY3RzIiwicmVtb3ZlZCIsImxvY2FsTWF0cml4IiwicGF0aGZpbmRlciIsImRlZmx0IiwiYmJveHd0IiwicmVhbFBhdGgiLCJtYXRyaXgiLCJwcm9wU3RyaW5nIiwiZXh0cmFjdFRyYW5zZm9ybSIsImRvUmV0dXJuIiwicGFwYSIsImdsb2JhbCIsImdldENUTSIsImxvY2FsU3RyaW5nIiwidG9UcmFuc2Zvcm1TdHJpbmciLCJnbG9iYWxNYXRyaXgiLCJ0b3RhbE1hdHJpeCIsImRpZmZNYXRyaXgiLCJ0b3RhbCIsImdyYWRpZW50VHJhbnNmb3JtIiwicGF0dGVyblRyYW5zZm9ybSIsImFwcGVuZCIsIml0IiwiYXBwZW5kVG8iLCJwcmVwZW5kIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJhc1BYIiwidXNlIiwiZml4aWRzIiwiZWxzIiwiaWRzIiwidXNlcyIsInVybHRlc3QiLCJsaW5rdGVzdCIsIm9sZGlkIiwib2xkIiwiZnMiLCJjbG9uZU5vZGUiLCJ0b0RlZnMiLCJ0b1BhdHRlcm4iLCJwYXR0ZXJuVW5pdHMiLCJtYXJrZXIiLCJyZWZYIiwicmVmWSIsIm1hcmtlcldpZHRoIiwibWFya2VySGVpZ2h0IiwiZWxkYXRhIiwicmVtb3ZlRGF0YSIsIm91dGVyU1ZHIiwiaW5uZXJTVkciLCJjaGxkIiwidG9EYXRhVVJMIiwiYnRvYSIsImNvbnRlbnRzIiwidW5lc2NhcGUiLCJtYXRyaXhwcm90byIsImFOZXciLCJiTmV3IiwibXVsdExlZnQiLCJjTmV3IiwiZU5ldyIsIm1lIiwic2tld1giLCJza2V3Iiwic2tld1kiLCJub3JtIiwibWFnIiwiZGV0ZXJtaW5hbnQiLCJyb3ciLCJzY2FsZXgiLCJzaGVhciIsInNjYWxleSIsImlzU2ltcGxlIiwiaXNTdXBlclNpbXBsZSIsIm5vUm90YXRpb24iLCJzaG9ydGVyIiwicmVVUkxWYWx1ZSIsImRldXJsIiwiY2xpcEl0IiwiZmlsbFN0cm9rZSIsImdyYWQiLCJncmFkaWVudCIsImdyYWRyZyIsInBhcnNlR3JhZCIsInRva2VucyIsInN0b3BzIiwidG9BYnNvbHV0ZSIsInR4dCIsImJhc2VWYWwiLCJ2YiIsInRwIiwidGV4dFBhdGgiLCJ0dW5lciIsImNodW5rIiwidHVuZWQiLCJzZXRGb250U2l6ZSIsInNldHRlciIsInRleHRFeHRyYWN0IiwiY2hpIiwiaW50ZXJuYWwiLCJnZXRGb250U2l6ZSIsInJnTm90U3BhY2UiLCJyZ0JhZFNwYWNlIiwicmdUcmltIiwiYWRkQ2xhc3MiLCJjbGFzc2VzIiwiY3VyQ2xhc3NlcyIsInBvcyIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsImZsYWciLCJvcGVyYXRvcnMiLCJyZVVuaXQiLCJyZUFkZG9uIiwiZ2V0TnVtYmVyIiwiZ2V0VW5pdCIsInVuaXQiLCJwbHVzIiwiZXZudCIsImF0ciIsImFVbml0Iiwib3AiLCJicGx1cyIsInJlY3QiLCJjaXJjbGUiLCJvbmVycm9yIiwiY3NzVGV4dCIsIm9ubG9hZCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZWxsaXBzZSIsInZieCIsInZieSIsInZidyIsInZiaCIsInB0cm4iLCJ2eCIsInZ5IiwidnciLCJ2aCIsImxpbmUiLCJwb2x5bGluZSIsInBvbHlnb24iLCJHc3RvcHMiLCJHYWRkU3RvcCIsImluc2VydGVkIiwic3RvcE9mZnNldCIsIkdnZXRCQm94IiwiR3NldFN0b3BzIiwiYWRkU3RvcCIsInVuc2hpZnQiLCJncmFkaWVudExpbmVhciIsImdyYWRpZW50UmFkaWFsIiwiZ3JhZGllbnRVbml0cyIsInNldFN0b3BzIiwicDJzIiwicGF0aHMiLCJwcyIsInNsZWVwIiwicjEiLCJyMiIsInIwIiwicmVjdFBhdGgiLCJwYXRoQ2xvbmUiLCJwYXRoQXJyYXkiLCJnZXRQb2ludEF0U2VnbWVudExlbmd0aCIsInAxeCIsInAxeSIsImMxeCIsImMxeSIsImMyeCIsImMyeSIsInAyeCIsInAyeSIsImJlemxlbiIsImZpbmREb3RzQXRTZWdtZW50IiwiZ2V0VG90TGVuIiwiZ2V0TGVuZ3RoRmFjdG9yeSIsImlzdG90YWwiLCJzdWJwYXRoIiwiTyIsIm9ubHlzdGFydCIsInBhdGgyY3VydmUiLCJzcCIsInN1YnBhdGhzIiwicG9pbnQiLCJnZXRTdWJwYXRoc0F0TGVuZ3RoIiwidDEiLCJ0MTMiLCJ0MTIiLCJ0MiIsInQzIiwibXgiLCJteSIsIm54IiwibnkiLCJheCIsImF5IiwiYWxwaGEiLCJiZXppZXJCQm94IiwiY3VydmVEaW0iLCJpc1BvaW50SW5zaWRlQkJveCIsImlzQkJveEludGVyc2VjdCIsImJib3gxIiwiYmJveDIiLCJiYXNlMyIsInAxIiwicDIiLCJwMyIsInA0IiwieDQiLCJ5NCIsInoyIiwiVHZhbHVlcyIsIkN2YWx1ZXMiLCJzdW0iLCJjdCIsInhiYXNlIiwieWJhc2UiLCJjb21iIiwibGwiLCJpbnRlcnNlY3QiLCJkZW5vbWluYXRvciIsInB4IiwicHkiLCJweDIiLCJweTIiLCJpbnRlciIsImJlejEiLCJiZXoyIiwiaW50ZXJIZWxwZXIiLCJpbnRlckNvdW50IiwianVzdENvdW50IiwibDEiLCJsMiIsIm4xIiwibjIiLCJkb3RzMSIsImRvdHMyIiwieHkiLCJkaSIsImRpMSIsImRqIiwiZGoxIiwiY2kiLCJjaiIsInBhdGhJbnRlcnNlY3Rpb24iLCJwYXRoMSIsInBhdGgyIiwiaW50ZXJQYXRoSGVscGVyIiwicGF0aEludGVyc2VjdGlvbk51bWJlciIsIngxbSIsInkxbSIsIngybSIsInkybSIsInBpIiwicGoiLCJpbnRyIiwia2siLCJzZWdtZW50MSIsInNlZ21lbnQyIiwiaXNQb2ludEluc2lkZVBhdGgiLCJwYXRoQkJveCIsImRpbSIsInhtaW4iLCJ5bWluIiwieG1heCIsInltYXgiLCJlbGxpcHNlUGF0aCIsImdldFBhdGgiLCJwYXRoVG9SZWxhdGl2ZSIsImxvd2VyQ2FzZSIsInBhIiwicGF0aFRvQWJzb2x1dGUiLCJwYTAiLCJjcnoiLCJkb3RzIiwiY2F0bXVsbFJvbTJiZXppZXIiLCJsMmMiLCJxMmMiLCJfMTMiLCJfMjMiLCJhMmMiLCJsYXJnZV9hcmNfZmxhZyIsInN3ZWVwX2ZsYWciLCJyZWN1cnNpdmUiLCJfMTIwIiwicngyIiwicnkyIiwiZjEiLCJmMiIsImRmIiwiZjJvbGQiLCJ4Mm9sZCIsInkyb2xkIiwiYzEiLCJzMSIsImMyIiwiczIiLCJoeCIsImh5IiwibTEiLCJtMiIsIm0zIiwibTQiLCJuZXdyZXMiLCJmaW5kRG90QXRTZWdtZW50IiwieDAiLCJ5MCIsInR2YWx1ZXMiLCJib3VuZHMiLCJiMmFjIiwic3FydGIyYWMiLCJqbGVuIiwibXQiLCJjdXJ2ZSIsImJ4IiwicXgiLCJxeSIsImF0dHJzMiIsInByb2Nlc3NQYXRoIiwicGNvbSIsIlQiLCJmaXhBcmMiLCJwcCIsInBjb21zMSIsInBjb21zMiIsImZpeE0iLCJhMSIsImEyIiwicGZpcnN0Iiwic2VnIiwic2VnMiIsInNlZ2xlbiIsInNlZzJsZW4iLCJtYXBQYXRoIiwicGF0aGkiLCJjcnAiLCJpTGVuIiwiZ2V0U3VicGF0aCIsImluc2lkZSIsImZvdW5kIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0aW9uTnVtYmVyIiwiaXNQb2ludEluc2lkZSIsInRvUmVsYXRpdmUiLCJ0b0N1YmljIiwiaXRlbXMiLCJiaW5kaW5ncyIsInNldHByb3RvIiwidGhpc0FyZyIsIkFuaW1hdGlvbiIsImVhY2giLCJjYWxsYmFja2VyIiwiYW5hbWUiLCJ1bmJvdW5kIiwiaW5zZXJ0aW9uIiwidGFpbCIsInRvZGVsIiwiYXJnbGVuIiwiZXhjbHVkZSIsImdldEVtcHR5IiwiZXF1YWxpc2VUcmFuc2Zvcm0iLCJ0dDEiLCJ0dDIiLCJwYXRoMmFycmF5IiwiZ2V0Vmlld0JveCIsImdldENvbG91ciIsImlzTnVtZXJpYyIsImFycmF5RXF1YWwiLCJhcnIxIiwiYXJyMiIsImVxdWFsIiwiTnVtYmVyIiwiYlVuaXQiLCJzdXBwb3J0c1RvdWNoIiwidG91Y2hNYXAiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwiZ2V0U2Nyb2xsIiwicHJldmVudFRvdWNoIiwib3JpZ2luYWxFdmVudCIsInN0b3BUb3VjaCIsImFkZEV2ZW50IiwicmVhbE5hbWUiLCJzY3JvbGxZIiwic2Nyb2xsWCIsIm9sZGUiLCJkcmFnIiwiZHJhZ01vdmUiLCJkcmFnaSIsInRvdWNoIiwiaWRlbnRpZmllciIsIl9kcmFnIiwibW92ZV9zY29wZSIsImRyYWdVcCIsInVubW91c2Vtb3ZlIiwidW5tb3VzZXVwIiwiZW5kX3Njb3BlIiwic3RhcnRfc2NvcGUiLCJvZmYiLCJ1bmJpbmQiLCJmX2luIiwiZl9vdXQiLCJzY29wZV9pbiIsInNjb3BlX291dCIsIm1vdXNlb3ZlciIsIm1vdXNlb3V0IiwidW5ob3ZlciIsInVubW91c2VvdmVyIiwidW5tb3VzZW91dCIsIm9ubW92ZSIsIm9uc3RhcnQiLCJvbmVuZCIsIm9yaWdUcmFuc2Zvcm0iLCJpbml0IiwidW5kcmFnIiwidW5tb3VzZWRvd24iLCJwcHJvdG8iLCJyZ3VybCIsImZpbHN0ciIsImZpbHRlclVuaXRzIiwiYmx1ciIsImRlZiIsInNoYWRvdyIsImdyYXlzY2FsZSIsImFtb3VudCIsInNlcGlhIiwic2F0dXJhdGUiLCJodWVSb3RhdGUiLCJhbW91bnQyIiwiYnJpZ2h0bmVzcyIsImNvbnRyYXN0IiwiZmlyc3RMZXR0ZXIiLCJnZXRBbGlnbiIsIndheSIsImFsaWduIiwiaW5BbmltIiwiX2F0dHJzIiwiY3VyU3RhdHVzIiwiZmtleXMiLCJ0a2V5cyIsImVxIiwicGluayIsInB1cnBsZSIsImRlZXBwdXJwbGUiLCJpbmRpZ28iLCJsaWdodGJsdWUiLCJjeWFuIiwidGVhbCIsImxpZ2h0Z3JlZW4iLCJsaW1lIiwieWVsbG93IiwiYW1iZXIiLCJvcmFuZ2UiLCJkZWVwb3JhbmdlIiwiYnJvd24iLCJncmV5IiwiYmx1ZWdyZXkiLCJtdWkiLCJmbGF0Iiwic2F2ZUNvbG9yIiwiY29sb3JzIiwiQTEwMCIsIkEyMDAiLCJBNDAwIiwiQTcwMCIsInR1cnF1b2lzZSIsImdyZWVuc2VhIiwic3VuZmxvd2VyIiwiZW1lcmxhbmQiLCJuZXBocml0aXMiLCJjYXJyb3QiLCJwdW1wa2luIiwicGV0ZXJyaXZlciIsImJlbGl6ZWhvbGUiLCJhbGl6YXJpbiIsInBvbWVncmFuYXRlIiwiYW1ldGh5c3QiLCJ3aXN0ZXJpYSIsImNsb3VkcyIsInNpbHZlciIsIndldGFzcGhhbHQiLCJtaWRuaWdodGJsdWUiLCJjb25jcmV0ZSIsImFzYmVzdG9zIiwiaW1wb3J0TVVJQ29sb3JzIiwiY29tYXNlcGFyYXRvciIsIndpbGRjYXJkIiwibnVtc29ydCIsImN1cnJlbnRfZXZlbnQiLCJsYXN0RGVmaW5lZCIsIm9ianRvcyIsImFyIiwib2xkc3RvcCIsImxpc3RlbmVycyIsImluZGV4ZWQiLCJjZSIsInNvcnQiLCJfZXZlbnRzIiwibmVzIiwiZXMiLCJzZXAiLCJleGlzdCIsInN1Ym5hbWUiLCJjdXIiLCJudHMiLCJpbm9kZXMiLCJmdW5jcyIsInBydW5lIiwic3RlcHMiLCJzdGVwc1RvdGFsIiwibmV4dFN0ZXAiLCJjbG9zZUJ1dHRvbiIsInRyYW5zZm9ybU9yaWdpbiIsInRyYW5zZm9ybVN0eWxlIiwicGVyc3BlY3RpdmUiLCJwZXJzcGVjdGl2ZU9yaWdpbiIsImlzVG91Y2hEZXZpY2UiLCJOYXZVcmxzIiwiYXJyYXlPZk5hdkxpbmtzIiwibmF2RWxlbWVudCIsImxpbmtzIiwiaW5uZXJUZXh0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDN0RBOzs7O0FBRUFBLE9BQU9DLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDQyxTQUFPO0FBRG9DLENBQTdDOztBQUlBLElBQUlDLFdBQVdKLE9BQU9LLE1BQVAsSUFBaUIsVUFBVUMsTUFBVixFQUFrQjtBQUFFLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJQyxVQUFVQyxNQUE5QixFQUFzQ0YsR0FBdEMsRUFBMkM7QUFBRSxRQUFJRyxTQUFTRixVQUFVRCxDQUFWLENBQWIsQ0FBMkIsS0FBSyxJQUFJSSxHQUFULElBQWdCRCxNQUFoQixFQUF3QjtBQUFFLFVBQUlWLE9BQU9ZLFNBQVAsQ0FBaUJDLGNBQWpCLENBQWdDQyxJQUFoQyxDQUFxQ0osTUFBckMsRUFBNkNDLEdBQTdDLENBQUosRUFBdUQ7QUFBRUwsZUFBT0ssR0FBUCxJQUFjRCxPQUFPQyxHQUFQLENBQWQ7QUFBNEI7QUFBRTtBQUFFLEdBQUMsT0FB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QkFBZ0I3OEcsT0FBT29rRixVQUFQLEdBQW9CLEdBQXhDOztBQUVBLFNBQVMwNEIsT0FBVCxHQUFtQjtBQUNsQixLQUFJQyxrQkFBa0IsRUFBdEI7QUFDQSxLQUFJQyxhQUFhbC9HLFNBQVNDLGFBQVQsQ0FBdUIsWUFBdkIsQ0FBakI7QUFDQSxLQUFJay9HLFFBQVFELFdBQVdob0Isb0JBQVgsQ0FBZ0MsR0FBaEMsQ0FBWjs7QUFFQSxNQUFLLElBQUlsOEYsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWtILE1BQU1qa0gsTUFBMUIsRUFBa0NGLEdBQWxDLEVBQXVDO0FBQ3RDaWtILGtCQUFnQnZ0RyxJQUFoQixDQUFxQixFQUFDbTBELE1BQUtzNUMsTUFBTW5rSCxDQUFOLEVBQVM2cUUsSUFBZixFQUFxQmgxRCxNQUFLc3VHLE1BQU1ua0gsQ0FBTixFQUFTb2tILFNBQW5DLEVBQXJCO0FBQ0E7O0FBRUQsUUFBT0gsZUFBUDtBQUNBOztrQkFFY0QsTyIsImZpbGUiOiJidW5kbGUtaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzYxNGVhNDg0YWNiOWUzZTQ2OTgiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDMsIF94NCwgX3g1KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MywgcHJvcGVydHkgPSBfeDQsIHJlY2VpdmVyID0gX3g1OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MyA9IHBhcmVudDsgX3g0ID0gcHJvcGVydHk7IF94NSA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfYmFzZVN0eWxlcyA9IHJlcXVpcmUoJy4vYmFzZVN0eWxlcycpO1xuXG52YXIgX2Jhc2VTdHlsZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZVN0eWxlcyk7XG5cbnZhciBfQnVyZ2VySWNvbiA9IHJlcXVpcmUoJy4vQnVyZ2VySWNvbicpO1xuXG52YXIgX0J1cmdlckljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQnVyZ2VySWNvbik7XG5cbnZhciBfQ3Jvc3NJY29uID0gcmVxdWlyZSgnLi9Dcm9zc0ljb24nKTtcblxudmFyIF9Dcm9zc0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ3Jvc3NJY29uKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICB2YXIgTWVudSA9IChmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhNZW51LCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIE1lbnUocHJvcHMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcblxuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTWVudS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGlzT3BlbjogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1lbnUsIFt7XG4gICAgICBrZXk6ICd0b2dnbGVNZW51JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBpc09wZW4gPSBvcHRpb25zLmlzT3BlbjtcbiAgICAgICAgdmFyIG5vU3RhdGVDaGFuZ2UgPSBvcHRpb25zLm5vU3RhdGVDaGFuZ2U7XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0ge1xuICAgICAgICAgIGlzT3BlbjogdHlwZW9mIGlzT3BlbiAhPT0gJ3VuZGVmaW5lZCcgPyBpc09wZW4gOiAhdGhpcy5zdGF0ZS5pc09wZW5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFwcGx5V3JhcHBlclN0eWxlcygpO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAhbm9TdGF0ZUNoYW5nZSAmJiBfdGhpcy5wcm9wcy5vblN0YXRlQ2hhbmdlKG5ld1N0YXRlKTtcblxuICAgICAgICAgIC8vIFRpbWVvdXQgZW5zdXJlcyB3cmFwcGVycyBhcmUgY2xlYXJlZCBhZnRlciBhbmltYXRpb24gZmluaXNoZXMuXG4gICAgICAgICAgX3RoaXMudGltZW91dElkICYmIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgIF90aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV3U3RhdGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgIF90aGlzLmFwcGx5V3JhcHBlclN0eWxlcyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGxpZXMgY29tcG9uZW50LXNwZWNpZmljIHN0eWxlcyB0byBleHRlcm5hbCB3cmFwcGVyIGVsZW1lbnRzLlxuICAgIH0sIHtcbiAgICAgIGtleTogJ2FwcGx5V3JhcHBlclN0eWxlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlXcmFwcGVyU3R5bGVzKCkge1xuICAgICAgICB2YXIgc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5ib2R5Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICAgICAgYm9keS5jbGFzc0xpc3Rbc2V0ID8gJ2FkZCcgOiAncmVtb3ZlJ10odGhpcy5wcm9wcy5ib2R5Q2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZXMucGFnZVdyYXAgJiYgdGhpcy5wcm9wcy5wYWdlV3JhcElkKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFeHRlcm5hbFdyYXBwZXIodGhpcy5wcm9wcy5wYWdlV3JhcElkLCBzdHlsZXMucGFnZVdyYXAsIHNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3R5bGVzLm91dGVyQ29udGFpbmVyICYmIHRoaXMucHJvcHMub3V0ZXJDb250YWluZXJJZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXh0ZXJuYWxXcmFwcGVyKHRoaXMucHJvcHMub3V0ZXJDb250YWluZXJJZCwgc3R5bGVzLm91dGVyQ29udGFpbmVyLCBzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHMgb3IgdW5zZXRzIHN0eWxlcyBvbiBET00gZWxlbWVudHMgb3V0c2lkZSB0aGUgbWVudSBjb21wb25lbnQuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBwYWdlIGludGVyYWN0aW9uIHdpdGggc29tZSBvZiB0aGUgbWVudXMuXG4gICAgICAvLyBUaHJvd3MgYW5kIHJldHVybnMgaWYgdGhlIHJlcXVpcmVkIGV4dGVybmFsIGVsZW1lbnRzIGRvbid0IGV4aXN0LFxuICAgICAgLy8gd2hpY2ggbWVhbnMgYW55IGV4dGVybmFsIHBhZ2UgYW5pbWF0aW9ucyB3b24ndCBiZSBhcHBsaWVkLlxuICAgIH0sIHtcbiAgICAgIGtleTogJ2hhbmRsZUV4dGVybmFsV3JhcHBlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxXcmFwcGVyKGlkLCB3cmFwcGVyU3R5bGVzLCBzZXQpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJyk7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRWxlbWVudCB3aXRoIElEICdcIiArIGlkICsgXCInIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVpbHRTdHlsZXMgPSB0aGlzLmdldFN0eWxlKHdyYXBwZXJTdHlsZXMpO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gYnVpbHRTdHlsZXMpIHtcbiAgICAgICAgICBpZiAoYnVpbHRTdHlsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuc3R5bGVbcHJvcF0gPSBzZXQgPyBidWlsdFN0eWxlc1twcm9wXSA6ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgYW55IGhvcml6b250YWwgc2Nyb2xsLlxuICAgICAgICBbaHRtbCwgYm9keV0uZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbJ292ZXJmbG93LXgnXSA9IHNldCA/ICdoaWRkZW4nIDogJyc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZHMgc3R5bGVzIGluY3JlbWVudGFsbHkgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdnZXRTdHlsZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlcyhlbCwgaW5kZXgsIGlubGluZSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSAnYm0nICsgZWwucmVwbGFjZShlbC5jaGFyQXQoMCksIGVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpKTtcblxuICAgICAgICAvLyBTZXQgYmFzZSBzdHlsZXMuXG4gICAgICAgIHZhciBvdXRwdXQgPSBfYmFzZVN0eWxlczJbJ2RlZmF1bHQnXVtlbF0gPyB0aGlzLmdldFN0eWxlKF9iYXNlU3R5bGVzMlsnZGVmYXVsdCddW2VsXSkgOiB7fTtcblxuICAgICAgICAvLyBBZGQgYW5pbWF0aW9uLXNwZWNpZmljIHN0eWxlcy5cbiAgICAgICAgaWYgKHN0eWxlc1tlbF0pIHtcbiAgICAgICAgICBvdXRwdXQgPSBfZXh0ZW5kcyh7fSwgb3V0cHV0LCB0aGlzLmdldFN0eWxlKHN0eWxlc1tlbF0sIGluZGV4ICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBzdHlsZXMuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnN0eWxlc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICBvdXRwdXQgPSBfZXh0ZW5kcyh7fSwgb3V0cHV0LCB0aGlzLnByb3BzLnN0eWxlc1twcm9wTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgaW5saW5lIHN0eWxlcy5cbiAgICAgICAgaWYgKGlubGluZSkge1xuICAgICAgICAgIG91dHB1dCA9IF9leHRlbmRzKHt9LCBvdXRwdXQsIGlubGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldFN0eWxlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZShzdHlsZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5wcm9wcy53aWR0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3N0cmluZycpIHdpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAgIHJldHVybiBzdHlsZSh0aGlzLnN0YXRlLmlzT3Blbiwgd2lkdGgsIHRoaXMucHJvcHMucmlnaHQsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdsaXN0ZW5Gb3JDbG9zZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuRm9yQ2xvc2UoZSkge1xuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaXNPcGVuICYmIChlLmtleSA9PT0gJ0VzY2FwZScgfHwgZS5rZXlDb2RlID09PSAyNykpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZU1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Nob3VsZERpc2FibGVPdmVybGF5Q2xpY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZERpc2FibGVPdmVybGF5Q2xpY2soKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5kaXNhYmxlT3ZlcmxheUNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZGlzYWJsZU92ZXJsYXlDbGljaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmRpc2FibGVPdmVybGF5Q2xpY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0eWxlcyBzdXBwbGllZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB3aW5kb3cub25rZXlkb3duID0gdGhpcy5saXN0ZW5Gb3JDbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIEFsbG93IGluaXRpYWwgb3BlbiBzdGF0ZSB0byBiZSBzZXQgYnkgcHJvcHMuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmlzT3Blbikge1xuICAgICAgICAgIHRoaXMudG9nZ2xlTWVudSh7IGlzT3BlbjogdHJ1ZSwgbm9TdGF0ZUNoYW5nZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgd2luZG93Lm9ua2V5ZG93biA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5hcHBseVdyYXBwZXJTdHlsZXMoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoc3R5bGVzLnN2Zykge1xuICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW9ycGhTaGFwZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZShfdGhpczIsICdibS1tb3JwaC1zaGFwZScpO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBzdHlsZXMuc3ZnLmxpYihtb3JwaFNoYXBlKS5zZWxlY3QoJ3BhdGgnKTtcblxuICAgICAgICAgICAgaWYgKF90aGlzMi5zdGF0ZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgLy8gQW5pbWF0ZSBTVkcgcGF0aC5cbiAgICAgICAgICAgICAgc3R5bGVzLnN2Zy5hbmltYXRlKHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVzZXQgcGF0aCAodGltZW91dCBlbnN1cmVzIGFuaW1hdGlvbiBoYXBwZW5zIG9mZiBzY3JlZW4pLlxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmF0dHIoJ2QnLCBzdHlsZXMuc3ZnLnBhdGhJbml0aWFsKTtcbiAgICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcHMuaXNPcGVuICE9PSAndW5kZWZpbmVkJyAmJiBuZXh0UHJvcHMuaXNPcGVuICE9PSB0aGlzLnN0YXRlLmlzT3Blbikge1xuICAgICAgICAgIHRoaXMudG9nZ2xlTWVudSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgICF0aGlzLnByb3BzLm5vT3ZlcmxheSAmJiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYm0tb3ZlcmxheSAnICsgdGhpcy5wcm9wcy5vdmVybGF5Q2xhc3NOYW1lLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIV90aGlzMy5zaG91bGREaXNhYmxlT3ZlcmxheUNsaWNrKCkgJiYgX3RoaXMzLnRvZ2dsZU1lbnUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZXMoJ292ZXJsYXknKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdibS1tZW51LXdyYXAgJyArIHRoaXMucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZXMoJ21lbnVXcmFwJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZXMuc3ZnICYmIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdibS1tb3JwaC1zaGFwZSAnICsgdGhpcy5wcm9wcy5tb3JwaFNoYXBlQ2xhc3NOYW1lLCBzdHlsZTogdGhpcy5nZXRTdHlsZXMoJ21vcnBoU2hhcGUnKSB9LFxuICAgICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3ZnJyxcbiAgICAgICAgICAgICAgICB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCB2aWV3Qm94OiAnMCAwIDEwMCA4MDAnLCBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAnbm9uZScgfSxcbiAgICAgICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgncGF0aCcsIHsgZDogc3R5bGVzLnN2Zy5wYXRoSW5pdGlhbCB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2JtLW1lbnUgJyArIHRoaXMucHJvcHMubWVudUNsYXNzTmFtZSwgc3R5bGU6IHRoaXMuZ2V0U3R5bGVzKCdtZW51JykgfSxcbiAgICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ25hdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdibS1pdGVtLWxpc3QgJyArIHRoaXMucHJvcHMuaXRlbUxpc3RDbGFzc05hbWUsIHN0eWxlOiB0aGlzLmdldFN0eWxlcygnaXRlbUxpc3QnKSB9LFxuICAgICAgICAgICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdGhpczMuZ2V0U3R5bGVzKCdpdGVtJywgaW5kZXgsIGl0ZW0ucHJvcHMuc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KGl0ZW0sIGV4dHJhUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLnByb3BzLmN1c3RvbUNyb3NzSWNvbiAhPT0gZmFsc2UgJiYgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICB7IHN0eWxlOiB0aGlzLmdldFN0eWxlcygnY2xvc2VCdXR0b24nKSB9LFxuICAgICAgICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfQ3Jvc3NJY29uMlsnZGVmYXVsdCddLCB7XG4gICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy50b2dnbGVNZW51KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHRoaXMucHJvcHMuc3R5bGVzLFxuICAgICAgICAgICAgICAgIGN1c3RvbUljb246IHRoaXMucHJvcHMuY3VzdG9tQ3Jvc3NJY29uLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jcm9zc0J1dHRvbkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBjcm9zc0NsYXNzTmFtZTogdGhpcy5wcm9wcy5jcm9zc0NsYXNzTmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgdGhpcy5wcm9wcy5jdXN0b21CdXJnZXJJY29uICE9PSBmYWxzZSAmJiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgeyBzdHlsZTogdGhpcy5nZXRTdHlsZXMoJ2J1cmdlckljb24nKSB9LFxuICAgICAgICAgICAgX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoX0J1cmdlckljb24yWydkZWZhdWx0J10sIHtcbiAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMudG9nZ2xlTWVudSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHlsZXM6IHRoaXMucHJvcHMuc3R5bGVzLFxuICAgICAgICAgICAgICBjdXN0b21JY29uOiB0aGlzLnByb3BzLmN1c3RvbUJ1cmdlckljb24sXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5idXJnZXJCdXR0b25DbGFzc05hbWUsXG4gICAgICAgICAgICAgIGJhckNsYXNzTmFtZTogdGhpcy5wcm9wcy5idXJnZXJCYXJDbGFzc05hbWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBNZW51O1xuICB9KShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBNZW51LnByb3BUeXBlcyA9IHtcbiAgICBib2R5Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBidXJnZXJCYXJDbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIGJ1cmdlckJ1dHRvbkNsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG4gICAgY3Jvc3NCdXR0b25DbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIGNyb3NzQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBjdXN0b21CdXJnZXJJY29uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKFtmYWxzZV0pXSksXG4gICAgY3VzdG9tQ3Jvc3NJY29uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mVHlwZShbX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5lbGVtZW50LCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9uZU9mKFtmYWxzZV0pXSksXG4gICAgZGlzYWJsZU92ZXJsYXlDbGljazogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCwgX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5mdW5jXSksXG4gICAgaWQ6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIGlzT3BlbjogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5ib29sLFxuICAgIGl0ZW1MaXN0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBtZW51Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBtb3JwaFNoYXBlQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBub092ZXJsYXk6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uYm9vbCxcbiAgICBvblN0YXRlQ2hhbmdlOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmZ1bmMsXG4gICAgb3V0ZXJDb250YWluZXJJZDogc3R5bGVzICYmIHN0eWxlcy5vdXRlckNvbnRhaW5lciA/IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLmlzUmVxdWlyZWQgOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBvdmVybGF5Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZyxcbiAgICBwYWdlV3JhcElkOiBzdHlsZXMgJiYgc3R5bGVzLnBhZ2VXcmFwID8gX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcuaXNSZXF1aXJlZCA6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICAgIHJpZ2h0OiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmJvb2wsXG4gICAgc3R5bGVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdCxcbiAgICB3aWR0aDogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vbmVPZlR5cGUoW19wcm9wVHlwZXMyWydkZWZhdWx0J10ubnVtYmVyLCBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLnN0cmluZ10pXG4gIH07XG5cbiAgTWVudS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgYm9keUNsYXNzTmFtZTogJycsXG4gICAgYnVyZ2VyQmFyQ2xhc3NOYW1lOiAnJyxcbiAgICBidXJnZXJCdXR0b25DbGFzc05hbWU6ICcnLFxuICAgIGNsYXNzTmFtZTogJycsXG4gICAgY3Jvc3NCdXR0b25DbGFzc05hbWU6ICcnLFxuICAgIGNyb3NzQ2xhc3NOYW1lOiAnJyxcbiAgICBpZDogJycsXG4gICAgaXRlbUxpc3RDbGFzc05hbWU6ICcnLFxuICAgIG1lbnVDbGFzc05hbWU6ICcnLFxuICAgIG1vcnBoU2hhcGVDbGFzc05hbWU6ICcnLFxuICAgIG5vT3ZlcmxheTogZmFsc2UsXG4gICAgb25TdGF0ZUNoYW5nZTogZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSgpIHt9LFxuICAgIG91dGVyQ29udGFpbmVySWQ6ICcnLFxuICAgIG92ZXJsYXlDbGFzc05hbWU6ICcnLFxuICAgIHBhZ2VXcmFwSWQ6ICcnLFxuICAgIHN0eWxlczoge30sXG4gICAgd2lkdGg6IDMwMFxuICB9O1xuXG4gIHJldHVybiBNZW51O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51RmFjdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFNuYXAgPSB1bmRlZmluZWQ7XG4gIHRyeSB7XG4gICAgU25hcCA9IHJlcXVpcmUoJ3NuYXBzdmctY2pzJyk7XG4gIH0gZmluYWxseSB7XG4gICAgcmV0dXJuIFNuYXA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvc25hcHN2Z0ltcG9ydGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgTW9iaWxlTWVudSBmcm9tICcuL2NvbXBvbmVudHMvbW9iaWxlTWVudSc7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG5cdGNvbnN0IG1lbnVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbWVudV0nKTtcblxuXHRpZiAobWVudUVsZW1lbnQpIHtcblx0XHRSZWFjdERPTS5yZW5kZXIoPE1vYmlsZU1lbnUgcGFnZVdyYXBJZD17IFwicGFnZS13cmFwXCIgfSBvdXRlckNvbnRhaW5lcklkPXsgXCJvdXRlci1jb250YWluZXJcIiB9IC8+LCBtZW51RWxlbWVudCk7XG5cdH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2luZGV4LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjIuMCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuZnVuY3Rpb24gQXN5bmNDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBhc3luY0NvbXBvbmVudFByb3RvdHlwZSA9IEFzeW5jQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3luY0NvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihhc3luY0NvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxue1xuICB2YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIHZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgVkFMSURfRlJBR01FTlRfUFJPUFMgPSBuZXcgTWFwKFtbJ2NoaWxkcmVuJywgdHJ1ZV0sIFsna2V5JywgdHJ1ZV1dKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICB2YXIgcHJvcFR5cGVzID0gY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzO1xuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50Q2xhc3MuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBuYW1lIHx8ICdVbmtub3duJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKCFWQUxJRF9GUkFHTUVOVF9QUk9QUy5oYXMoa2V5KSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvclsncmV0dXJuJ10pIHtcbiAgICAgICAgX2l0ZXJhdG9yWydyZXR1cm4nXSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ251bWJlcic7XG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgJiYgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG4gIHVuc3RhYmxlX0FzeW5jQ29tcG9uZW50OiBBc3luY0NvbXBvbmVudCxcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICAgIGFzc2lnbjogX2Fzc2lnblxuICB9XG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkM1snZGVmYXVsdCddID8gUmVhY3QkM1snZGVmYXVsdCddIDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBzbGlkZSBhcyBNZW51IH0gZnJvbSAncmVhY3QtYnVyZ2VyLW1lbnUnO1xuaW1wb3J0IE5hdlVybHMgZnJvbSAnLi4vdXRpbHMvbmF2VXJscyc7XG5cbmNvbnN0IG5hdlVybHMgPSBOYXZVcmxzKCk7XG5jb25zdCBtb2JpbGVXaWR0aCA9IDc2OTtcblxuY2xhc3MgTW9iaWxlTWVudSBleHRlbmRzIENvbXBvbmVudCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRzaG91bGRNZW51UmVuZGVyOiB3aW5kb3cuaW5uZXJXaWR0aCA8IG1vYmlsZVdpZHRoLFxuXHRcdFx0aXNPcGVuOiBmYWxzZVxuXHRcdH07XG5cdH1cblxuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKGUpID0+IHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRzaG91bGRNZW51UmVuZGVyOiB3aW5kb3cuaW5uZXJXaWR0aCA8IG1vYmlsZVdpZHRoXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAoIXRoaXMuc3RhdGUuc2hvdWxkTWVudVJlbmRlcikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0eWxlcyA9IHtcblx0XHRcdGJtQnVyZ2VyQnV0dG9uOiB7XG5cdFx0XHRcdHpJbmRleDogMTAsXG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR3aWR0aDogJzM2cHgnLFxuXHRcdFx0XHRoZWlnaHQ6ICcyM3B4Jyxcblx0XHRcdFx0cmlnaHQ6ICcyMHB4Jyxcblx0XHRcdFx0dG9wOiAnMjJweCdcblx0XHRcdH0sXG5cdFx0XHRibUJ1cmdlckJhcnM6IHtcblx0XHRcdFx0YmFja2dyb3VuZDogJyNmZmYnLFxuXHRcdFx0XHRoZWlnaHQ6ICc0cHgnLFxuXHRcdFx0fSxcblx0XHRcdGJtQ3Jvc3NCdXR0b246IHtcblx0XHRcdFx0aGVpZ2h0OiAnMzVweCcsXG5cdFx0XHRcdHdpZHRoOiAnMzVweCcsXG5cdFx0XHRcdHJpZ2h0OiAnMjJweCcsXG5cdFx0XHRcdHRvcDogJzE2cHgnXG5cdFx0XHR9LFxuXHRcdFx0Ym1Dcm9zczoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0XHRcdGhlaWdodDogJzMwcHgnLFxuXHRcdFx0XHR3aWR0aDogJzVweCdcblx0XHRcdH0sXG5cdFx0XHRibU1lbnVXcmFwIDoge1xuXHRcdFx0XHR6SW5kZXg6IDE1XG5cdFx0XHR9LFxuXHRcdFx0Ym1NZW51OiB7XG5cdFx0XHRcdGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuOCknLFxuXHRcdFx0XHRwYWRkaW5nOiAnMi41ZW0gMS41ZW0gMCcsXG5cdFx0XHRcdGZvbnRTaXplOiAnMS4xNWVtJ1xuXHRcdFx0fSxcblx0XHRcdGJtTW9ycGhTaGFwZToge1xuXHRcdFx0XHRmaWxsOiAnIzM3M2E0Nydcblx0XHRcdH0sXG5cdFx0XHRibUl0ZW1MaXN0OiB7XG5cdFx0XHRcdGNvbG9yOiAnI2I4YjdhZCcsXG5cdFx0XHRcdHBhZGRpbmc6ICcwLjhlbScsXG5cdFx0XHRcdHRleHRBbGlnbjogJ2NlbnRlcidcblx0XHRcdH0sXG5cdFx0XHRibU92ZXJsYXk6IHtcblx0XHRcdFx0YmFja2dyb3VuZDogJ3JnYmEoMCwgMCwgMCwgMC4zKSdcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGlzTWVudU9wZW4gPSAoc3RhdGUpID0+IHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IHN0YXRlLmlzT3BlblxuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8TWVudSByaWdodCBzdHlsZXM9e3N0eWxlc30gb25TdGF0ZUNoYW5nZT17aXNNZW51T3Blbn0+XG5cdFx0XHRcdDxhIGNsYXNzTmFtZT1cIm1lbnUtaXRlbVwiIGhyZWY9XCIvXCI+SG9tZTwvYT5cblx0XHRcdFx0e25hdlVybHMubWFwKGZ1bmN0aW9uKG5hdlVybCwgaW5kZXgpe1xuXHRcdFx0XHRcdHJldHVybiA8YSBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJtZW51LWl0ZW1cIiBocmVmPXtuYXZVcmwuaHJlZn0+e25hdlVybC50ZXh0fTwvYT47XG5cdFx0XHRcdH0pfVxuICAgICAgPC9NZW51PlxuXHRcdCk7XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBNb2JpbGVNZW51O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2NvbXBvbmVudHMvbW9iaWxlTWVudS5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIHNsaWRlOiByZXF1aXJlKCcuL21lbnVzL3NsaWRlJyksXG4gIHN0YWNrOiByZXF1aXJlKCcuL21lbnVzL3N0YWNrJyksXG4gIGVsYXN0aWM6IHJlcXVpcmUoJy4vbWVudXMvZWxhc3RpYycpLFxuICBidWJibGU6IHJlcXVpcmUoJy4vbWVudXMvYnViYmxlJyksXG4gIHB1c2g6IHJlcXVpcmUoJy4vbWVudXMvcHVzaCcpLFxuICBwdXNoUm90YXRlOiByZXF1aXJlKCcuL21lbnVzL3B1c2hSb3RhdGUnKSxcbiAgc2NhbGVEb3duOiByZXF1aXJlKCcuL21lbnVzL3NjYWxlRG93bicpLFxuICBzY2FsZVJvdGF0ZTogcmVxdWlyZSgnLi9tZW51cy9zY2FsZVJvdGF0ZScpLFxuICBmYWxsRG93bjogcmVxdWlyZSgnLi9tZW51cy9mYWxsRG93bicpLFxuICByZXZlYWw6IHJlcXVpcmUoJy4vbWVudXMvcmV2ZWFsJylcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL0J1cmdlck1lbnUuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbWVudUZhY3RvcnkgPSByZXF1aXJlKCcuLi9tZW51RmFjdG9yeScpO1xuXG52YXIgX21lbnVGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVGYWN0b3J5KTtcblxudmFyIHN0eWxlcyA9IHt9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSAoMCwgX21lbnVGYWN0b3J5MlsnZGVmYXVsdCddKShzdHlsZXMpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9zbGlkZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBzdHlsZXMgPSB7XG5cbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheShpc09wZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICB6SW5kZXg6IDEsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxuICAgICAgTW96VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyxcbiAgICAgIHRyYW5zaXRpb246IGlzT3BlbiA/ICdvcGFjaXR5IDAuM3MnIDogJ29wYWNpdHkgMC4zcywgdHJhbnNmb3JtIDBzIDAuM3MnXG4gICAgfTtcbiAgfSxcblxuICBtZW51V3JhcDogZnVuY3Rpb24gbWVudVdyYXAoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICByaWdodDogcmlnaHQgPyAwIDogJ2luaGVyaXQnLFxuICAgICAgekluZGV4OiAyLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuNXMnXG4gICAgfTtcbiAgfSxcblxuICBtZW51OiBmdW5jdGlvbiBtZW51KCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xuICAgIH07XG4gIH0sXG5cbiAgaXRlbUxpc3Q6IGZ1bmN0aW9uIGl0ZW1MaXN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgIH07XG4gIH0sXG5cbiAgaXRlbTogZnVuY3Rpb24gaXRlbSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIG91dGxpbmU6ICdub25lJ1xuICAgIH07XG4gIH0sXG5cbiAgYnVyZ2VySWNvbjogZnVuY3Rpb24gYnVyZ2VySWNvbihpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBzdHlsZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL2Jhc2VTdHlsZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBCdXJnZXJJY29uID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhCdXJnZXJJY29uLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCdXJnZXJJY29uKHByb3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1cmdlckljb24pO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnVyZ2VySWNvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaG92ZXI6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdXJnZXJJY29uLCBbe1xuICAgIGtleTogJ2dldExpbmVTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVTdHlsZShpbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIGhlaWdodDogJzIwJScsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB0b3A6IDIwICogKGluZGV4ICogMikgKyAnJScsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMuc3RhdGUuaG92ZXIgPyAwLjYgOiAxXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBpY29uID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGJ1dHRvblN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgZm9udFNpemU6IDgsXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5wcm9wcy5jdXN0b21JY29uKSB7XG4gICAgICAgIHZhciBleHRyYVByb3BzID0ge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ2JtLWljb24nLFxuICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0sIHRoaXMucHJvcHMuc3R5bGVzLmJtSWNvbilcbiAgICAgICAgfTtcbiAgICAgICAgaWNvbiA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jbG9uZUVsZW1lbnQodGhpcy5wcm9wcy5jdXN0b21JY29uLCBleHRyYVByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGljb24gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChiYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgICAgICAgICAga2V5OiBiYXIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2JtLWJ1cmdlci1iYXJzICcgKyBfdGhpcy5wcm9wcy5iYXJDbGFzc05hbWUsXG4gICAgICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgX3RoaXMuZ2V0TGluZVN0eWxlKGJhciksIF90aGlzLnByb3BzLnN0eWxlcy5ibUJ1cmdlckJhcnMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnYm0tYnVyZ2VyLWJ1dHRvbiAnICsgdGhpcy5wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHsgekluZGV4OiAxIH0sIHRoaXMucHJvcHMuc3R5bGVzLmJtQnVyZ2VyQnV0dG9uKVxuICAgICAgICB9LFxuICAgICAgICBpY29uLFxuICAgICAgICBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByb3BzLm9uQ2xpY2ssXG4gICAgICAgICAgICBvbk1vdXNlT3ZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0U3RhdGUoeyBob3ZlcjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRTdGF0ZSh7IGhvdmVyOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZTogYnV0dG9uU3R5bGVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdPcGVuIE1lbnUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1cmdlckljb247XG59KShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQnVyZ2VySWNvbjtcblxuQnVyZ2VySWNvbi5wcm9wVHlwZXMgPSB7XG4gIGJhckNsYXNzTmFtZTogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5zdHJpbmcsXG4gIGN1c3RvbUljb246IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uZWxlbWVudCxcbiAgc3R5bGVzOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLm9iamVjdFxufTtcblxuQnVyZ2VySWNvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGJhckNsYXNzTmFtZTogJycsXG4gIGNsYXNzTmFtZTogJycsXG4gIHN0eWxlczoge31cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL0J1cmdlckljb24uanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBDcm9zc0ljb24gPSAoZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKENyb3NzSWNvbiwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ3Jvc3NJY29uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm9zc0ljb24pO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3Jvc3NJY29uLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3Jvc3NJY29uLCBbe1xuICAgIGtleTogJ2dldENyb3NzU3R5bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDcm9zc1N0eWxlKHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogMyxcbiAgICAgICAgaGVpZ2h0OiAxNCxcbiAgICAgICAgdHJhbnNmb3JtOiB0eXBlID09PSAnYmVmb3JlJyA/ICdyb3RhdGUoNDVkZWcpJyA6ICdyb3RhdGUoLTQ1ZGVnKSdcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGljb247XG4gICAgICB2YXIgYnV0dG9uV3JhcHBlclN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IDI0LFxuICAgICAgICBoZWlnaHQ6IDI0LFxuICAgICAgICByaWdodDogOCxcbiAgICAgICAgdG9wOiA4XG4gICAgICB9O1xuICAgICAgdmFyIGJ1dHRvblN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgdGV4dEluZGVudDogLTk5OTksXG4gICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmN1c3RvbUljb24pIHtcbiAgICAgICAgdmFyIGV4dHJhUHJvcHMgPSB7XG4gICAgICAgICAgY2xhc3NOYW1lOiAnYm0tY3Jvc3MnLFxuICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0sIHRoaXMucHJvcHMuc3R5bGVzLmJtQ3Jvc3MpXG4gICAgICAgIH07XG4gICAgICAgIGljb24gPSBfcmVhY3QyWydkZWZhdWx0J10uY2xvbmVFbGVtZW50KHRoaXMucHJvcHMuY3VzdG9tSWNvbiwgZXh0cmFQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpY29uID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3NwYW4nLFxuICAgICAgICAgIHsgc3R5bGU6IHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogJzZweCcsIHJpZ2h0OiAnMTRweCcgfSB9LFxuICAgICAgICAgIFsnYmVmb3JlJywgJ2FmdGVyJ10ubWFwKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnYm0tY3Jvc3MgJyArIF90aGlzLnByb3BzLmNyb3NzQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIF90aGlzLmdldENyb3NzU3R5bGUodHlwZSksIF90aGlzLnByb3BzLnN0eWxlcy5ibUNyb3NzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ2JtLWNyb3NzLWJ1dHRvbiAnICsgdGhpcy5wcm9wcy5jbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBidXR0b25XcmFwcGVyU3R5bGUsIHRoaXMucHJvcHMuc3R5bGVzLmJtQ3Jvc3NCdXR0b24pXG4gICAgICAgIH0sXG4gICAgICAgIGljb24sXG4gICAgICAgIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgIHsgb25DbGljazogdGhpcy5wcm9wcy5vbkNsaWNrLCBzdHlsZTogYnV0dG9uU3R5bGUgfSxcbiAgICAgICAgICAnQ2xvc2UgTWVudSdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvc3NJY29uO1xufSkoX3JlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENyb3NzSWNvbjtcblxuQ3Jvc3NJY29uLnByb3BUeXBlcyA9IHtcbiAgY3Jvc3NDbGFzc05hbWU6IF9wcm9wVHlwZXMyWydkZWZhdWx0J10uc3RyaW5nLFxuICBjdXN0b21JY29uOiBfcHJvcFR5cGVzMlsnZGVmYXVsdCddLmVsZW1lbnQsXG4gIHN0eWxlczogX3Byb3BUeXBlczJbJ2RlZmF1bHQnXS5vYmplY3Rcbn07XG5cbkNyb3NzSWNvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNyb3NzQ2xhc3NOYW1lOiAnJyxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgc3R5bGVzOiB7fVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvQ3Jvc3NJY29uLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX21lbnVGYWN0b3J5ID0gcmVxdWlyZSgnLi4vbWVudUZhY3RvcnknKTtcblxudmFyIF9tZW51RmFjdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51RmFjdG9yeSk7XG5cbnZhciBzdHlsZXMgPSB7XG5cbiAgbWVudVdyYXA6IGZ1bmN0aW9uIG1lbnVXcmFwKGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIHRyYW5zaXRpb246IGlzT3BlbiA/ICd0cmFuc2Zvcm0gMC44cyBjdWJpYy1iZXppZXIoMC43LCAwLCAwLjMsIDEpJyA6ICd0cmFuc2Zvcm0gMC40cyBjdWJpYy1iZXppZXIoMC43LCAwLCAwLjMsIDEpJ1xuICAgIH07XG4gIH0sXG5cbiAgaXRlbTogZnVuY3Rpb24gaXRlbShpc09wZW4sIHdpZHRoLCByaWdodCwgbnRoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTW96VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgwLCAnICsgbnRoQ2hpbGQgKiA1MDAgKyAncHgsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgwLCAnICsgbnRoQ2hpbGQgKiA1MDAgKyAncHgsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogJ3RyYW5zbGF0ZTNkKDAsICcgKyBudGhDaGlsZCAqIDUwMCArICdweCwgMCknLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgwLCAnICsgbnRoQ2hpbGQgKiA1MDAgKyAncHgsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgJyArIG50aENoaWxkICogNTAwICsgJ3B4LCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiBpc09wZW4gPyAndHJhbnNmb3JtIDAuOHMgY3ViaWMtYmV6aWVyKDAuNywgMCwgMC4zLCAxKScgOiAndHJhbnNmb3JtIDBzIDAuMnMgY3ViaWMtYmV6aWVyKDAuNywgMCwgMC4zLCAxKSdcbiAgICB9O1xuICB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSAoMCwgX21lbnVGYWN0b3J5MlsnZGVmYXVsdCddKShzdHlsZXMpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9zdGFjay5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9zbmFwc3ZnSW1wb3J0ZXIgPSByZXF1aXJlKCcuLi9zbmFwc3ZnSW1wb3J0ZXInKTtcblxudmFyIF9zbmFwc3ZnSW1wb3J0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc25hcHN2Z0ltcG9ydGVyKTtcblxudmFyIF9tZW51RmFjdG9yeSA9IHJlcXVpcmUoJy4uL21lbnVGYWN0b3J5Jyk7XG5cbnZhciBfbWVudUZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVudUZhY3RvcnkpO1xuXG52YXIgc3R5bGVzID0ge1xuXG4gIHN2Zzoge1xuICAgIGxpYjogX3NuYXBzdmdJbXBvcnRlcjJbJ2RlZmF1bHQnXSxcbiAgICBwYXRoSW5pdGlhbDogJ00tMSwwaDEwMWMwLDAtOTcuODMzLDE1My42MDMtOTcuODMzLDM5Ni4xNjdDMi4xNjcsNjI3LjU3OSwxMDAsODAwLDEwMCw4MDBILTFWMHonLFxuICAgIHBhdGhPcGVuOiAnTS0xLDBoMTAxYzAsMCwwLTEsMCwzOTVjMCw0MDQsMCw0MDUsMCw0MDVILTFWMHonLFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUocGF0aCkge1xuICAgICAgcGF0aC5hbmltYXRlKHsgcGF0aDogdGhpcy5wYXRoT3BlbiB9LCA0MDAsIHdpbmRvdy5taW5hLmVhc2Vpbm91dCk7XG4gICAgfVxuICB9LFxuXG4gIG1vcnBoU2hhcGU6IGZ1bmN0aW9uIG1vcnBoU2hhcGUoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogMTIwLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICByaWdodDogcmlnaHQgPyAnaW5oZXJpdCcgOiAwLFxuICAgICAgbGVmdDogcmlnaHQgPyAwIDogJ2luaGVyaXQnLFxuICAgICAgTW96VHJhbnNmb3JtOiByaWdodCA/ICdyb3RhdGVZKDE4MGRlZyknIDogJycsXG4gICAgICBNc1RyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICcnLFxuICAgICAgT1RyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICcnLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiByaWdodCA/ICdyb3RhdGVZKDE4MGRlZyknIDogJycsXG4gICAgICB0cmFuc2Zvcm06IHJpZ2h0ID8gJ3JvdGF0ZVkoMTgwZGVnKScgOiAnJ1xuICAgIH07XG4gIH0sXG5cbiAgbWVudVdyYXA6IGZ1bmN0aW9uIG1lbnVXcmFwKGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknLFxuICAgICAgTXNUcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknLFxuICAgICAgdHJhbnNmb3JtOiBpc09wZW4gPyAndHJhbnNsYXRlM2QoMCwgMCwgMCknIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuM3MnXG4gICAgfTtcbiAgfSxcblxuICBtZW51OiBmdW5jdGlvbiBtZW51KGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgcmlnaHQ6IHJpZ2h0ID8gMCA6ICdpbmhlcml0JyxcbiAgICAgIHdpZHRoOiAxODAsXG4gICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICAgIH07XG4gIH0sXG5cbiAgaXRlbUxpc3Q6IGZ1bmN0aW9uIGl0ZW1MaXN0KGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgbGVmdDogJy0xMTBweCcsXG4gICAgICAgIHdpZHRoOiAnMTcwJScsXG4gICAgICAgIG92ZXJmbG93OiAnYXV0bydcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHBhZ2VXcmFwOiBmdW5jdGlvbiBwYWdlV3JhcChpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLTEwMHB4LCAwLCAwKScgOiAndHJhbnNsYXRlM2QoMTAwcHgsIDAsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0xMDBweCwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKDEwMHB4LCAwLCAwKScsXG4gICAgICBPVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0xMDBweCwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKDEwMHB4LCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLTEwMHB4LCAwLCAwKScgOiAndHJhbnNsYXRlM2QoMTAwcHgsIDAsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtMTAwcHgsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgxMDBweCwgMCwgMCknLFxuICAgICAgdHJhbnNpdGlvbjogaXNPcGVuID8gJ2FsbCAwLjNzJyA6ICdhbGwgMC4zcyAwLjFzJ1xuICAgIH07XG4gIH0sXG5cbiAgb3V0ZXJDb250YWluZXI6IGZ1bmN0aW9uIG91dGVyQ29udGFpbmVyKGlzT3Blbikge1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyZmxvdzogaXNPcGVuID8gJycgOiAnaGlkZGVuJ1xuICAgIH07XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9ICgwLCBfbWVudUZhY3RvcnkyWydkZWZhdWx0J10pKHN0eWxlcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL2VsYXN0aWMuanMiLCJ3aW5kb3cuZXZlID0gcmVxdWlyZSgnZXZlJylcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIG1pbmEgPSAoZnVuY3Rpb24gKGV2ZSkge1xuICAgIHZhciBhbmltYXRpb25zID0ge30sXG4gICAgcmVxdWVzdEFuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE2LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICByZXF1ZXN0SUQsXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9LFxuICAgIGlkZ2VuID0gMCxcbiAgICBpZHByZWZpeCA9IFwiTVwiICsgKCtuZXcgRGF0ZSkudG9TdHJpbmcoMzYpLFxuICAgIElEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgZGlmZiA9IGZ1bmN0aW9uIChhLCBiLCBBLCBCKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGEpKSB7XG4gICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGRpZmYoYVtpXSwgYiwgQVtpXSwgQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWYgPSAoQSAtIGEpIC8gKEIgLSBiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBkaWYgKiAoYmIgLSBiKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRpbWVyID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gK25ldyBEYXRlO1xuICAgIH0sXG4gICAgc3RhID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGEucztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHMgPSBhLnMgLSB2YWw7XG4gICAgICAgIGEuYiArPSBhLmR1ciAqIGRzO1xuICAgICAgICBhLkIgKz0gYS5kdXIgKiBkcztcbiAgICAgICAgYS5zID0gdmFsO1xuICAgIH0sXG4gICAgc3BlZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zcGQ7XG4gICAgICAgIH1cbiAgICAgICAgYS5zcGQgPSB2YWw7XG4gICAgfSxcbiAgICBkdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmR1cjtcbiAgICAgICAgfVxuICAgICAgICBhLnMgPSBhLnMgKiB2YWwgLyBhLmR1cjtcbiAgICAgICAgYS5kdXIgPSB2YWw7XG4gICAgfSxcbiAgICBzdG9waXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgZGVsZXRlIGFuaW1hdGlvbnNbYS5pZF07XG4gICAgICAgIGEudXBkYXRlKCk7XG4gICAgICAgIGV2ZShcIm1pbmEuc3RvcC5cIiArIGEuaWQsIGEpO1xuICAgIH0sXG4gICAgcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKGEucGRpZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2EuaWRdO1xuICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICBhLnBkaWYgPSBhLmdldCgpIC0gYS5iO1xuICAgIH0sXG4gICAgcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICghYS5wZGlmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYS5iID0gYS5nZXQoKSAtIGEucGRpZjtcbiAgICAgICAgZGVsZXRlIGEucGRpZjtcbiAgICAgICAgYW5pbWF0aW9uc1thLmlkXSA9IGE7XG4gICAgICAgIGZyYW1lKCk7XG4gICAgfSxcbiAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gdGhpcyxcbiAgICAgICAgICAgIHJlcztcbiAgICAgICAgaWYgKGlzQXJyYXkoYS5zdGFydCkpIHtcbiAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gYS5zdGFydC5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2pdID0gK2Euc3RhcnRbal0gK1xuICAgICAgICAgICAgICAgICAgICAoYS5lbmRbal0gLSBhLnN0YXJ0W2pdKSAqIGEuZWFzaW5nKGEucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSArYS5zdGFydCArIChhLmVuZCAtIGEuc3RhcnQpICogYS5lYXNpbmcoYS5zKTtcbiAgICAgICAgfVxuICAgICAgICBhLnNldChyZXMpO1xuICAgIH0sXG4gICAgZnJhbWUgPSBmdW5jdGlvbiAodGltZVN0YW1wKSB7XG4gICAgICAgIC8vIE1hbnVhbCBpbnZva2F0aW9uP1xuICAgICAgICBpZiAoIXRpbWVTdGFtcCkge1xuICAgICAgICAgICAgLy8gRnJhbWUgbG9vcCBzdG9wcGVkP1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0SUQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBmcmFtZSBsb29wLi4uXG4gICAgICAgICAgICAgICAgcmVxdWVzdElEID0gcmVxdWVzdEFuaW1GcmFtZShmcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYW5pbWF0aW9ucykgaWYgKGFuaW1hdGlvbnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIHZhciBhID0gYW5pbWF0aW9uc1tpXSxcbiAgICAgICAgICAgICAgICBiID0gYS5nZXQoKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGEucyA9IChiIC0gYS5iKSAvIChhLmR1ciAvIGEuc3BkKTtcbiAgICAgICAgICAgIGlmIChhLnMgPj0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBhbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGEucyA9IDE7XG4gICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlKFwibWluYS5maW5pc2guXCIgKyBhLmlkLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RJRCA9IGxlbiA/IHJlcXVlc3RBbmltRnJhbWUoZnJhbWUpIDogZmFsc2U7XG4gICAgfSxcbiAgICAvKlxcXG4gICAgICogbWluYVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2VuZXJpYyBhbmltYXRpb24gb2YgbnVtYmVyc1xuICAgICAqKlxuICAgICAtIGEgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBBIChudW1iZXIpIGVuZCBfc2xhdmVfIG51bWJlclxuICAgICAtIGIgKG51bWJlcikgc3RhcnQgX21hc3Rlcl8gbnVtYmVyIChzdGFydCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBCIChudW1iZXIpIGVuZCBfbWFzdGVyXyBudW1iZXIgKGVuZCB0aW1lIGluIGdlbmVyYWwgY2FzZSlcbiAgICAgLSBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSlcbiAgICAgLSBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXJcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uLCBkZWZhdWx0IGlzIEBtaW5hLmxpbmVhclxuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBkZXNjcmlwdG9yXG4gICAgIG8ge1xuICAgICBvICAgICAgICAgaWQgKHN0cmluZykgYW5pbWF0aW9uIGlkLFxuICAgICBvICAgICAgICAgc3RhcnQgKG51bWJlcikgc3RhcnQgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlbmQgKG51bWJlcikgZW5kIF9zbGF2ZV8gbnVtYmVyLFxuICAgICBvICAgICAgICAgYiAobnVtYmVyKSBzdGFydCBfbWFzdGVyXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBzIChudW1iZXIpIGFuaW1hdGlvbiBzdGF0dXMgKDAuLjEpLFxuICAgICBvICAgICAgICAgZHVyIChudW1iZXIpIGFuaW1hdGlvbiBkdXJhdGlvbixcbiAgICAgbyAgICAgICAgIHNwZCAobnVtYmVyKSBhbmltYXRpb24gc3BlZWQsXG4gICAgIG8gICAgICAgICBnZXQgKGZ1bmN0aW9uKSBnZXR0ZXIgb2YgX21hc3Rlcl8gbnVtYmVyIChzZWUgQG1pbmEudGltZSksXG4gICAgIG8gICAgICAgICBzZXQgKGZ1bmN0aW9uKSBzZXR0ZXIgb2YgX3NsYXZlXyBudW1iZXIsXG4gICAgIG8gICAgICAgICBlYXNpbmcgKGZ1bmN0aW9uKSBlYXNpbmcgZnVuY3Rpb24sIGRlZmF1bHQgaXMgQG1pbmEubGluZWFyLFxuICAgICBvICAgICAgICAgc3RhdHVzIChmdW5jdGlvbikgc3RhdHVzIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzcGVlZCAoZnVuY3Rpb24pIHNwZWVkIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGR1cmF0aW9uIGdldHRlci9zZXR0ZXIsXG4gICAgIG8gICAgICAgICBzdG9wIChmdW5jdGlvbikgYW5pbWF0aW9uIHN0b3BwZXJcbiAgICAgbyAgICAgICAgIHBhdXNlIChmdW5jdGlvbikgcGF1c2VzIHRoZSBhbmltYXRpb25cbiAgICAgbyAgICAgICAgIHJlc3VtZSAoZnVuY3Rpb24pIHJlc3VtZXMgdGhlIGFuaW1hdGlvblxuICAgICBvICAgICAgICAgdXBkYXRlIChmdW5jdGlvbikgY2FsbGVzIHNldHRlciB3aXRoIHRoZSByaWdodCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBtaW5hID0gZnVuY3Rpb24gKGEsIEEsIGIsIEIsIGdldCwgc2V0LCBlYXNpbmcpIHtcbiAgICAgICAgdmFyIGFuaW0gPSB7XG4gICAgICAgICAgICBpZDogSUQoKSxcbiAgICAgICAgICAgIHN0YXJ0OiBhLFxuICAgICAgICAgICAgZW5kOiBBLFxuICAgICAgICAgICAgYjogYixcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICBkdXI6IEIgLSBiLFxuICAgICAgICAgICAgc3BkOiAxLFxuICAgICAgICAgICAgZ2V0OiBnZXQsXG4gICAgICAgICAgICBzZXQ6IHNldCxcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nIHx8IG1pbmEubGluZWFyLFxuICAgICAgICAgICAgc3RhdHVzOiBzdGEsXG4gICAgICAgICAgICBzcGVlZDogc3BlZWQsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBzdG9wOiBzdG9waXQsXG4gICAgICAgICAgICBwYXVzZTogcGF1c2UsXG4gICAgICAgICAgICByZXN1bWU6IHJlc3VtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGlvbnNbYW5pbS5pZF0gPSBhbmltO1xuICAgICAgICB2YXIgbGVuID0gMCwgaTtcbiAgICAgICAgZm9yIChpIGluIGFuaW1hdGlvbnMpIGlmIChhbmltYXRpb25zLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIGlmIChsZW4gPT0gMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbiA9PSAxICYmIGZyYW1lKCk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEudGltZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLiBFcXVpdmFsZW50IHRvOlxuICAgICB8IGZ1bmN0aW9uICgpIHtcbiAgICAgfCAgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgbWluYS50aW1lID0gdGltZXI7XG4gICAgLypcXFxuICAgICAqIG1pbmEuZ2V0QnlJZFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBhbmltYXRpb24gYnkgaXRzIGlkXG4gICAgIC0gaWQgKHN0cmluZykgYW5pbWF0aW9uJ3MgaWRcbiAgICAgPSAob2JqZWN0KSBTZWUgQG1pbmFcbiAgICBcXCovXG4gICAgbWluYS5nZXRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2lkXSB8fCBudWxsO1xuICAgIH07XG5cbiAgICAvKlxcXG4gICAgICogbWluYS5saW5lYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERlZmF1bHQgbGluZWFyIGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEubGluZWFyID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5lYXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlb3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZW91dCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhuLCAxLjcpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWFzZWluXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFYXNlaW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5lYXNlaW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobiwgLjQ4KTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBtaW5hLmVhc2Vpbm91dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWFzZWlub3V0IGVhc2luZ1xuICAgICAtIG4gKG51bWJlcikgaW5wdXQgMC4uMVxuICAgICA9IChudW1iZXIpIG91dHB1dCAwLi4xXG4gICAgXFwqL1xuICAgIG1pbmEuZWFzZWlub3V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHEgPSAuNDggLSBuIC8gMS4wNCxcbiAgICAgICAgICAgIFEgPSBNYXRoLnNxcnQoLjE3MzQgKyBxICogcSksXG4gICAgICAgICAgICB4ID0gUSAtIHEsXG4gICAgICAgICAgICBYID0gTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKSAqICh4IDwgMCA/IC0xIDogMSksXG4gICAgICAgICAgICB5ID0gLVEgLSBxLFxuICAgICAgICAgICAgWSA9IE1hdGgucG93KE1hdGguYWJzKHkpLCAxIC8gMykgKiAoeSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICAgICAgdCA9IFggKyBZICsgLjU7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogMyAqIHQgKiB0ICsgdCAqIHQgKiB0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja2luXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBCYWNraW4gZWFzaW5nXG4gICAgIC0gbiAobnVtYmVyKSBpbnB1dCAwLi4xXG4gICAgID0gKG51bWJlcikgb3V0cHV0IDAuLjFcbiAgICBcXCovXG4gICAgbWluYS5iYWNraW4gPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBuICogbiAqICgocyArIDEpICogbiAtIHMpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuYmFja291dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmFja291dCBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJhY2tvdXQgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBuID0gbiAtIDE7XG4gICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIG4gKiBuICogKChzICsgMSkgKiBuICsgcykgKyAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIG1pbmEuZWxhc3RpY1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRWxhc3RpYyBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmVsYXN0aWMgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PSAhIW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiBuKSAqIE1hdGguc2luKChuIC0gLjA3NSkgKlxuICAgICAgICAgICAgKDIgKiBNYXRoLlBJKSAvIC4zKSArIDE7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogbWluYS5ib3VuY2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJvdW5jZSBlYXNpbmdcbiAgICAgLSBuIChudW1iZXIpIGlucHV0IDAuLjFcbiAgICAgPSAobnVtYmVyKSBvdXRwdXQgMC4uMVxuICAgIFxcKi9cbiAgICBtaW5hLmJvdW5jZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBzID0gNy41NjI1LFxuICAgICAgICAgICAgcCA9IDIuNzUsXG4gICAgICAgICAgICBsO1xuICAgICAgICBpZiAobiA8IDEgLyBwKSB7XG4gICAgICAgICAgICBsID0gcyAqIG4gKiBuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4gPCAyIC8gcCkge1xuICAgICAgICAgICAgICAgIG4gLT0gMS41IC8gcDtcbiAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjc1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8IDIuNSAvIHApIHtcbiAgICAgICAgICAgICAgICAgICAgbiAtPSAyLjI1IC8gcDtcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMgKiBuICogbiArIC45Mzc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG4gLT0gMi42MjUgLyBwO1xuICAgICAgICAgICAgICAgICAgICBsID0gcyAqIG4gKiBuICsgLjk4NDM3NTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgICB3aW5kb3cubWluYSA9IG1pbmE7XG4gICAgcmV0dXJuIG1pbmE7XG59KSh0eXBlb2YgZXZlID09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiAoKSB7fSA6IGV2ZSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyAtIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbnZhciBTbmFwID0gKGZ1bmN0aW9uKHJvb3QpIHtcblNuYXAudmVyc2lvbiA9IFwiMC41LjFcIjtcbi8qXFxcbiAqIFNuYXBcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBkcmF3aW5nIHN1cmZhY2Ugb3Igd3JhcHMgZXhpc3RpbmcgU1ZHIGVsZW1lbnQuXG4gKipcbiAtIHdpZHRoIChudW1iZXJ8c3RyaW5nKSB3aWR0aCBvZiBzdXJmYWNlXG4gLSBoZWlnaHQgKG51bWJlcnxzdHJpbmcpIGhlaWdodCBvZiBzdXJmYWNlXG4gKiBvclxuIC0gRE9NIChTVkdFbGVtZW50KSBlbGVtZW50IHRvIGJlIHdyYXBwZWQgaW50byBTbmFwIHN0cnVjdHVyZVxuICogb3JcbiAtIGFycmF5IChhcnJheSkgYXJyYXkgb2YgZWxlbWVudHMgKHdpbGwgcmV0dXJuIHNldCBvZiBlbGVtZW50cylcbiAqIG9yXG4gLSBxdWVyeSAoc3RyaW5nKSBDU1MgcXVlcnkgc2VsZWN0b3JcbiA9IChvYmplY3QpIEBFbGVtZW50XG5cXCovXG5mdW5jdGlvbiBTbmFwKHcsIGgpIHtcbiAgICBpZiAodykge1xuICAgICAgICBpZiAody5ub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHcsIFwiYXJyYXlcIikgJiYgU25hcC5zZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLnNldC5hcHBseShTbmFwLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdyA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IoU3RyaW5nKHcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcCh3KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3ID0gdyA9PSBudWxsID8gXCIxMDAlXCIgOiB3O1xuICAgIGggPSBoID09IG51bGwgPyBcIjEwMCVcIiA6IGg7XG4gICAgcmV0dXJuIG5ldyBQYXBlcih3LCBoKTtcbn1cblNuYXAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiU25hcCB2XCIgKyB0aGlzLnZlcnNpb247XG59O1xuU25hcC5fID0ge307XG52YXIgZ2xvYiA9IHtcbiAgICB3aW46IHJvb3Qud2luZG93LFxuICAgIGRvYzogcm9vdC53aW5kb3cuZG9jdW1lbnRcbn07XG5TbmFwLl8uZ2xvYiA9IGdsb2I7XG52YXIgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIFN0ciA9IFN0cmluZyxcbiAgICB0b0Zsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICB0b0ludCA9IHBhcnNlSW50LFxuICAgIG1hdGggPSBNYXRoLFxuICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICBtbWluID0gbWF0aC5taW4sXG4gICAgYWJzID0gbWF0aC5hYnMsXG4gICAgcG93ID0gbWF0aC5wb3csXG4gICAgUEkgPSBtYXRoLlBJLFxuICAgIHJvdW5kID0gbWF0aC5yb3VuZCxcbiAgICBFID0gXCJcIixcbiAgICBTID0gXCIgXCIsXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIElTVVJMID0gL151cmxcXChbJ1wiXT8oW15cXCldKz8pWydcIl0/XFwpJC9pLFxuICAgIGNvbG91clJlZ0V4cCA9IC9eXFxzKigoI1thLWZcXGRdezZ9KXwoI1thLWZcXGRdezN9KXxyZ2JhP1xcKFxccyooW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/KD86XFxzKixcXHMqW1xcZFxcLl0rJT8pPylcXHMqXFwpfGhzYmE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/JT8pXFxzKlxcKXxoc2xhP1xcKFxccyooW1xcZFxcLl0rKD86ZGVnfFxceGIwfCUpP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rKD86JT9cXHMqLFxccypbXFxkXFwuXSspPyU/KVxccypcXCkpXFxzKiQvaSxcbiAgICBiZXppZXJyZyA9IC9eKD86Y3ViaWMtKT9iZXppZXJcXCgoW14sXSspLChbXixdKyksKFteLF0rKSwoW15cXCldKylcXCkvLFxuICAgIHNlcGFyYXRvciA9IFNuYXAuXy5zZXBhcmF0b3IgPSAvWyxcXHNdKy8sXG4gICAgd2hpdGVzcGFjZSA9IC9bXFxzXS9nLFxuICAgIGNvbW1hU3BhY2VzID0gL1tcXHNdKixbXFxzXSovLFxuICAgIGhzcmcgPSB7aHM6IDEsIHJnOiAxfSxcbiAgICBwYXRoQ29tbWFuZCA9IC8oW2Etel0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHRDb21tYW5kID0gLyhbcnN0bV0pW1xccyxdKigoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspP1tcXHNdKiw/W1xcc10qKSspL2lnLFxuICAgIHBhdGhWYWx1ZXMgPSAvKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pW1xcc10qLD9bXFxzXSovaWcsXG4gICAgaWRnZW4gPSAwLFxuICAgIGlkcHJlZml4ID0gXCJTXCIgKyAoK25ldyBEYXRlKS50b1N0cmluZygzNiksXG4gICAgSUQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIChlbCAmJiBlbC50eXBlID8gZWwudHlwZSA6IEUpICsgaWRwcmVmaXggKyAoaWRnZW4rKykudG9TdHJpbmcoMzYpO1xuICAgIH0sXG4gICAgeGxpbmsgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICB4bWxucyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBodWIgPSB7fSxcbiAgICAvKlxcXG4gICAgICogU25hcC51cmxcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFdyYXBzIHBhdGggaW50byBgXCJ1cmwoJzxwYXRoPicpXCJgLlxuICAgICAtIHZhbHVlIChzdHJpbmcpIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB3cmFwcGVkIHBhdGhcbiAgICBcXCovXG4gICAgVVJMID0gU25hcC51cmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBcInVybCgnI1wiICsgdXJsICsgXCInKVwiO1xuICAgIH07XG5cbmZ1bmN0aW9uICQoZWwsIGF0dHIpIHtcbiAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoZWwgPT0gXCIjdGV4dFwiKSB7XG4gICAgICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZVRleHROb2RlKGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsID09IFwiI2NvbW1lbnRcIikge1xuICAgICAgICAgICAgZWwgPSBnbG9iLmRvYy5jcmVhdGVDb21tZW50KGF0dHIudGV4dCB8fCBhdHRyW1wiI3RleHRcIl0gfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbCA9ICQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLnN1YnN0cmluZygwLCA2KSA9PSBcInhsaW5rOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGVOUyh4bGluaywgYXR0ci5zdWJzdHJpbmcoNikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZU5TKHhtbG5zLCBhdHRyLnN1YnN0cmluZyg0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHIpIGlmIChhdHRyW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBTdHIoYXR0cltrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDYpID09IFwieGxpbms6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rLCBrZXkuc3Vic3RyaW5nKDYpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleS5zdWJzdHJpbmcoMCwgNCkgPT0gXCJ4bWw6XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCBrZXkuc3Vic3RyaW5nKDQpLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInRleHRcIiBpbiBhdHRyKSB7XG4gICAgICAgICAgICBlbC5ub2RlVmFsdWUgPSBhdHRyLnRleHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGdsb2IuZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxucywgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5TbmFwLl8uJCA9ICQ7XG5TbmFwLl8uaWQgPSBJRDtcbmZ1bmN0aW9uIGdldEF0dHJzKGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV0ubmFtZXNwYWNlVVJJID09IHhsaW5rKSB7XG4gICAgICAgICAgICBuYW1lID0gXCJ4bGluazpcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgKz0gYXR0cnNbaV0ubmFtZTtcbiAgICAgICAgb3V0W25hbWVdID0gYXR0cnNbaV0udGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpcyhvLCB0eXBlKSB7XG4gICAgdHlwZSA9IFN0ci5wcm90b3R5cGUudG9Mb3dlckNhc2UuY2FsbCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShvKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJhcnJheVwiICYmXG4gICAgICAgIChvIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG8pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICB0eXBlID09IFwibnVsbFwiICYmIG8gPT09IG51bGwgfHxcbiAgICAgICAgICAgIHR5cGUgPT0gdHlwZW9mIG8gJiYgbyAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZSA9PSBcIm9iamVjdFwiICYmIG8gPT09IE9iamVjdChvKSB8fFxuICAgICAgICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKSA9PSB0eXBlO1xufVxuLypcXFxuICogU25hcC5mb3JtYXRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJlcGxhY2VzIGNvbnN0cnVjdGlvbiBvZiB0eXBlIGB7PG5hbWU+fWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXJndW1lbnRcbiAqKlxuIC0gdG9rZW4gKHN0cmluZykgc3RyaW5nIHRvIGZvcm1hdFxuIC0ganNvbiAob2JqZWN0KSBvYmplY3Qgd2hpY2ggcHJvcGVydGllcyBhcmUgdXNlZCBhcyBhIHJlcGxhY2VtZW50XG4gPSAoc3RyaW5nKSBmb3JtYXR0ZWQgc3RyaW5nXG4gPiBVc2FnZVxuIHwgLy8gdGhpcyBkcmF3cyBhIHJlY3Rhbmd1bGFyIHNoYXBlIGVxdWl2YWxlbnQgdG8gXCJNMTAsMjBoNDB2NTBoLTQwelwiXG4gfCBwYXBlci5wYXRoKFNuYXAuZm9ybWF0KFwiTXt4fSx7eX1oe2RpbS53aWR0aH12e2RpbS5oZWlnaHR9aHtkaW1bJ25lZ2F0aXZlIHdpZHRoJ119elwiLCB7XG4gfCAgICAgeDogMTAsXG4gfCAgICAgeTogMjAsXG4gfCAgICAgZGltOiB7XG4gfCAgICAgICAgIHdpZHRoOiA0MCxcbiB8ICAgICAgICAgaGVpZ2h0OiA1MCxcbiB8ICAgICAgICAgXCJuZWdhdGl2ZSB3aWR0aFwiOiAtNDBcbiB8ICAgICB9XG4gfCB9KSk7XG5cXCovXG5TbmFwLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuUmVnZXggPSAvXFx7KFteXFx9XSspXFx9L2csXG4gICAgICAgIG9iak5vdGF0aW9uUmVnZXggPSAvKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZywgLy8gbWF0Y2hlcyAueHh4eHggb3IgW1wieHh4eHhcIl0gdG8gcnVuIG92ZXIgb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoYWxsLCBrZXksIG9iaikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG9iajtcbiAgICAgICAgICAgIGtleS5yZXBsYWNlKG9iak5vdGF0aW9uUmVnZXgsIGZ1bmN0aW9uIChhbGwsIG5hbWUsIHF1b3RlLCBxdW90ZWROYW1lLCBpc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCBxdW90ZWROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcyA9PSBcImZ1bmN0aW9uXCIgJiYgaXNGdW5jICYmIChyZXMgPSByZXMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXMgPSAocmVzID09IG51bGwgfHwgcmVzID09IG9iaiA/IGFsbCA6IHJlcykgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgb2JqKSB7XG4gICAgICAgIHJldHVybiBTdHIoc3RyKS5yZXBsYWNlKHRva2VuUmVnZXgsIGZ1bmN0aW9uIChhbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGFsbCwga2V5LCBvYmopO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09IFwiZnVuY3Rpb25cIiB8fCBPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByZXMgPSBuZXcgb2JqLmNvbnN0cnVjdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChvYmpbaGFzXShrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gY2xvbmUob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuU25hcC5fLmNsb25lID0gY2xvbmU7XG5mdW5jdGlvbiByZXB1c2goYXJyYXksIGl0ZW0pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LnB1c2goYXJyYXkuc3BsaWNlKGksIDEpWzBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWNoZXIoZiwgc2NvcGUsIHBvc3Rwcm9jZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBuZXdmKCkge1xuICAgICAgICB2YXIgYXJnID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmcuam9pbihcIlxcdTI0MDBcIiksXG4gICAgICAgICAgICBjYWNoZSA9IG5ld2YuY2FjaGUgPSBuZXdmLmNhY2hlIHx8IHt9LFxuICAgICAgICAgICAgY291bnQgPSBuZXdmLmNvdW50ID0gbmV3Zi5jb3VudCB8fCBbXTtcbiAgICAgICAgaWYgKGNhY2hlW2hhc10oYXJncykpIHtcbiAgICAgICAgICAgIHJlcHVzaChjb3VudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gcG9zdHByb2Nlc3NvciA/IHBvc3Rwcm9jZXNzb3IoY2FjaGVbYXJnc10pIDogY2FjaGVbYXJnc107XG4gICAgICAgIH1cbiAgICAgICAgY291bnQubGVuZ3RoID49IDFlMyAmJiBkZWxldGUgY2FjaGVbY291bnQuc2hpZnQoKV07XG4gICAgICAgIGNvdW50LnB1c2goYXJncyk7XG4gICAgICAgIGNhY2hlW2FyZ3NdID0gZi5hcHBseShzY29wZSwgYXJnKTtcbiAgICAgICAgcmV0dXJuIHBvc3Rwcm9jZXNzb3IgPyBwb3N0cHJvY2Vzc29yKGNhY2hlW2FyZ3NdKSA6IGNhY2hlW2FyZ3NdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Zjtcbn1cblNuYXAuXy5jYWNoZXIgPSBjYWNoZXI7XG5mdW5jdGlvbiBhbmdsZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgaWYgKHgzID09IG51bGwpIHtcbiAgICAgICAgdmFyIHggPSB4MSAtIHgyLFxuICAgICAgICAgICAgeSA9IHkxIC0geTI7XG4gICAgICAgIGlmICgheCAmJiAheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgxODAgKyBtYXRoLmF0YW4yKC15LCAteCkgKiAxODAgLyBQSSArIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlKHgxLCB5MSwgeDMsIHkzKSAtIGFuZ2xlKHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByYWQoZGVnKSB7XG4gICAgcmV0dXJuIGRlZyAlIDM2MCAqIFBJIC8gMTgwO1xufVxuZnVuY3Rpb24gZGVnKHJhZCkge1xuICAgIHJldHVybiByYWQgKiAxODAgLyBQSSAlIDM2MDtcbn1cbmZ1bmN0aW9uIHhfeSgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgUyArIHRoaXMueTtcbn1cbmZ1bmN0aW9uIHhfeV93X2goKSB7XG4gICAgcmV0dXJuIHRoaXMueCArIFMgKyB0aGlzLnkgKyBTICsgdGhpcy53aWR0aCArIFwiIFxceGQ3IFwiICsgdGhpcy5oZWlnaHQ7XG59XG5cbi8qXFxcbiAqIFNuYXAucmFkXG4gWyBtZXRob2QgXVxuICoqXG4gKiBUcmFuc2Zvcm0gYW5nbGUgdG8gcmFkaWFuc1xuIC0gZGVnIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGFuZ2xlIGluIHJhZGlhbnNcblxcKi9cblNuYXAucmFkID0gcmFkO1xuLypcXFxuICogU25hcC5kZWdcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFRyYW5zZm9ybSBhbmdsZSB0byBkZWdyZWVzXG4gLSByYWQgKG51bWJlcikgYW5nbGUgaW4gcmFkaWFuc1xuID0gKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5kZWcgPSBkZWc7XG4vKlxcXG4gKiBTbmFwLnNpblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5zaW4oKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gYW5nbGUgKG51bWJlcikgYW5nbGUgaW4gZGVncmVlc1xuID0gKG51bWJlcikgc2luXG5cXCovXG5TbmFwLnNpbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIHJldHVybiBtYXRoLnNpbihTbmFwLnJhZChhbmdsZSkpO1xufTtcbi8qXFxcbiAqIFNuYXAudGFuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLnRhbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBpbiBkZWdyZWVzXG4gPSAobnVtYmVyKSB0YW5cblxcKi9cblNuYXAudGFuID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIG1hdGgudGFuKFNuYXAucmFkKGFuZ2xlKSk7XG59O1xuLypcXFxuICogU25hcC5jb3NcbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguY29zKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIGFuZ2xlIChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcbiA9IChudW1iZXIpIGNvc1xuXFwqL1xuU25hcC5jb3MgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gbWF0aC5jb3MoU25hcC5yYWQoYW5nbGUpKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFzaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIEVxdWl2YWxlbnQgdG8gYE1hdGguYXNpbigpYCBvbmx5IHdvcmtzIHdpdGggZGVncmVlcywgbm90IHJhZGlhbnMuXG4gLSBudW0gKG51bWJlcikgdmFsdWVcbiA9IChudW1iZXIpIGFzaW4gaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hc2luID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBTbmFwLmRlZyhtYXRoLmFzaW4obnVtKSk7XG59O1xuLypcXFxuICogU25hcC5hY29zXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmFjb3MoKWAgb25seSB3b3JrcyB3aXRoIGRlZ3JlZXMsIG5vdCByYWRpYW5zLlxuIC0gbnVtIChudW1iZXIpIHZhbHVlXG4gPSAobnVtYmVyKSBhY29zIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYWNvcyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hY29zKG51bSkpO1xufTtcbi8qXFxcbiAqIFNuYXAuYXRhblxuIFsgbWV0aG9kIF1cbiAqKlxuICogRXF1aXZhbGVudCB0byBgTWF0aC5hdGFuKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbiBpbiBkZWdyZWVzXG5cXCovXG5TbmFwLmF0YW4gPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIFNuYXAuZGVnKG1hdGguYXRhbihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmF0YW4yXG4gWyBtZXRob2QgXVxuICoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmF0YW4yKClgIG9ubHkgd29ya3Mgd2l0aCBkZWdyZWVzLCBub3QgcmFkaWFucy5cbiAtIG51bSAobnVtYmVyKSB2YWx1ZVxuID0gKG51bWJlcikgYXRhbjIgaW4gZGVncmVlc1xuXFwqL1xuU25hcC5hdGFuMiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gU25hcC5kZWcobWF0aC5hdGFuMihudW0pKTtcbn07XG4vKlxcXG4gKiBTbmFwLmFuZ2xlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gdHdvIG9yIHRocmVlIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gLSB4MyAobnVtYmVyKSAjb3B0aW9uYWwgeCBjb29yZCBvZiB0aGlyZCBwb2ludFxuIC0geTMgKG51bWJlcikgI29wdGlvbmFsIHkgY29vcmQgb2YgdGhpcmQgcG9pbnRcbiA9IChudW1iZXIpIGFuZ2xlIGluIGRlZ3JlZXNcblxcKi9cblNuYXAuYW5nbGUgPSBhbmdsZTtcbi8qXFxcbiAqIFNuYXAubGVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFNuYXAubGVuMih4MSwgeTEsIHgyLCB5MikpO1xufTtcbi8qXFxcbiAqIFNuYXAubGVuMlxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuIC0geDEgKG51bWJlcikgeCBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geTEgKG51bWJlcikgeSBjb29yZCBvZiBmaXJzdCBwb2ludFxuIC0geDIgKG51bWJlcikgeCBjb29yZCBvZiBzZWNvbmQgcG9pbnRcbiAtIHkyIChudW1iZXIpIHkgY29vcmQgb2Ygc2Vjb25kIHBvaW50XG4gPSAobnVtYmVyKSBkaXN0YW5jZVxuXFwqL1xuU25hcC5sZW4yID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MSAtIHgyKSAqICh4MSAtIHgyKSArICh5MSAtIHkyKSAqICh5MSAtIHkyKTtcbn07XG4vKlxcXG4gKiBTbmFwLmNsb3Nlc3RQb2ludFxuIFsgbWV0aG9kIF1cbiAqKlxuICogUmV0dXJucyBjbG9zZXN0IHBvaW50IHRvIGEgZ2l2ZW4gb25lIG9uIGEgZ2l2ZW4gcGF0aC5cbiAtIHBhdGggKEVsZW1lbnQpIHBhdGggZWxlbWVudFxuIC0geCAobnVtYmVyKSB4IGNvb3JkIG9mIGEgcG9pbnRcbiAtIHkgKG51bWJlcikgeSBjb29yZCBvZiBhIHBvaW50XG4gPSAob2JqZWN0KSBpbiBmb3JtYXRcbiB7XG4gICAgeCAobnVtYmVyKSB4IGNvb3JkIG9mIHRoZSBwb2ludCBvbiB0aGUgcGF0aFxuICAgIHkgKG51bWJlcikgeSBjb29yZCBvZiB0aGUgcG9pbnQgb24gdGhlIHBhdGhcbiAgICBsZW5ndGggKG51bWJlcikgbGVuZ3RoIG9mIHRoZSBwYXRoIHRvIHRoZSBwb2ludFxuICAgIGRpc3RhbmNlIChudW1iZXIpIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBwYXRoXG4gfVxuXFwqL1xuLy8gQ29waWVkIGZyb20gaHR0cDovL2JsLm9ja3Mub3JnL21ib3N0b2NrLzgwMjc2MzdcblNuYXAuY2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gKHBhdGgsIHgsIHkpIHtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZTIocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4LFxuICAgICAgICAgICAgZHkgPSBwLnkgLSB5O1xuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIHZhciBwYXRoTm9kZSA9IHBhdGgubm9kZSxcbiAgICAgICAgcGF0aExlbmd0aCA9IHBhdGhOb2RlLmdldFRvdGFsTGVuZ3RoKCksXG4gICAgICAgIHByZWNpc2lvbiA9IHBhdGhMZW5ndGggLyBwYXRoTm9kZS5wYXRoU2VnTGlzdC5udW1iZXJPZkl0ZW1zICogLjEyNSxcbiAgICAgICAgYmVzdCxcbiAgICAgICAgYmVzdExlbmd0aCxcbiAgICAgICAgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAvLyBsaW5lYXIgc2NhbiBmb3IgY29hcnNlIGFwcHJveGltYXRpb25cbiAgICBmb3IgKHZhciBzY2FuLCBzY2FuTGVuZ3RoID0gMCwgc2NhbkRpc3RhbmNlOyBzY2FuTGVuZ3RoIDw9IHBhdGhMZW5ndGg7IHNjYW5MZW5ndGggKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmICgoc2NhbkRpc3RhbmNlID0gZGlzdGFuY2UyKHNjYW4gPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKHNjYW5MZW5ndGgpKSkgPCBiZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGJlc3QgPSBzY2FuO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IHNjYW5MZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBzY2FuRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiaW5hcnkgc2VhcmNoIGZvciBwcmVjaXNlIGVzdGltYXRlXG4gICAgcHJlY2lzaW9uICo9IC41O1xuICAgIHdoaWxlIChwcmVjaXNpb24gPiAuNSkge1xuICAgICAgICB2YXIgYmVmb3JlLFxuICAgICAgICAgICAgYWZ0ZXIsXG4gICAgICAgICAgICBiZWZvcmVMZW5ndGgsXG4gICAgICAgICAgICBhZnRlckxlbmd0aCxcbiAgICAgICAgICAgIGJlZm9yZURpc3RhbmNlLFxuICAgICAgICAgICAgYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgaWYgKChiZWZvcmVMZW5ndGggPSBiZXN0TGVuZ3RoIC0gcHJlY2lzaW9uKSA+PSAwICYmIChiZWZvcmVEaXN0YW5jZSA9IGRpc3RhbmNlMihiZWZvcmUgPSBwYXRoTm9kZS5nZXRQb2ludEF0TGVuZ3RoKGJlZm9yZUxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGJlZm9yZTtcbiAgICAgICAgICAgIGJlc3RMZW5ndGggPSBiZWZvcmVMZW5ndGg7XG4gICAgICAgICAgICBiZXN0RGlzdGFuY2UgPSBiZWZvcmVEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICgoYWZ0ZXJMZW5ndGggPSBiZXN0TGVuZ3RoICsgcHJlY2lzaW9uKSA8PSBwYXRoTGVuZ3RoICYmIChhZnRlckRpc3RhbmNlID0gZGlzdGFuY2UyKGFmdGVyID0gcGF0aE5vZGUuZ2V0UG9pbnRBdExlbmd0aChhZnRlckxlbmd0aCkpKSA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgYmVzdCA9IGFmdGVyO1xuICAgICAgICAgICAgYmVzdExlbmd0aCA9IGFmdGVyTGVuZ3RoO1xuICAgICAgICAgICAgYmVzdERpc3RhbmNlID0gYWZ0ZXJEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWNpc2lvbiAqPSAuNTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlc3QgPSB7XG4gICAgICAgIHg6IGJlc3QueCxcbiAgICAgICAgeTogYmVzdC55LFxuICAgICAgICBsZW5ndGg6IGJlc3RMZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoYmVzdERpc3RhbmNlKVxuICAgIH07XG4gICAgcmV0dXJuIGJlc3Q7XG59XG4vKlxcXG4gKiBTbmFwLmlzXG4gWyBtZXRob2QgXVxuICoqXG4gKiBIYW5keSByZXBsYWNlbWVudCBmb3IgdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gLSBvICjigKYpIGFueSBvYmplY3Qgb3IgcHJpbWl0aXZlXG4gLSB0eXBlIChzdHJpbmcpIG5hbWUgb2YgdGhlIHR5cGUsIGUuZy4sIGBzdHJpbmdgLCBgZnVuY3Rpb25gLCBgbnVtYmVyYCwgZXRjLlxuID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBnaXZlbiB2YWx1ZSBpcyBvZiBnaXZlbiB0eXBlXG5cXCovXG5TbmFwLmlzID0gaXM7XG4vKlxcXG4gKiBTbmFwLnNuYXBUb1xuIFsgbWV0aG9kIF1cbiAqKlxuICogU25hcHMgZ2l2ZW4gdmFsdWUgdG8gZ2l2ZW4gZ3JpZFxuIC0gdmFsdWVzIChhcnJheXxudW1iZXIpIGdpdmVuIGFycmF5IG9mIHZhbHVlcyBvciBzdGVwIG9mIHRoZSBncmlkXG4gLSB2YWx1ZSAobnVtYmVyKSB2YWx1ZSB0byBhZGp1c3RcbiAtIHRvbGVyYW5jZSAobnVtYmVyKSAjb3B0aW9uYWwgbWF4aW11bSBkaXN0YW5jZSB0byB0aGUgdGFyZ2V0IHZhbHVlIHRoYXQgd291bGQgdHJpZ2dlciB0aGUgc25hcC4gRGVmYXVsdCBpcyBgMTBgLlxuID0gKG51bWJlcikgYWRqdXN0ZWQgdmFsdWVcblxcKi9cblNuYXAuc25hcFRvID0gZnVuY3Rpb24gKHZhbHVlcywgdmFsdWUsIHRvbGVyYW5jZSkge1xuICAgIHRvbGVyYW5jZSA9IGlzKHRvbGVyYW5jZSwgXCJmaW5pdGVcIikgPyB0b2xlcmFuY2UgOiAxMDtcbiAgICBpZiAoaXModmFsdWVzLCBcImFycmF5XCIpKSB7XG4gICAgICAgIHZhciBpID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgaWYgKGFicyh2YWx1ZXNbaV0gLSB2YWx1ZSkgPD0gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzID0gK3ZhbHVlcztcbiAgICAgICAgdmFyIHJlbSA9IHZhbHVlICUgdmFsdWVzO1xuICAgICAgICBpZiAocmVtIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgLSByZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbSA+IHZhbHVlcyAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC0gcmVtICsgdmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vLyBDb2xvdXJcbi8qXFxcbiAqIFNuYXAuZ2V0UkdCXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgY29sb3Igc3RyaW5nIGFzIFJHQiBvYmplY3RcbiAtIGNvbG9yIChzdHJpbmcpIGNvbG9yIHN0cmluZyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICMgPHVsPlxuICMgICAgIDxsaT5Db2xvciBuYW1lICg8Y29kZT5yZWQ8L2NvZGU+LCA8Y29kZT5ncmVlbjwvY29kZT4sIDxjb2RlPmNvcm5mbG93ZXJibHVlPC9jb2RlPiwgZXRjKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKIg4oCUIHNob3J0ZW5lZCBIVE1MIGNvbG9yOiAoPGNvZGU+IzAwMDwvY29kZT4sIDxjb2RlPiNmYzA8L2NvZGU+LCBldGMuKTwvbGk+XG4gIyAgICAgPGxpPiPigKLigKLigKLigKLigKLigKIg4oCUIGZ1bGwgbGVuZ3RoIEhUTUwgY29sb3I6ICg8Y29kZT4jMDAwMDAwPC9jb2RlPiwgPGNvZGU+I2JkMjMwMDwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzIHZhbHVlczogKDxjb2RlPnJnYigyMDAsJm5ic3A7MTAwLCZuYnNwOzApPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+cmdiKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTogKDxjb2RlPnJnYigxMDAlLCZuYnNwOzE3NSUsJm5ic3A7MCUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5yZ2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBicmlnaHRuZXNzIHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDsxKTwvY29kZT4pPC9saT5cbiAjICAgICA8bGk+aHNiYSjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzYijigKLigKLigKIlLCDigKLigKLigKIlLCDigKLigKLigKIlKSDigJQgc2FtZSBhcyBhYm92ZSwgYnV0IGluICU8L2xpPlxuICMgICAgIDxsaT5oc2JhKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBhbHNvIHdpdGggb3BhY2l0eTwvbGk+XG4gIyAgICAgPGxpPmhzbCjigKLigKLigKIsIOKAouKAouKAoiwg4oCi4oCi4oCiKSDigJQgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbm9zaXR5IHZhbHVlczogKDxjb2RlPmhzYigwLjUsJm5ic3A7MC4yNSwmbmJzcDswLjUpPC9jb2RlPik8L2xpPlxuICMgICAgIDxsaT5oc2xhKOKAouKAouKAoiwg4oCi4oCi4oCiLCDigKLigKLigKIsIOKAouKAouKAoikg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjICAgICA8bGk+aHNsKOKAouKAouKAoiUsIOKAouKAouKAoiUsIOKAouKAouKAoiUpIOKAlCBzYW1lIGFzIGFib3ZlLCBidXQgaW4gJTwvbGk+XG4gIyAgICAgPGxpPmhzbGEo4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSwg4oCi4oCi4oCiJSkg4oCUIGFsc28gd2l0aCBvcGFjaXR5PC9saT5cbiAjIDwvdWw+XG4gKiBOb3RlIHRoYXQgYCVgIGNhbiBiZSB1c2VkIGFueSB0aW1lOiBgcmdiKDIwJSwgMjU1LCA1MCUpYC5cbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAoixcbiBvICAgICBlcnJvciAoYm9vbGVhbikgdHJ1ZSBpZiBzdHJpbmcgY2FuJ3QgYmUgcGFyc2VkXG4gbyB9XG5cXCovXG5TbmFwLmdldFJHQiA9IGNhY2hlcihmdW5jdGlvbiAoY29sb3VyKSB7XG4gICAgaWYgKCFjb2xvdXIgfHwgISEoKGNvbG91ciA9IFN0cihjb2xvdXIpKS5pbmRleE9mKFwiLVwiKSArIDEpKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIGlmIChjb2xvdXIgPT0gXCJub25lXCIpIHtcbiAgICAgICAgcmV0dXJuIHtyOiAtMSwgZzogLTEsIGI6IC0xLCBoZXg6IFwibm9uZVwiLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgIH1cbiAgICAhKGhzcmdbaGFzXShjb2xvdXIudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMCwgMikpIHx8IGNvbG91ci5jaGFyQXQoKSA9PSBcIiNcIikgJiYgKGNvbG91ciA9IHRvSGV4KGNvbG91cikpO1xuICAgIGlmICghY29sb3VyKSB7XG4gICAgICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG4gICAgfVxuICAgIHZhciByZXMsXG4gICAgICAgIHJlZCxcbiAgICAgICAgZ3JlZW4sXG4gICAgICAgIGJsdWUsXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHQsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgcmdiID0gY29sb3VyLm1hdGNoKGNvbG91clJlZ0V4cCk7XG4gICAgaWYgKHJnYikge1xuICAgICAgICBpZiAocmdiWzJdKSB7XG4gICAgICAgICAgICBibHVlID0gdG9JbnQocmdiWzJdLnN1YnN0cmluZyg1KSwgMTYpO1xuICAgICAgICAgICAgZ3JlZW4gPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDMsIDUpLCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludChyZ2JbMl0uc3Vic3RyaW5nKDEsIDMpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJnYlszXSkge1xuICAgICAgICAgICAgYmx1ZSA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgzKSkgKyB0LCAxNik7XG4gICAgICAgICAgICBncmVlbiA9IHRvSW50KCh0ID0gcmdiWzNdLmNoYXJBdCgyKSkgKyB0LCAxNik7XG4gICAgICAgICAgICByZWQgPSB0b0ludCgodCA9IHJnYlszXS5jaGFyQXQoMSkpICsgdCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNF0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls0XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgKj0gMi41NSk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuICo9IDIuNTUpO1xuICAgICAgICAgICAgYmx1ZSA9IHRvRmxvYXQodmFsdWVzWzJdKTtcbiAgICAgICAgICAgIHZhbHVlc1syXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGJsdWUgKj0gMi41NSk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcInJnYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZ2JbNV0pIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHJnYls1XS5zcGxpdChjb21tYVNwYWNlcyk7XG4gICAgICAgICAgICByZWQgPSB0b0Zsb2F0KHZhbHVlc1swXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiJVwiICYmIChyZWQgLz0gMTAwKTtcbiAgICAgICAgICAgIGdyZWVuID0gdG9GbG9hdCh2YWx1ZXNbMV0pO1xuICAgICAgICAgICAgdmFsdWVzWzFdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoZ3JlZW4gLz0gMTAwKTtcbiAgICAgICAgICAgIGJsdWUgPSB0b0Zsb2F0KHZhbHVlc1syXSk7XG4gICAgICAgICAgICB2YWx1ZXNbMl0uc2xpY2UoLTEpID09IFwiJVwiICYmIChibHVlIC89IDEwMCk7XG4gICAgICAgICAgICAodmFsdWVzWzBdLnNsaWNlKC0zKSA9PSBcImRlZ1wiIHx8IHZhbHVlc1swXS5zbGljZSgtMSkgPT0gXCJcXHhiMFwiKSAmJiAocmVkIC89IDM2MCk7XG4gICAgICAgICAgICByZ2JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLCA0KSA9PSBcImhzYmFcIiAmJiAob3BhY2l0eSA9IHRvRmxvYXQodmFsdWVzWzNdKSk7XG4gICAgICAgICAgICB2YWx1ZXNbM10gJiYgdmFsdWVzWzNdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAob3BhY2l0eSAvPSAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuaHNiMnJnYihyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmdiWzZdKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSByZ2JbNl0uc3BsaXQoY29tbWFTcGFjZXMpO1xuICAgICAgICAgICAgcmVkID0gdG9GbG9hdCh2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgdmFsdWVzWzBdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAocmVkIC89IDEwMCk7XG4gICAgICAgICAgICBncmVlbiA9IHRvRmxvYXQodmFsdWVzWzFdKTtcbiAgICAgICAgICAgIHZhbHVlc1sxXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKGdyZWVuIC89IDEwMCk7XG4gICAgICAgICAgICBibHVlID0gdG9GbG9hdCh2YWx1ZXNbMl0pO1xuICAgICAgICAgICAgdmFsdWVzWzJdLnNsaWNlKC0xKSA9PSBcIiVcIiAmJiAoYmx1ZSAvPSAxMDApO1xuICAgICAgICAgICAgKHZhbHVlc1swXS5zbGljZSgtMykgPT0gXCJkZWdcIiB8fCB2YWx1ZXNbMF0uc2xpY2UoLTEpID09IFwiXFx4YjBcIikgJiYgKHJlZCAvPSAzNjApO1xuICAgICAgICAgICAgcmdiWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNCkgPT0gXCJoc2xhXCIgJiYgKG9wYWNpdHkgPSB0b0Zsb2F0KHZhbHVlc1szXSkpO1xuICAgICAgICAgICAgdmFsdWVzWzNdICYmIHZhbHVlc1szXS5zbGljZSgtMSkgPT0gXCIlXCIgJiYgKG9wYWNpdHkgLz0gMTAwKTtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLmhzbDJyZ2IocmVkLCBncmVlbiwgYmx1ZSwgb3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkID0gbW1pbihtYXRoLnJvdW5kKHJlZCksIDI1NSk7XG4gICAgICAgIGdyZWVuID0gbW1pbihtYXRoLnJvdW5kKGdyZWVuKSwgMjU1KTtcbiAgICAgICAgYmx1ZSA9IG1taW4obWF0aC5yb3VuZChibHVlKSwgMjU1KTtcbiAgICAgICAgb3BhY2l0eSA9IG1taW4obW1heChvcGFjaXR5LCAwKSwgMSk7XG4gICAgICAgIHJnYiA9IHtyOiByZWQsIGc6IGdyZWVuLCBiOiBibHVlLCB0b1N0cmluZzogcmdidG9TdHJpbmd9O1xuICAgICAgICByZ2IuaGV4ID0gXCIjXCIgKyAoMTY3NzcyMTYgfCBibHVlIHwgZ3JlZW4gPDwgOCB8IHJlZCA8PCAxNikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICByZ2Iub3BhY2l0eSA9IGlzKG9wYWNpdHksIFwiZmluaXRlXCIpID8gb3BhY2l0eSA6IDE7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIHJldHVybiB7cjogLTEsIGc6IC0xLCBiOiAtMSwgaGV4OiBcIm5vbmVcIiwgZXJyb3I6IDEsIHRvU3RyaW5nOiByZ2J0b1N0cmluZ307XG59LCBTbmFwKTtcbi8qXFxcbiAqIFNuYXAuaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0IgdmFsdWVzIHRvIGEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuIC0gaCAobnVtYmVyKSBodWVcbiAtIHMgKG51bWJlcikgc2F0dXJhdGlvblxuIC0gYiAobnVtYmVyKSB2YWx1ZSBvciBicmlnaHRuZXNzXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLmhzYiA9IGNhY2hlcihmdW5jdGlvbiAoaCwgcywgYikge1xuICAgIHJldHVybiBTbmFwLmhzYjJyZ2IoaCwgcywgYikuaGV4O1xufSk7XG4vKlxcXG4gKiBTbmFwLmhzbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNMIHZhbHVlcyB0byBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sb3JcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKHN0cmluZykgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xvclxuXFwqL1xuU25hcC5oc2wgPSBjYWNoZXIoZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICByZXR1cm4gU25hcC5oc2wycmdiKGgsIHMsIGwpLmhleDtcbn0pO1xuLypcXFxuICogU25hcC5yZ2JcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENvbnZlcnRzIFJHQiB2YWx1ZXMgdG8gYSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG4gLSByIChudW1iZXIpIHJlZFxuIC0gZyAobnVtYmVyKSBncmVlblxuIC0gYiAobnVtYmVyKSBibHVlXG4gPSAoc3RyaW5nKSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbG9yXG5cXCovXG5TbmFwLnJnYiA9IGNhY2hlcihmdW5jdGlvbiAociwgZywgYiwgbykge1xuICAgIGlmIChpcyhvLCBcImZpbml0ZVwiKSkge1xuICAgICAgICB2YXIgcm91bmQgPSBtYXRoLnJvdW5kO1xuICAgICAgICByZXR1cm4gXCJyZ2JhKFwiICsgW3JvdW5kKHIpLCByb3VuZChnKSwgcm91bmQoYiksICtvLnRvRml4ZWQoMildICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBcIiNcIiArICgxNjc3NzIxNiB8IGIgfCBnIDw8IDggfCByIDw8IDE2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59KTtcbnZhciB0b0hleCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBpID0gZ2xvYi5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGdsb2IuZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3ZnXCIpWzBdLFxuICAgICAgICByZWQgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgdG9IZXggPSBjYWNoZXIoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvci50b0xvd2VyQ2FzZSgpID09IFwicmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IHJlZDtcbiAgICAgICAgaS5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgICB2YXIgb3V0ID0gZ2xvYi5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShpLCBFKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIik7XG4gICAgICAgIHJldHVybiBvdXQgPT0gcmVkID8gbnVsbCA6IG91dDtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9IZXgoY29sb3IpO1xufSxcbmhzYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzYihcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5iXSArIFwiKVwiO1xufSxcbmhzbHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImhzbChcIiArIFt0aGlzLmgsIHRoaXMucywgdGhpcy5sXSArIFwiKVwiO1xufSxcbnJnYnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT0gMSB8fCB0aGlzLm9wYWNpdHkgPT0gbnVsbCA/XG4gICAgICAgICAgICB0aGlzLmhleCA6XG4gICAgICAgICAgICBcInJnYmEoXCIgKyBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5vcGFjaXR5XSArIFwiKVwiO1xufSxcbnByZXBhcmVSR0IgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIGlmIChnID09IG51bGwgJiYgaXMociwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gciAmJiBcImdcIiBpbiByICYmIFwiYlwiIGluIHIpIHtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICB9XG4gICAgaWYgKGcgPT0gbnVsbCAmJiBpcyhyLCBzdHJpbmcpKSB7XG4gICAgICAgIHZhciBjbHIgPSBTbmFwLmdldFJHQihyKTtcbiAgICAgICAgciA9IGNsci5yO1xuICAgICAgICBnID0gY2xyLmc7XG4gICAgICAgIGIgPSBjbHIuYjtcbiAgICB9XG4gICAgaWYgKHIgPiAxIHx8IGcgPiAxIHx8IGIgPiAxKSB7XG4gICAgICAgIHIgLz0gMjU1O1xuICAgICAgICBnIC89IDI1NTtcbiAgICAgICAgYiAvPSAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbn0sXG5wYWNrYWdlUkdCID0gZnVuY3Rpb24gKHIsIGcsIGIsIG8pIHtcbiAgICByID0gbWF0aC5yb3VuZChyICogMjU1KTtcbiAgICBnID0gbWF0aC5yb3VuZChnICogMjU1KTtcbiAgICBiID0gbWF0aC5yb3VuZChiICogMjU1KTtcbiAgICB2YXIgcmdiID0ge1xuICAgICAgICByOiByLFxuICAgICAgICBnOiBnLFxuICAgICAgICBiOiBiLFxuICAgICAgICBvcGFjaXR5OiBpcyhvLCBcImZpbml0ZVwiKSA/IG8gOiAxLFxuICAgICAgICBoZXg6IFNuYXAucmdiKHIsIGcsIGIpLFxuICAgICAgICB0b1N0cmluZzogcmdidG9TdHJpbmdcbiAgICB9O1xuICAgIGlzKG8sIFwiZmluaXRlXCIpICYmIChyZ2Iub3BhY2l0eSA9IG8pO1xuICAgIHJldHVybiByZ2I7XG59O1xuLypcXFxuICogU25hcC5jb2xvclxuIFsgbWV0aG9kIF1cbiAqKlxuICogUGFyc2VzIHRoZSBjb2xvciBzdHJpbmcgYW5kIHJldHVybnMgYW4gb2JqZWN0IGZlYXR1cmluZyB0aGUgY29sb3IncyBjb21wb25lbnQgdmFsdWVzXG4gLSBjbHIgKHN0cmluZykgY29sb3Igc3RyaW5nIGluIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZvcm1hdHMgKHNlZSBAU25hcC5nZXRSR0IpXG4gPSAob2JqZWN0KSBDb21iaW5lZCBSR0IvSFNCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiLFxuIG8gICAgIGVycm9yIChib29sZWFuKSBgdHJ1ZWAgaWYgc3RyaW5nIGNhbid0IGJlIHBhcnNlZCxcbiBvICAgICBoIChudW1iZXIpIGh1ZSxcbiBvICAgICBzIChudW1iZXIpIHNhdHVyYXRpb24sXG4gbyAgICAgdiAobnVtYmVyKSB2YWx1ZSAoYnJpZ2h0bmVzcyksXG4gbyAgICAgbCAobnVtYmVyKSBsaWdodG5lc3NcbiBvIH1cblxcKi9cblNuYXAuY29sb3IgPSBmdW5jdGlvbiAoY2xyKSB7XG4gICAgdmFyIHJnYjtcbiAgICBpZiAoaXMoY2xyLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBjbHIgJiYgXCJzXCIgaW4gY2xyICYmIFwiYlwiIGluIGNscikge1xuICAgICAgICByZ2IgPSBTbmFwLmhzYjJyZ2IoY2xyKTtcbiAgICAgICAgY2xyLnIgPSByZ2IucjtcbiAgICAgICAgY2xyLmcgPSByZ2IuZztcbiAgICAgICAgY2xyLmIgPSByZ2IuYjtcbiAgICAgICAgY2xyLm9wYWNpdHkgPSAxO1xuICAgICAgICBjbHIuaGV4ID0gcmdiLmhleDtcbiAgICB9IGVsc2UgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gY2xyICYmIFwic1wiIGluIGNsciAmJiBcImxcIiBpbiBjbHIpIHtcbiAgICAgICAgcmdiID0gU25hcC5oc2wycmdiKGNscik7XG4gICAgICAgIGNsci5yID0gcmdiLnI7XG4gICAgICAgIGNsci5nID0gcmdiLmc7XG4gICAgICAgIGNsci5iID0gcmdiLmI7XG4gICAgICAgIGNsci5vcGFjaXR5ID0gMTtcbiAgICAgICAgY2xyLmhleCA9IHJnYi5oZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzKGNsciwgXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIGNsciA9IFNuYXAuZ2V0UkdCKGNscik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKGNsciwgXCJvYmplY3RcIikgJiYgXCJyXCIgaW4gY2xyICYmIFwiZ1wiIGluIGNsciAmJiBcImJcIiBpbiBjbHIgJiYgIShcImVycm9yXCIgaW4gY2xyKSkge1xuICAgICAgICAgICAgcmdiID0gU25hcC5yZ2IyaHNsKGNscik7XG4gICAgICAgICAgICBjbHIuaCA9IHJnYi5oO1xuICAgICAgICAgICAgY2xyLnMgPSByZ2IucztcbiAgICAgICAgICAgIGNsci5sID0gcmdiLmw7XG4gICAgICAgICAgICByZ2IgPSBTbmFwLnJnYjJoc2IoY2xyKTtcbiAgICAgICAgICAgIGNsci52ID0gcmdiLmI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbHIgPSB7aGV4OiBcIm5vbmVcIn07XG4gICAgICAgICAgICBjbHIuciA9IGNsci5nID0gY2xyLmIgPSBjbHIuaCA9IGNsci5zID0gY2xyLnYgPSBjbHIubCA9IC0xO1xuICAgICAgICAgICAgY2xyLmVycm9yID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbHIudG9TdHJpbmcgPSByZ2J0b1N0cmluZztcbiAgICByZXR1cm4gY2xyO1xufTtcbi8qXFxcbiAqIFNuYXAuaHNiMnJnYlxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ29udmVydHMgSFNCIHZhbHVlcyB0byBhbiBSR0Igb2JqZWN0XG4gLSBoIChudW1iZXIpIGh1ZVxuIC0gcyAobnVtYmVyKSBzYXR1cmF0aW9uXG4gLSB2IChudW1iZXIpIHZhbHVlIG9yIGJyaWdodG5lc3NcbiA9IChvYmplY3QpIFJHQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgciAobnVtYmVyKSByZWQsXG4gbyAgICAgZyAobnVtYmVyKSBncmVlbixcbiBvICAgICBiIChudW1iZXIpIGJsdWUsXG4gbyAgICAgaGV4IChzdHJpbmcpIGNvbG9yIGluIEhUTUwvQ1NTIGZvcm1hdDogI+KAouKAouKAouKAouKAouKAolxuIG8gfVxuXFwqL1xuU25hcC5oc2IycmdiID0gZnVuY3Rpb24gKGgsIHMsIHYsIG8pIHtcbiAgICBpZiAoaXMoaCwgXCJvYmplY3RcIikgJiYgXCJoXCIgaW4gaCAmJiBcInNcIiBpbiBoICYmIFwiYlwiIGluIGgpIHtcbiAgICAgICAgdiA9IGguYjtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgbyA9IGgubztcbiAgICAgICAgaCA9IGguaDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gdiAqIHM7XG4gICAgWCA9IEMgKiAoMSAtIGFicyhoICUgMiAtIDEpKTtcbiAgICBSID0gRyA9IEIgPSB2IC0gQztcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5oc2wycmdiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBIU0wgdmFsdWVzIHRvIGFuIFJHQiBvYmplY3RcbiAtIGggKG51bWJlcikgaHVlXG4gLSBzIChudW1iZXIpIHNhdHVyYXRpb25cbiAtIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuID0gKG9iamVjdCkgUkdCIG9iamVjdCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDpcbiBvIHtcbiBvICAgICByIChudW1iZXIpIHJlZCxcbiBvICAgICBnIChudW1iZXIpIGdyZWVuLFxuIG8gICAgIGIgKG51bWJlcikgYmx1ZSxcbiBvICAgICBoZXggKHN0cmluZykgY29sb3IgaW4gSFRNTC9DU1MgZm9ybWF0OiAj4oCi4oCi4oCi4oCi4oCi4oCiXG4gbyB9XG5cXCovXG5TbmFwLmhzbDJyZ2IgPSBmdW5jdGlvbiAoaCwgcywgbCwgbykge1xuICAgIGlmIChpcyhoLCBcIm9iamVjdFwiKSAmJiBcImhcIiBpbiBoICYmIFwic1wiIGluIGggJiYgXCJsXCIgaW4gaCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgIH1cbiAgICBpZiAoaCA+IDEgfHwgcyA+IDEgfHwgbCA+IDEpIHtcbiAgICAgICAgaCAvPSAzNjA7XG4gICAgICAgIHMgLz0gMTAwO1xuICAgICAgICBsIC89IDEwMDtcbiAgICB9XG4gICAgaCAqPSAzNjA7XG4gICAgdmFyIFIsIEcsIEIsIFgsIEM7XG4gICAgaCA9IGggJSAzNjAgLyA2MDtcbiAgICBDID0gMiAqIHMgKiAobCA8IC41ID8gbCA6IDEgLSBsKTtcbiAgICBYID0gQyAqICgxIC0gYWJzKGggJSAyIC0gMSkpO1xuICAgIFIgPSBHID0gQiA9IGwgLSBDIC8gMjtcblxuICAgIGggPSB+fmg7XG4gICAgUiArPSBbQywgWCwgMCwgMCwgWCwgQ11baF07XG4gICAgRyArPSBbWCwgQywgQywgWCwgMCwgMF1baF07XG4gICAgQiArPSBbMCwgMCwgWCwgQywgQywgWF1baF07XG4gICAgcmV0dXJuIHBhY2thZ2VSR0IoUiwgRywgQiwgbyk7XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNiXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTQiBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTQiBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGIgKG51bWJlcikgYnJpZ2h0bmVzc1xuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNiID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBWLCBDO1xuICAgIFYgPSBtbWF4KHIsIGcsIGIpO1xuICAgIEMgPSBWIC0gbW1pbihyLCBnLCBiKTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIFYgPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgViA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgUyA9IEMgPT0gMCA/IDAgOiBDIC8gVjtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGI6IFYsIHRvU3RyaW5nOiBoc2J0b1N0cmluZ307XG59O1xuLypcXFxuICogU25hcC5yZ2IyaHNsXG4gWyBtZXRob2QgXVxuICoqXG4gKiBDb252ZXJ0cyBSR0IgdmFsdWVzIHRvIGFuIEhTTCBvYmplY3RcbiAtIHIgKG51bWJlcikgcmVkXG4gLSBnIChudW1iZXIpIGdyZWVuXG4gLSBiIChudW1iZXIpIGJsdWVcbiA9IChvYmplY3QpIEhTTCBvYmplY3QgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gbyB7XG4gbyAgICAgaCAobnVtYmVyKSBodWUsXG4gbyAgICAgcyAobnVtYmVyKSBzYXR1cmF0aW9uLFxuIG8gICAgIGwgKG51bWJlcikgbHVtaW5vc2l0eVxuIG8gfVxuXFwqL1xuU25hcC5yZ2IyaHNsID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICBiID0gcHJlcGFyZVJHQihyLCBnLCBiKTtcbiAgICByID0gYlswXTtcbiAgICBnID0gYlsxXTtcbiAgICBiID0gYlsyXTtcblxuICAgIHZhciBILCBTLCBMLCBNLCBtLCBDO1xuICAgIE0gPSBtbWF4KHIsIGcsIGIpO1xuICAgIG0gPSBtbWluKHIsIGcsIGIpO1xuICAgIEMgPSBNIC0gbTtcbiAgICBIID0gQyA9PSAwID8gbnVsbCA6XG4gICAgICAgIE0gPT0gciA/IChnIC0gYikgLyBDIDpcbiAgICAgICAgTSA9PSBnID8gKGIgLSByKSAvIEMgKyAyIDpcbiAgICAgICAgICAgICAgICAgKHIgLSBnKSAvIEMgKyA0O1xuICAgIEggPSAoSCArIDM2MCkgJSA2ICogNjAgLyAzNjA7XG4gICAgTCA9IChNICsgbSkgLyAyO1xuICAgIFMgPSBDID09IDAgPyAwIDpcbiAgICAgICAgIEwgPCAuNSA/IEMgLyAoMiAqIEwpIDpcbiAgICAgICAgICAgICAgICAgIEMgLyAoMiAtIDIgKiBMKTtcbiAgICByZXR1cm4ge2g6IEgsIHM6IFMsIGw6IEwsIHRvU3RyaW5nOiBoc2x0b1N0cmluZ307XG59O1xuXG4vLyBUcmFuc2Zvcm1hdGlvbnNcbi8qXFxcbiAqIFNuYXAucGFyc2VQYXRoU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gcGF0aCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgcGF0aCBzZWdtZW50c1xuIC0gcGF0aFN0cmluZyAoc3RyaW5nfGFycmF5KSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBzZWdtZW50cyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuXFwqL1xuU25hcC5wYXJzZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAocGF0aFN0cmluZykge1xuICAgIGlmICghcGF0aFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHB0aCA9IFNuYXAucGF0aChwYXRoU3RyaW5nKTtcbiAgICBpZiAocHRoLmFycikge1xuICAgICAgICByZXR1cm4gU25hcC5wYXRoLmNsb25lKHB0aC5hcnIpO1xuICAgIH1cblxuICAgIHZhciBwYXJhbUNvdW50cyA9IHthOiA3LCBjOiA2LCBvOiAyLCBoOiAxLCBsOiAyLCBtOiAyLCByOiA0LCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB1OiAzLCB6OiAwfSxcbiAgICAgICAgZGF0YSA9IFtdO1xuICAgIGlmIChpcyhwYXRoU3RyaW5nLCBcImFycmF5XCIpICYmIGlzKHBhdGhTdHJpbmdbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICBkYXRhID0gU25hcC5wYXRoLmNsb25lKHBhdGhTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIFN0cihwYXRoU3RyaW5nKS5yZXBsYWNlKHBhdGhDb21tYW5kLCBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBiLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBiICYmIHBhcmFtcy5wdXNoKCtiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJtXCIgJiYgcGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IFwibFwiO1xuICAgICAgICAgICAgICAgIGIgPSBiID09IFwibVwiID8gXCJsXCIgOiBcIkxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwib1wiICYmIHBhcmFtcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYiwgcGFyYW1zWzBdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInJcIikge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCBwYXJhbUNvdW50c1tuYW1lXSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcHRoLmFyciA9IFNuYXAucGF0aC5jbG9uZShkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG4vKlxcXG4gKiBTbmFwLnBhcnNlVHJhbnNmb3JtU3RyaW5nXG4gWyBtZXRob2QgXVxuICoqXG4gKiBVdGlsaXR5IG1ldGhvZFxuICoqXG4gKiBQYXJzZXMgZ2l2ZW4gdHJhbnNmb3JtIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9uc1xuIC0gVFN0cmluZyAoc3RyaW5nfGFycmF5KSB0cmFuc2Zvcm0gc3RyaW5nIG9yIGFycmF5IG9mIHRyYW5zZm9ybWF0aW9ucyAoaW4gdGhlIGxhc3QgY2FzZSBpdCBpcyByZXR1cm5lZCBzdHJhaWdodCBhd2F5KVxuID0gKGFycmF5KSBhcnJheSBvZiB0cmFuc2Zvcm1hdGlvbnNcblxcKi9cbnZhciBwYXJzZVRyYW5zZm9ybVN0cmluZyA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbiAoVFN0cmluZykge1xuICAgIGlmICghVFN0cmluZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcmFtQ291bnRzID0ge3I6IDMsIHM6IDQsIHQ6IDIsIG06IDZ9LFxuICAgICAgICBkYXRhID0gW107XG4gICAgaWYgKGlzKFRTdHJpbmcsIFwiYXJyYXlcIikgJiYgaXMoVFN0cmluZ1swXSwgXCJhcnJheVwiKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgIGRhdGEgPSBTbmFwLnBhdGguY2xvbmUoVFN0cmluZyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgU3RyKFRTdHJpbmcpLnJlcGxhY2UodENvbW1hbmQsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gW10sXG4gICAgICAgICAgICAgICAgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGIgJiYgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEudG9TdHJpbmcgPSBTbmFwLnBhdGgudG9TdHJpbmc7XG4gICAgcmV0dXJuIGRhdGE7XG59O1xuZnVuY3Rpb24gc3ZnVHJhbnNmb3JtMnN0cmluZyh0c3RyKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHRzdHIgPSB0c3RyLnJlcGxhY2UoLyg/Ol58XFxzKShcXHcrKVxcKChbXildKylcXCkvZywgZnVuY3Rpb24gKGFsbCwgbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJyb3RhdGVcIiAmJiBwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2NhbGVcIikge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbXNbMF0sIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwic2tld1hcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCAwLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwic2tld1lcIikge1xuICAgICAgICAgICAgcmVzLnB1c2goW1wibVwiLCAxLCBtYXRoLnRhbihyYWQocGFyYW1zWzBdKSksIDAsIDEsIDAsIDBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtuYW1lLmNoYXJBdCgwKV0uY29uY2F0KHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nID0gc3ZnVHJhbnNmb3JtMnN0cmluZztcblNuYXAuXy5yZ1RyYW5zZm9ybSA9IC9eW2Etel1bXFxzXSotP1xcLj9cXGQvaTtcbmZ1bmN0aW9uIHRyYW5zZm9ybTJtYXRyaXgodHN0ciwgYmJveCkge1xuICAgIHZhciB0ZGF0YSA9IHBhcnNlVHJhbnNmb3JtU3RyaW5nKHRzdHIpLFxuICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4O1xuICAgIGlmICh0ZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0ZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRkYXRhW2ldLFxuICAgICAgICAgICAgICAgIHRsZW4gPSB0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjb21tYW5kID0gU3RyKHRbMF0pLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYWJzb2x1dGUgPSB0WzBdICE9IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgaW52ZXIgPSBhYnNvbHV0ZSA/IG0uaW52ZXJ0KCkgOiAwLFxuICAgICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgICAgIGJiO1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT0gXCJ0XCIgJiYgdGxlbiA9PSAyKXtcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PSBcInRcIiAmJiB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBpbnZlci54KDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGludmVyLnkoMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHgyID0gaW52ZXIueCh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMV0sIHRbMl0pO1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh4MiAtIHgxLCB5MiAtIHkxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSh0WzFdLCB0WzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT0gXCJyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGxlbiA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJiID0gYmIgfHwgYmJveDtcbiAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgYmIueCArIGJiLndpZHRoIC8gMiwgYmIueSArIGJiLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGxlbiA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBpbnZlci54KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBpbnZlci55KHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yb3RhdGUodFsxXSwgeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucm90YXRlKHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwic1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRsZW4gPT0gMiB8fCB0bGVuID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmIgPSBiYiB8fCBiYm94O1xuICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbdGxlbiAtIDFdLCBiYi54ICsgYmIud2lkdGggLyAyLCBiYi55ICsgYmIuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFsyXSwgdFszXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMV0sIHRbMl0sIHRbM10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bGVuID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IGludmVyLngodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGludmVyLnkodFszXSwgdFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNjYWxlKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21tYW5kID09IFwibVwiICYmIHRsZW4gPT0gNykge1xuICAgICAgICAgICAgICAgIG0uYWRkKHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0sIHRbNl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtO1xufVxuU25hcC5fLnRyYW5zZm9ybTJtYXRyaXggPSB0cmFuc2Zvcm0ybWF0cml4O1xuU25hcC5fdW5pdDJweCA9IHVuaXQycHg7XG52YXIgY29udGFpbnMgPSBnbG9iLmRvYy5jb250YWlucyB8fCBnbG9iLmRvYy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuICAgICAgICAgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gYSA9PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PSAxICYmIChcbiAgICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKGJ1cCkgOlxuICAgICAgICAgICAgICAgICAgICBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2XG4gICAgICAgICAgICApKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgd2hpbGUgKGIpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChiID09IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuZnVuY3Rpb24gZ2V0U29tZURlZnMoZWwpIHtcbiAgICB2YXIgcCA9IGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8XG4gICAgICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUgJiYgd3JhcChlbC5ub2RlLnBhcmVudE5vZGUpIHx8XG4gICAgICAgICAgICBTbmFwLnNlbGVjdChcInN2Z1wiKSB8fFxuICAgICAgICAgICAgU25hcCgwLCAwKSxcbiAgICAgICAgcGRlZnMgPSBwLnNlbGVjdChcImRlZnNcIiksXG4gICAgICAgIGRlZnMgID0gcGRlZnMgPT0gbnVsbCA/IGZhbHNlIDogcGRlZnMubm9kZTtcbiAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgZGVmcyA9IG1ha2UoXCJkZWZzXCIsIHAubm9kZSkubm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZnM7XG59XG5mdW5jdGlvbiBnZXRTb21lU1ZHKGVsKSB7XG4gICAgcmV0dXJuIGVsLm5vZGUub3duZXJTVkdFbGVtZW50ICYmIHdyYXAoZWwubm9kZS5vd25lclNWR0VsZW1lbnQpIHx8IFNuYXAuc2VsZWN0KFwic3ZnXCIpO1xufVxuU25hcC5fLmdldFNvbWVEZWZzID0gZ2V0U29tZURlZnM7XG5TbmFwLl8uZ2V0U29tZVNWRyA9IGdldFNvbWVTVkc7XG5mdW5jdGlvbiB1bml0MnB4KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzdmcgPSBnZXRTb21lU1ZHKGVsKS5ub2RlLFxuICAgICAgICBvdXQgPSB7fSxcbiAgICAgICAgbWdyID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoXCIuc3ZnLS0tbWdyXCIpO1xuICAgIGlmICghbWdyKSB7XG4gICAgICAgIG1nciA9ICQoXCJyZWN0XCIpO1xuICAgICAgICAkKG1nciwge3g6IC05ZTksIHk6IC05ZTksIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMCwgXCJjbGFzc1wiOiBcInN2Zy0tLW1nclwiLCBmaWxsOiBcIm5vbmVcIn0pO1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobWdyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Vyh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHt3aWR0aDogdmFsfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbWdyLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09ICt2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgJChtZ3IsIHtoZWlnaHQ6IHZhbH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1nci5nZXRCQm94KCkuaGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQobmFtLCBmKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dFtuYW1dID0gZihlbC5hdHRyKG5hbSkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtID09IG5hbWUpIHtcbiAgICAgICAgICAgIG91dCA9IGYodmFsdWUgPT0gbnVsbCA/IGVsLmF0dHIobmFtKSB8fCAwIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVjdFwiOlxuICAgICAgICAgICAgc2V0KFwicnhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyeVwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgICAgICBzZXQoXCJ3aWR0aFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImhlaWdodFwiLCBnZXRIKTtcbiAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHNldChcInhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJcIiwgZ2V0Vyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxsaXBzZVwiOlxuICAgICAgICAgICAgc2V0KFwiY3hcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJjeVwiLCBnZXRIKTtcbiAgICAgICAgICAgIHNldChcInJ4XCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwicnlcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICAgICAgc2V0KFwieDFcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJ4MlwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcInkxXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwieTJcIiwgZ2V0SCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFya2VyXCI6XG4gICAgICAgICAgICBzZXQoXCJyZWZYXCIsIGdldFcpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VyV2lkdGhcIiwgZ2V0Vyk7XG4gICAgICAgICAgICBzZXQoXCJyZWZZXCIsIGdldEgpO1xuICAgICAgICAgICAgc2V0KFwibWFya2VySGVpZ2h0XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJhZGlhbEdyYWRpZW50XCI6XG4gICAgICAgICAgICBzZXQoXCJmeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImZ5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRzcGFuXCI6XG4gICAgICAgICAgICBzZXQoXCJkeFwiLCBnZXRXKTtcbiAgICAgICAgICAgIHNldChcImR5XCIsIGdldEgpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldChuYW1lLCBnZXRXKTtcbiAgICB9XG4gICAgc3ZnLnJlbW92ZUNoaWxkKG1ncik7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qXFxcbiAqIFNuYXAuc2VsZWN0XG4gWyBtZXRob2QgXVxuICoqXG4gKiBXcmFwcyBhIERPTSBlbGVtZW50IHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgQEVsZW1lbnRcbiAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvciBvZiB0aGUgZWxlbWVudFxuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcblxcKi9cblNuYXAuc2VsZWN0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBTdHIocXVlcnkpLnJlcGxhY2UoLyhbXlxcXFxdKTovZywgXCIkMVxcXFw6XCIpO1xuICAgIHJldHVybiB3cmFwKGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKTtcbn07XG4vKlxcXG4gKiBTbmFwLnNlbGVjdEFsbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogV3JhcHMgRE9NIGVsZW1lbnRzIHNwZWNpZmllZCBieSBDU1Mgc2VsZWN0b3IgYXMgc2V0IG9yIGFycmF5IG9mIEBFbGVtZW50XG4gLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3Igb2YgdGhlIGVsZW1lbnRcbiA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG5cXCovXG5TbmFwLnNlbGVjdEFsbCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgIHZhciBub2RlbGlzdCA9IGdsb2IuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICBzZXQgPSAoU25hcC5zZXQgfHwgQXJyYXkpKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59O1xuXG5mdW5jdGlvbiBhZGQyZ3JvdXAobGlzdCkge1xuICAgIGlmICghaXMobGlzdCwgXCJhcnJheVwiKSkge1xuICAgICAgICBsaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZTtcbiAgICB3aGlsZSAodGhpc1tpXSkgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIGxpc3RbaV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGVsLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2orK10gPSB3cmFwKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG4vLyBIdWIgZ2FyYmFnZSBjb2xsZWN0b3IgZXZlcnkgMTBzXG5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGh1YikgaWYgKGh1YltoYXNdKGtleSkpIHtcbiAgICAgICAgdmFyIGVsID0gaHViW2tleV0sXG4gICAgICAgICAgICBub2RlID0gZWwubm9kZTtcbiAgICAgICAgaWYgKGVsLnR5cGUgIT0gXCJzdmdcIiAmJiAhbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgZWwudHlwZSA9PSBcInN2Z1wiICYmICghbm9kZS5wYXJlbnROb2RlIHx8IFwib3duZXJTVkdFbGVtZW50XCIgaW4gbm9kZS5wYXJlbnROb2RlICYmICFub2RlLm93bmVyU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBodWJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn0sIDFlNCk7XG5mdW5jdGlvbiBFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnNuYXAgaW4gaHViKSB7XG4gICAgICAgIHJldHVybiBodWJbZWwuc25hcF07XG4gICAgfVxuICAgIHZhciBzdmc7XG4gICAgdHJ5IHtcbiAgICAgICAgc3ZnID0gZWwub3duZXJTVkdFbGVtZW50O1xuICAgIH0gY2F0Y2goZSkge31cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5ub2RlXG4gICAgIFsgcHJvcGVydHkgKG9iamVjdCkgXVxuICAgICAqKlxuICAgICAqIEdpdmVzIHlvdSBhIHJlZmVyZW5jZSB0byB0aGUgRE9NIG9iamVjdCwgc28geW91IGNhbiBhc3NpZ24gZXZlbnQgaGFuZGxlcnMgb3IganVzdCBtZXNzIGFyb3VuZC5cbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGRyYXcgYSBjaXJjbGUgYXQgY29vcmRpbmF0ZSAxMCwxMCB3aXRoIHJhZGl1cyBvZiAxMFxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApO1xuICAgICB8IGMubm9kZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICBjLmF0dHIoXCJmaWxsXCIsIFwicmVkXCIpO1xuICAgICB8IH07XG4gICAgXFwqL1xuICAgIHRoaXMubm9kZSA9IGVsO1xuICAgIGlmIChzdmcpIHtcbiAgICAgICAgdGhpcy5wYXBlciA9IG5ldyBQYXBlcihzdmcpO1xuICAgIH1cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50eXBlXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIFNWRyB0YWcgbmFtZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICBcXCovXG4gICAgdGhpcy50eXBlID0gZWwudGFnTmFtZSB8fCBlbC5ub2RlTmFtZTtcbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gSUQodGhpcyk7XG4gICAgdGhpcy5hbmltcyA9IHt9O1xuICAgIHRoaXMuXyA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgIH07XG4gICAgZWwuc25hcCA9IGlkO1xuICAgIGh1YltpZF0gPSB0aGlzO1xuICAgIGlmICh0aGlzLnR5cGUgPT0gXCJnXCIpIHtcbiAgICAgICAgdGhpcy5hZGQgPSBhZGQyZ3JvdXA7XG4gICAgfVxuICAgIGlmICh0aGlzLnR5cGUgaW4ge2c6IDEsIG1hc2s6IDEsIHBhdHRlcm46IDEsIHN5bWJvbDogMX0pIHtcbiAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIFBhcGVyLnByb3RvdHlwZSkgaWYgKFBhcGVyLnByb3RvdHlwZVtoYXNdKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IFBhcGVyLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxufVxuICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXR0clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogR2V0cyBvciBzZXRzIGdpdmVuIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXG4gICAgICoqXG4gICAgIC0gcGFyYW1zIChvYmplY3QpIGNvbnRhaW5zIGtleS12YWx1ZSBwYWlycyBvZiBhdHRyaWJ1dGVzIHlvdSB3YW50IHRvIHNldFxuICAgICAqIG9yXG4gICAgIC0gcGFyYW0gKHN0cmluZykgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChzdHJpbmcpIHZhbHVlIG9mIGF0dHJpYnV0ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IFwiI2ZjMFwiLFxuICAgICB8ICAgICBzdHJva2U6IFwiIzAwMFwiLFxuICAgICB8ICAgICBzdHJva2VXaWR0aDogMiwgLy8gQ2FtZWxDYXNlLi4uXG4gICAgIHwgICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAuNSwgLy8gb3IgZGFzaC1zZXBhcmF0ZWQgbmFtZXNcbiAgICAgfCAgICAgd2lkdGg6IFwiKj0yXCIgLy8gcHJlZml4ZWQgdmFsdWVzXG4gICAgIHwgfSk7XG4gICAgIHwgY29uc29sZS5sb2coZWwuYXR0cihcImZpbGxcIikpOyAvLyAjZmMwXG4gICAgICogUHJlZml4ZWQgdmFsdWVzIGluIGZvcm1hdCBgXCIrPTEwXCJgIHN1cHBvcnRlZC4gQWxsIGZvdXIgb3BlcmF0aW9uc1xuICAgICAqIChgK2AsIGAtYCwgYCpgIGFuZCBgL2ApIGNvdWxkIGJlIHVzZWQuIE9wdGlvbmFsbHkgeW91IGNhbiB1c2UgdW5pdHMgZm9yIGArYFxuICAgICAqIGFuZCBgLWA6IGBcIis9MmVtXCJgLlxuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcyxcbiAgICAgICAgICAgIG5vZGUgPSBlbC5ub2RlO1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5vZGUubm9kZVZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXR0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2F0dHJbaV0ubm9kZU5hbWVdID0gYXR0cltpXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhwYXJhbXMsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGpzb25bcGFyYW1zXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IGpzb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5cIiArIHBhcmFtcywgZWwpLmZpcnN0RGVmaW5lZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGF0dCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXNbaGFzXShhdHQpKSB7XG4gICAgICAgICAgICAgICAgZXZlKFwic25hcC51dGlsLmF0dHIuXCIgKyBhdHQsIGVsLCBwYXJhbXNbYXR0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4vKlxcXG4gKiBTbmFwLnBhcnNlXG4gWyBtZXRob2QgXVxuICoqXG4gKiBQYXJzZXMgU1ZHIGZyYWdtZW50IGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgQEZyYWdtZW50XG4gKipcbiAtIHN2ZyAoc3RyaW5nKSBTVkcgc3RyaW5nXG4gPSAoRnJhZ21lbnQpIHRoZSBARnJhZ21lbnRcblxcKi9cblNuYXAucGFyc2UgPSBmdW5jdGlvbiAoc3ZnKSB7XG4gICAgdmFyIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGZ1bGwgPSB0cnVlLFxuICAgICAgICBkaXYgPSBnbG9iLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN2ZyA9IFN0cihzdmcpO1xuICAgIGlmICghc3ZnLm1hdGNoKC9eXFxzKjxcXHMqc3ZnKD86XFxzfD4pLykpIHtcbiAgICAgICAgc3ZnID0gXCI8c3ZnPlwiICsgc3ZnICsgXCI8L3N2Zz5cIjtcbiAgICAgICAgZnVsbCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXYuaW5uZXJIVE1MID0gc3ZnO1xuICAgIHN2ZyA9IGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAgIGlmIChmdWxsKSB7XG4gICAgICAgICAgICBmID0gc3ZnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChmKTtcbn07XG5mdW5jdGlvbiBGcmFnbWVudChmcmFnKSB7XG4gICAgdGhpcy5ub2RlID0gZnJhZztcbn1cbi8qXFxcbiAqIFNuYXAuZnJhZ21lbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIENyZWF0ZXMgYSBET00gZnJhZ21lbnQgZnJvbSBhIGdpdmVuIGxpc3Qgb2YgZWxlbWVudHMgb3Igc3RyaW5nc1xuICoqXG4gLSB2YXJhcmdzICjigKYpIFNWRyBzdHJpbmdcbiA9IChGcmFnbWVudCkgdGhlIEBGcmFnbWVudFxuXFwqL1xuU25hcC5mcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCksXG4gICAgICAgIGYgPSBnbG9iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0ubm9kZSAmJiBpdGVtLm5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoaXRlbS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZi5hcHBlbmRDaGlsZChTbmFwLnBhcnNlKGl0ZW0pLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoZik7XG59O1xuXG5mdW5jdGlvbiBtYWtlKG5hbWUsIHBhcmVudCkge1xuICAgIHZhciByZXMgPSAkKG5hbWUpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChyZXMpO1xuICAgIHZhciBlbCA9IHdyYXAocmVzKTtcbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBQYXBlcih3LCBoKSB7XG4gICAgdmFyIHJlcyxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcHJvdG8gPSBQYXBlci5wcm90b3R5cGU7XG4gICAgaWYgKHcgJiYgdy50YWdOYW1lICYmIHcudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgaWYgKHcuc25hcCBpbiBodWIpIHtcbiAgICAgICAgICAgIHJldHVybiBodWJbdy5zbmFwXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gdy5vd25lckRvY3VtZW50O1xuICAgICAgICByZXMgPSBuZXcgRWxlbWVudCh3KTtcbiAgICAgICAgZGVzYyA9IHcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkZXNjXCIpWzBdO1xuICAgICAgICBkZWZzID0gdy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRlZnNcIilbMF07XG4gICAgICAgIGlmICghZGVzYykge1xuICAgICAgICAgICAgZGVzYyA9ICQoXCJkZXNjXCIpO1xuICAgICAgICAgICAgZGVzYy5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggU25hcFwiKSk7XG4gICAgICAgICAgICByZXMubm9kZS5hcHBlbmRDaGlsZChkZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZnMpIHtcbiAgICAgICAgICAgIGRlZnMgPSAkKFwiZGVmc1wiKTtcbiAgICAgICAgICAgIHJlcy5ub2RlLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5kZWZzID0gZGVmcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3RvKSBpZiAocHJvdG9baGFzXShrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHByb3RvW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnBhcGVyID0gcmVzLnJvb3QgPSByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gbWFrZShcInN2Z1wiLCBnbG9iLmRvYy5ib2R5KTtcbiAgICAgICAgJChyZXMubm9kZSwge1xuICAgICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgdmVyc2lvbjogMS4xLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICB4bWxuczogeG1sbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB3cmFwKGRvbSkge1xuICAgIGlmICghZG9tKSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGRvbSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGlmIChkb20udGFnTmFtZSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXBlcihkb20pO1xuICAgIH1cbiAgICBpZiAoZG9tLnRhZ05hbWUgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm9iamVjdFwiICYmIGRvbS50eXBlID09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFwZXIoZG9tLmNvbnRlbnREb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN2Z1wiKVswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudChkb20pO1xufVxuXG5TbmFwLl8ubWFrZSA9IG1ha2U7XG5TbmFwLl8ud3JhcCA9IHdyYXA7XG4vKlxcXG4gKiBQYXBlci5lbFxuIFsgbWV0aG9kIF1cbiAqKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IG9uIHBhcGVyIHdpdGggYSBnaXZlbiBuYW1lIGFuZCBubyBhdHRyaWJ1dGVzXG4gKipcbiAtIG5hbWUgKHN0cmluZykgdGFnIG5hbWVcbiAtIGF0dHIgKG9iamVjdCkgYXR0cmlidXRlc1xuID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiA+IFVzYWdlXG4gfCB2YXIgYyA9IHBhcGVyLmNpcmNsZSgxMCwgMTAsIDEwKTsgLy8gaXMgdGhlIHNhbWUgYXMuLi5cbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIikuYXR0cih7XG4gfCAgICAgY3g6IDEwLFxuIHwgICAgIGN5OiAxMCxcbiB8ICAgICByOiAxMFxuIHwgfSk7XG4gfCAvLyBhbmQgdGhlIHNhbWUgYXNcbiB8IHZhciBjID0gcGFwZXIuZWwoXCJjaXJjbGVcIiwge1xuIHwgICAgIGN4OiAxMCxcbiB8ICAgICBjeTogMTAsXG4gfCAgICAgcjogMTBcbiB8IH0pO1xuXFwqL1xuUGFwZXIucHJvdG90eXBlLmVsID0gZnVuY3Rpb24gKG5hbWUsIGF0dHIpIHtcbiAgICB2YXIgZWwgPSBtYWtlKG5hbWUsIHRoaXMubm9kZSk7XG4gICAgYXR0ciAmJiBlbC5hdHRyKGF0dHIpO1xuICAgIHJldHVybiBlbDtcbn07XG4vKlxcXG4gKiBFbGVtZW50LmNoaWxkcmVuXG4gWyBtZXRob2QgXVxuICoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gPSAoYXJyYXkpIGFycmF5IG9mIEVsZW1lbnRzXG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICAgIGNoID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2gubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBTbmFwKGNoW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5mdW5jdGlvbiBqc29uRmlsbGVyKHJvb3QsIG8pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByb290Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcm9vdFtpXS50eXBlLFxuICAgICAgICAgICAgICAgIGF0dHI6IHJvb3RbaV0uYXR0cigpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW4gPSByb290W2ldLmNoaWxkcmVuKCk7XG4gICAgICAgIG8ucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAganNvbkZpbGxlcihjaGlsZHJlbiwgaXRlbS5jaGlsZE5vZGVzID0gW10pO1xuICAgICAgICB9XG4gICAgfVxufVxuLypcXFxuICogRWxlbWVudC50b0pTT05cbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLlxuID0gKG9iamVjdCkgaW4gZm9ybWF0XG4gbyB7XG4gbyAgICAgdHlwZSAoc3RyaW5nKSB0aGlzLnR5cGUsXG4gbyAgICAgYXR0ciAob2JqZWN0KSBhdHRyaWJ1dGVzIG1hcCxcbiBvICAgICBjaGlsZE5vZGVzIChhcnJheSkgb3B0aW9uYWwgYXJyYXkgb2YgY2hpbGRyZW4gaW4gdGhlIHNhbWUgZm9ybWF0XG4gbyB9XG5cXCovXG5FbGVtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGpzb25GaWxsZXIoW3RoaXNdLCBvdXQpO1xuICAgIHJldHVybiBvdXRbMF07XG59O1xuLy8gZGVmYXVsdFxuZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHJcIiwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKTtcbiAgICBhdHQgPSBhdHQuc3Vic3RyaW5nKGF0dC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgICB2YXIgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gICAgaWYgKGNzc0F0dHJbaGFzXShjc3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShjc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMubm9kZSwgYXR0KTtcbiAgICB9XG59KTtcbnZhciBjc3NBdHRyID0ge1xuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiOiAwLFxuICAgIFwiY2xpcFwiOiAwLFxuICAgIFwiY2xpcC1wYXRoXCI6IDAsXG4gICAgXCJjbGlwLXJ1bGVcIjogMCxcbiAgICBcImNvbG9yXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCI6IDAsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIjogMCxcbiAgICBcImNvbG9yLXByb2ZpbGVcIjogMCxcbiAgICBcImNvbG9yLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwiY3Vyc29yXCI6IDAsXG4gICAgXCJkaXJlY3Rpb25cIjogMCxcbiAgICBcImRpc3BsYXlcIjogMCxcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IDAsXG4gICAgXCJlbmFibGUtYmFja2dyb3VuZFwiOiAwLFxuICAgIFwiZmlsbFwiOiAwLFxuICAgIFwiZmlsbC1vcGFjaXR5XCI6IDAsXG4gICAgXCJmaWxsLXJ1bGVcIjogMCxcbiAgICBcImZpbHRlclwiOiAwLFxuICAgIFwiZmxvb2QtY29sb3JcIjogMCxcbiAgICBcImZsb29kLW9wYWNpdHlcIjogMCxcbiAgICBcImZvbnRcIjogMCxcbiAgICBcImZvbnQtZmFtaWx5XCI6IDAsXG4gICAgXCJmb250LXNpemVcIjogMCxcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIjogMCxcbiAgICBcImZvbnQtc3RyZXRjaFwiOiAwLFxuICAgIFwiZm9udC1zdHlsZVwiOiAwLFxuICAgIFwiZm9udC12YXJpYW50XCI6IDAsXG4gICAgXCJmb250LXdlaWdodFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiOiAwLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIjogMCxcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiOiAwLFxuICAgIFwia2VybmluZ1wiOiAwLFxuICAgIFwibGV0dGVyLXNwYWNpbmdcIjogMCxcbiAgICBcImxpZ2h0aW5nLWNvbG9yXCI6IDAsXG4gICAgXCJtYXJrZXJcIjogMCxcbiAgICBcIm1hcmtlci1lbmRcIjogMCxcbiAgICBcIm1hcmtlci1taWRcIjogMCxcbiAgICBcIm1hcmtlci1zdGFydFwiOiAwLFxuICAgIFwibWFza1wiOiAwLFxuICAgIFwib3BhY2l0eVwiOiAwLFxuICAgIFwib3ZlcmZsb3dcIjogMCxcbiAgICBcInBvaW50ZXItZXZlbnRzXCI6IDAsXG4gICAgXCJzaGFwZS1yZW5kZXJpbmdcIjogMCxcbiAgICBcInN0b3AtY29sb3JcIjogMCxcbiAgICBcInN0b3Atb3BhY2l0eVwiOiAwLFxuICAgIFwic3Ryb2tlXCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IDAsXG4gICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiAwLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogMCxcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiAwLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIjogMCxcbiAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogMCxcbiAgICBcInRleHQtYW5jaG9yXCI6IDAsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogMCxcbiAgICBcInRleHQtcmVuZGVyaW5nXCI6IDAsXG4gICAgXCJ1bmljb2RlLWJpZGlcIjogMCxcbiAgICBcInZpc2liaWxpdHlcIjogMCxcbiAgICBcIndvcmQtc3BhY2luZ1wiOiAwLFxuICAgIFwid3JpdGluZy1tb2RlXCI6IDBcbn07XG5cbmV2ZS5vbihcInNuYXAudXRpbC5hdHRyXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBhdHQgPSBldmUubnQoKSxcbiAgICAgICAgYXR0ciA9IHt9O1xuICAgIGF0dCA9IGF0dC5zdWJzdHJpbmcoYXR0Lmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICAgIGF0dHJbYXR0XSA9IHZhbHVlO1xuICAgIHZhciBzdHlsZSA9IGF0dC5yZXBsYWNlKC8tKFxcdykvZ2ksIGZ1bmN0aW9uIChhbGwsIGxldHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KSxcbiAgICAgICAgY3NzID0gYXR0LnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uIChsZXR0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICBpZiAoY3NzQXR0cltoYXNdKGNzcykpIHtcbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3N0eWxlXSA9IHZhbHVlID09IG51bGwgPyBFIDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgJCh0aGlzLm5vZGUsIGF0dHIpO1xuICAgIH1cbn0pO1xuKGZ1bmN0aW9uIChwcm90bykge30oUGFwZXIucHJvdG90eXBlKSk7XG5cbi8vIHNpbXBsZSBhamF4XG4vKlxcXG4gKiBTbmFwLmFqYXhcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBBamF4XG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIHBvc3REYXRhIChvYmplY3R8c3RyaW5nKSBkYXRhIGZvciBwb3N0IHJlcXVlc3RcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuICogb3JcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuID0gKFhNTEh0dHBSZXF1ZXN0KSB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LCBqdXN0IGluIGNhc2VcblxcKi9cblNuYXAuYWpheCA9IGZ1bmN0aW9uICh1cmwsIHBvc3REYXRhLCBjYWxsYmFjaywgc2NvcGUpe1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QsXG4gICAgICAgIGlkID0gSUQoKTtcbiAgICBpZiAocmVxKSB7XG4gICAgICAgIGlmIChpcyhwb3N0RGF0YSwgXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgc2NvcGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcG9zdERhdGE7XG4gICAgICAgICAgICBwb3N0RGF0YSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMocG9zdERhdGEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgcGQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwb3N0RGF0YSkgaWYgKHBvc3REYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwZC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocG9zdERhdGFba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdERhdGEgPSBwZC5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3Blbihwb3N0RGF0YSA/IFwiUE9TVFwiIDogXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKHBvc3REYXRhKSB7XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjBcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFqYXguXCIgKyBpZCArIFwiLjIwMFwiLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBldmUub25jZShcInNuYXAuYWpheC5cIiArIGlkICsgXCIuMzA0XCIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlKFwic25hcC5hamF4LlwiICsgaWQgKyBcIi5cIiArIHJlcS5zdGF0dXMsIHNjb3BlLCByZXEpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZChwb3N0RGF0YSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxufTtcbi8qXFxcbiAqIFNuYXAubG9hZFxuIFsgbWV0aG9kIF1cbiAqKlxuICogTG9hZHMgZXh0ZXJuYWwgU1ZHIGZpbGUgYXMgYSBARnJhZ21lbnQgKHNlZSBAU25hcC5hamF4IGZvciBtb3JlIGFkdmFuY2VkIEFKQVgpXG4gKipcbiAtIHVybCAoc3RyaW5nKSBVUkxcbiAtIGNhbGxiYWNrIChmdW5jdGlvbikgY2FsbGJhY2tcbiAtIHNjb3BlIChvYmplY3QpICNvcHRpb25hbCBzY29wZSBvZiBjYWxsYmFja1xuXFwqL1xuU25hcC5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgU25hcC5hamF4KHVybCwgZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgZiA9IFNuYXAucGFyc2UocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNjb3BlID8gY2FsbGJhY2suY2FsbChzY29wZSwgZikgOiBjYWxsYmFjayhmKTtcbiAgICB9KTtcbn07XG52YXIgZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgYm94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBjbGllbnRUb3AgPSBkb2NFbGVtLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwLCBjbGllbnRMZWZ0ID0gZG9jRWxlbS5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwLFxuICAgICAgICB0b3AgID0gYm94LnRvcCAgKyAoZy53aW4ucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3AgKSAtIGNsaWVudFRvcCxcbiAgICAgICAgbGVmdCA9IGJveC5sZWZ0ICsgKGcud2luLnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQpIC0gY2xpZW50TGVmdDtcbiAgICByZXR1cm4ge1xuICAgICAgICB5OiB0b3AsXG4gICAgICAgIHg6IGxlZnRcbiAgICB9O1xufTtcbi8qXFxcbiAqIFNuYXAuZ2V0RWxlbWVudEJ5UG9pbnRcbiBbIG1ldGhvZCBdXG4gKipcbiAqIFJldHVybnMgeW91IHRvcG1vc3QgZWxlbWVudCB1bmRlciBnaXZlbiBwb2ludC5cbiAqKlxuID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdFxuIC0geCAobnVtYmVyKSB4IGNvb3JkaW5hdGUgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB3aW5kb3dcbiAtIHkgKG51bWJlcikgeSBjb29yZGluYXRlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgd2luZG93XG4gPiBVc2FnZVxuIHwgU25hcC5nZXRFbGVtZW50QnlQb2ludChtb3VzZVgsIG1vdXNlWSkuYXR0cih7c3Ryb2tlOiBcIiNmMDBcIn0pO1xuXFwqL1xuU25hcC5nZXRFbGVtZW50QnlQb2ludCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHBhcGVyID0gdGhpcyxcbiAgICAgICAgc3ZnID0gcGFwZXIuY2FudmFzLFxuICAgICAgICB0YXJnZXQgPSBnbG9iLmRvYy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChnbG9iLndpbi5vcGVyYSAmJiB0YXJnZXQudGFnTmFtZSA9PSBcInN2Z1wiKSB7XG4gICAgICAgIHZhciBzbyA9IGdldE9mZnNldCh0YXJnZXQpLFxuICAgICAgICAgICAgc3IgPSB0YXJnZXQuY3JlYXRlU1ZHUmVjdCgpO1xuICAgICAgICBzci54ID0geCAtIHNvLng7XG4gICAgICAgIHNyLnkgPSB5IC0gc28ueTtcbiAgICAgICAgc3Iud2lkdGggPSBzci5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgaGl0cyA9IHRhcmdldC5nZXRJbnRlcnNlY3Rpb25MaXN0KHNyLCBudWxsKTtcbiAgICAgICAgaWYgKGhpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBoaXRzW2hpdHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHRhcmdldCk7XG59O1xuLypcXFxuICogU25hcC5wbHVnaW5cbiBbIG1ldGhvZCBdXG4gKipcbiAqIExldCB5b3Ugd3JpdGUgcGx1Z2lucy4gWW91IHBhc3MgaW4gYSBmdW5jdGlvbiB3aXRoIGZpdmUgYXJndW1lbnRzLCBsaWtlIHRoaXM6XG4gfCBTbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2JhbCwgRnJhZ21lbnQpIHtcbiB8ICAgICBTbmFwLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIEVsZW1lbnQucHJvdG90eXBlLm5ld21ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xuIHwgICAgIFBhcGVyLnByb3RvdHlwZS5uZXdtZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcbiB8IH0pO1xuICogSW5zaWRlIHRoZSBmdW5jdGlvbiB5b3UgaGF2ZSBhY2Nlc3MgdG8gYWxsIG1haW4gb2JqZWN0cyAoYW5kIHRoZWlyXG4gKiBwcm90b3R5cGVzKS4gVGhpcyBhbGxvdyB5b3UgdG8gZXh0ZW5kIGFueXRoaW5nIHlvdSB3YW50LlxuICoqXG4gLSBmIChmdW5jdGlvbikgeW91ciBwbHVnaW4gYm9keVxuXFwqL1xuU25hcC5wbHVnaW4gPSBmdW5jdGlvbiAoZikge1xuICAgIGYoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KTtcbn07XG5nbG9iLndpbi5TbmFwID0gU25hcDtcbnJldHVybiBTbmFwO1xufSh3aW5kb3cgfHwgdGhpcykpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIHVuaXQycHggPSBTbmFwLl91bml0MnB4LFxuICAgICAgICAkID0gU25hcC5fLiQsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgZ2V0U29tZURlZnMgPSBTbmFwLl8uZ2V0U29tZURlZnMsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIixcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yIGZvciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveCBkZXNjcmlwdG9yOlxuICAgICBvIHtcbiAgICAgbyAgICAgY3g6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgY3k6IChudW1iZXIpIHggb2YgdGhlIGNlbnRlcixcbiAgICAgbyAgICAgaDogKG51bWJlcikgaGVpZ2h0LFxuICAgICBvICAgICBoZWlnaHQ6IChudW1iZXIpIGhlaWdodCxcbiAgICAgbyAgICAgcGF0aDogKHN0cmluZykgcGF0aCBjb21tYW5kIGZvciB0aGUgYm94LFxuICAgICBvICAgICByMDogKG51bWJlcikgcmFkaXVzIG9mIGEgY2lyY2xlIHRoYXQgZnVsbHkgZW5jbG9zZXMgdGhlIGJveCxcbiAgICAgbyAgICAgcjE6IChudW1iZXIpIHJhZGl1cyBvZiB0aGUgc21hbGxlc3QgY2lyY2xlIHRoYXQgY2FuIGJlIGVuY2xvc2VkLFxuICAgICBvICAgICByMjogKG51bWJlcikgcmFkaXVzIG9mIHRoZSBsYXJnZXN0IGNpcmNsZSB0aGF0IGNhbiBiZSBlbmNsb3NlZCxcbiAgICAgbyAgICAgdmI6IChzdHJpbmcpIGJveCBhcyBhIHZpZXdib3ggY29tbWFuZCxcbiAgICAgbyAgICAgdzogKG51bWJlcikgd2lkdGgsXG4gICAgIG8gICAgIHdpZHRoOiAobnVtYmVyKSB3aWR0aCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggb2YgdGhlIHJpZ2h0IHNpZGUsXG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggb2YgdGhlIGxlZnQgc2lkZSxcbiAgICAgbyAgICAgeTI6IChudW1iZXIpIHkgb2YgdGhlIGJvdHRvbSBlZGdlLFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IG9mIHRoZSB0b3AgZWRnZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKGlzV2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3godGhpcy5ub2RlLmdldENsaWVudFJlY3RzKCkuaXRlbSgwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFTbmFwLk1hdHJpeCB8fCAhU25hcC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgbSA9IG5ldyBTbmFwLk1hdHJpeDtcbiAgICAgICAgaWYgKGVsLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVsLnR5cGUgPT0gXCJ1c2VcIikge1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtID0gbS5hZGQoZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXgudHJhbnNsYXRlKGVsLmF0dHIoXCJ4XCIpIHx8IDAsIGVsLmF0dHIoXCJ5XCIpIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5vcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIGVsID0gZWwub3JpZ2luYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gZWwuYXR0cihcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5vcmlnaW5hbCA9IGVsLm5vZGUub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChocmVmLnN1YnN0cmluZyhocmVmLmluZGV4T2YoXCIjXCIpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfID0gZWwuXyxcbiAgICAgICAgICAgIHBhdGhmaW5kZXIgPSBTbmFwLnBhdGguZ2V0W2VsLnR5cGVdIHx8IFNuYXAucGF0aC5nZXQuZGVmbHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNXaXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgXy5iYm94d3QgPSBwYXRoZmluZGVyID8gU25hcC5wYXRoLmdldEJCb3goZWwucmVhbFBhdGggPSBwYXRoZmluZGVyKGVsKSkgOiBTbmFwLl8uYm94KGVsLm5vZGUuZ2V0QkJveCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChfLmJib3h3dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlYWxQYXRoID0gcGF0aGZpbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgZWwubWF0cml4ID0gZWwudHJhbnNmb3JtKCkubG9jYWxNYXRyaXg7XG4gICAgICAgICAgICAgICAgXy5iYm94ID0gU25hcC5wYXRoLmdldEJCb3goU25hcC5wYXRoLm1hcChlbC5yZWFsUGF0aCwgbS5hZGQoZWwubWF0cml4KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KF8uYmJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc27igJl0IGdpdmUgeW91IGJib3ggb2YgaGlkZGVuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBTbmFwLl8uYm94KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9wU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBleHRyYWN0VHJhbnNmb3JtKGVsLCB0c3RyKSB7XG4gICAgICAgIGlmICh0c3RyID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkb1JldHVybiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcImxpbmVhckdyYWRpZW50XCIgfHwgZWwudHlwZSA9PSBcInJhZGlhbEdyYWRpZW50XCIpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gZWwubm9kZS5nZXRBdHRyaWJ1dGUoXCJncmFkaWVudFRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PSBcInBhdHRlcm5cIikge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInBhdHRlcm5UcmFuc2Zvcm1cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRzdHIgPSBlbC5ub2RlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0c3RyID0gU25hcC5fLnN2Z1RyYW5zZm9ybTJzdHJpbmcodHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVNuYXAuXy5yZ1RyYW5zZm9ybS50ZXN0KHRzdHIpKSB7XG4gICAgICAgICAgICAgICAgdHN0ciA9IFNuYXAuXy5zdmdUcmFuc2Zvcm0yc3RyaW5nKHRzdHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU3RyKHRzdHIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGVsLl8udHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzKHRzdHIsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgICAgICB0c3RyID0gU25hcC5wYXRoID8gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodHN0cikgOiBTdHIodHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fLnRyYW5zZm9ybSA9IHRzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG0gPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeCh0c3RyLCBlbC5nZXRCQm94KDEpKTtcbiAgICAgICAgaWYgKGRvUmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLm1hdHJpeCA9IG07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudHJhbnNmb3JtXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgKipcbiAgICAgLSB0c3RyIChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmcgaW4gU25hcCBvciBTVkcgZm9ybWF0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKiBvclxuICAgICA9IChvYmplY3QpIHRyYW5zZm9ybWF0aW9uIGRlc2NyaXB0b3I6XG4gICAgIG8ge1xuICAgICBvICAgICBzdHJpbmcgKHN0cmluZykgdHJhbnNmb3JtIHN0cmluZyxcbiAgICAgbyAgICAgZ2xvYmFsTWF0cml4IChNYXRyaXgpIG1hdHJpeCBvZiBhbGwgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgdG8gZWxlbWVudCBvciBpdHMgcGFyZW50cyxcbiAgICAgbyAgICAgbG9jYWxNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIG9ubHkgdG8gdGhlIGVsZW1lbnQsXG4gICAgIG8gICAgIGRpZmZNYXRyaXggKE1hdHJpeCkgbWF0cml4IG9mIGRpZmZlcmVuY2UgYmV0d2VlbiBnbG9iYWwgYW5kIGxvY2FsIHRyYW5zZm9ybWF0aW9ucyxcbiAgICAgbyAgICAgZ2xvYmFsIChzdHJpbmcpIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBhcyBzdHJpbmcsXG4gICAgIG8gICAgIGxvY2FsIChzdHJpbmcpIGxvY2FsIHRyYW5zZm9ybWF0aW9uIGFzIHN0cmluZyxcbiAgICAgbyAgICAgdG9TdHJpbmcgKGZ1bmN0aW9uKSByZXR1cm5zIGBzdHJpbmdgIHByb3BlcnR5XG4gICAgIG8gfVxuICAgIFxcKi9cbiAgICBlbHByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0c3RyKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fO1xuICAgICAgICBpZiAodHN0ciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFwYSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gbmV3IFNuYXAuTWF0cml4KHRoaXMubm9kZS5nZXRDVE0oKSksXG4gICAgICAgICAgICAgICAgbG9jYWwgPSBleHRyYWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgICAgICAgIG1zID0gW2xvY2FsXSxcbiAgICAgICAgICAgICAgICBtID0gbmV3IFNuYXAuTWF0cml4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgbG9jYWxTdHJpbmcgPSBsb2NhbC50b1RyYW5zZm9ybVN0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IFN0cihsb2NhbCkgPT0gU3RyKHRoaXMubWF0cml4KSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyKF8udHJhbnNmb3JtKSA6IGxvY2FsU3RyaW5nO1xuICAgICAgICAgICAgd2hpbGUgKHBhcGEudHlwZSAhPSBcInN2Z1wiICYmIChwYXBhID0gcGFwYS5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBtcy5wdXNoKGV4dHJhY3RUcmFuc2Zvcm0ocGFwYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IG1zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZChtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICAgICAgICAgIGdsb2JhbE1hdHJpeDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgIHRvdGFsTWF0cml4OiBtLFxuICAgICAgICAgICAgICAgIGxvY2FsTWF0cml4OiBsb2NhbCxcbiAgICAgICAgICAgICAgICBkaWZmTWF0cml4OiBnbG9iYWwuY2xvbmUoKS5hZGQobG9jYWwuaW52ZXJ0KCkpLFxuICAgICAgICAgICAgICAgIGdsb2JhbDogZ2xvYmFsLnRvVHJhbnNmb3JtU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdG90YWw6IG0udG9UcmFuc2Zvcm1TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxTdHJpbmcsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IHByb3BTdHJpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRzdHIgaW5zdGFuY2VvZiBTbmFwLk1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0c3RyO1xuICAgICAgICAgICAgdGhpcy5fLnRyYW5zZm9ybSA9IHRzdHIudG9UcmFuc2Zvcm1TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3RUcmFuc2Zvcm0odGhpcywgdHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtncmFkaWVudFRyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09IFwicGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLm1hdHJpeH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMubm9kZSwge3RyYW5zZm9ybTogdGhpcy5tYXRyaXh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQucGFyZW50XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50J3MgcGFyZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdyYXAodGhpcy5ub2RlLnBhcmVudE5vZGUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYXBwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBlbGVtZW50IHRvIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnR8U2V0KSBlbGVtZW50IHRvIGFwcGVuZFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWRkXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuYXBwZW5kXG4gICAgXFwqL1xuICAgIGVscHJvdG8uYXBwZW5kID0gZWxwcm90by5hZGQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBlbC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5hZGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFwcGVuZFRvXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIGNoaWxkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5hcHBlbmRUbyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gZWxlbWVudCB0byB0aGUgY3VycmVudCBvbmVcbiAgICAgKipcbiAgICAgLSBlbCAoRWxlbWVudCkgZWxlbWVudCB0byBwcmVwZW5kXG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3Q7XG4gICAgICAgICAgICAgICAgZWwuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdC5hZnRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5wcmVwZW5kKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgdGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5hZGQgJiYgdGhpcy5hZGQoKTtcbiAgICAgICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5wcmVwZW5kVG9cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFByZXBlbmRzIHRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBwYXJlbnQgZWxlbWVudCB0byBwcmVwZW5kIHRvXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjaGlsZCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucHJlcGVuZFRvID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIGVsLnByZXBlbmQodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYmVmb3JlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSBjdXJyZW50IG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IHRvIGluc2VydFxuICAgICA9IChFbGVtZW50KSB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5iZWZvcmUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKGVsLnR5cGUgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIGl0ID0gdGhpcztcbiAgICAgICAgICAgIGVsLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGl0Lm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwubm9kZSwgaXQubm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMucGFyZW50KCkgJiYgdGhpcy5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJbnNlcnRzIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lXG4gICAgICoqXG4gICAgIC0gZWwgKEVsZW1lbnQpIGVsZW1lbnQgdG8gaW5zZXJ0XG4gICAgID0gKEVsZW1lbnQpIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFmdGVyID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLm5vZGUsIHRoaXMubm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbC5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCgpICYmIHRoaXMucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYWRkKCk7XG4gICAgICAgIGVsLnBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5pbnNlcnRCZWZvcmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsID0gd3JhcChlbCk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICBlbC5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSwgZWwubm9kZSk7XG4gICAgICAgIHRoaXMucGFwZXIgPSBlbC5wYXBlcjtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgZWwucGFyZW50KCkgJiYgZWwucGFyZW50KCkuYWRkKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5zZXJ0QWZ0ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEluc2VydHMgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIGdpdmVuIG9uZVxuICAgICAqKlxuICAgICAtIGVsIChFbGVtZW50KSBlbGVtZW50IG5leHQgdG8gd2hvbSBpbnNlcnQgdG9cbiAgICAgPSAoRWxlbWVudCkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwgPSB3cmFwKGVsKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIGVsLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCBlbC5ub2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5wYXBlciA9IGVsLnBhcGVyO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFkZCgpO1xuICAgICAgICBlbC5wYXJlbnQoKSAmJiBlbC5wYXJlbnQoKS5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgPSAoRWxlbWVudCkgdGhlIGRldGFjaGVkIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZSAmJiB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICBkZWxldGUgdGhpcy5wYXBlcjtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hZGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5zZWxlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEdhdGhlcnMgdGhlIG5lc3RlZCBARWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2V0IG9mIENTUyBzZWxlY3RvcnNcbiAgICAgKipcbiAgICAgLSBxdWVyeSAoc3RyaW5nKSBDU1Mgc2VsZWN0b3JcbiAgICAgPSAoRWxlbWVudCkgcmVzdWx0IG9mIHF1ZXJ5IHNlbGVjdGlvblxuICAgIFxcKi9cbiAgICBlbHByb3RvLnNlbGVjdCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihxdWVyeSkpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBHYXRoZXJzIG5lc3RlZCBARWxlbWVudCBvYmplY3RzIG1hdGNoaW5nIHRoZSBnaXZlbiBzZXQgb2YgQ1NTIHNlbGVjdG9yc1xuICAgICAqKlxuICAgICAtIHF1ZXJ5IChzdHJpbmcpIENTUyBzZWxlY3RvclxuICAgICA9IChTZXR8YXJyYXkpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5zZWxlY3RBbGwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIG5vZGVsaXN0ID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLFxuICAgICAgICAgICAgc2V0ID0gKFNuYXAuc2V0IHx8IEFycmF5KSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXQucHVzaCh3cmFwKG5vZGVsaXN0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmFzUFhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBlbGVtZW50IGFzIGEgYHB4YCB2YWx1ZSAobm90ICUsIGVtLCBldGMuKVxuICAgICAqKlxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSAjb3B0aW9uYWwgYXR0cmlidXRlIHZhbHVlXG4gICAgID0gKEVsZW1lbnQpIHJlc3VsdCBvZiBxdWVyeSBzZWxlY3Rpb25cbiAgICBcXCovXG4gICAgZWxwcm90by5hc1BYID0gZnVuY3Rpb24gKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cihhdHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gK3VuaXQycHgodGhpcywgYXR0ciwgdmFsdWUpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQudXNlKCk6IEkgc3VnZ2VzdCBhZGRpbmcgYSBub3RlIGFib3V0IGhvdyB0byBhY2Nlc3MgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhlIHJldHVybmVkIDx1c2U+IGluc3RhbnRpYXRlcy4gSXQncyBhIHBhcnQgb2YgU1ZHIHdpdGggd2hpY2ggb3JkaW5hcnkgd2ViIGRldmVsb3BlcnMgbWF5IGJlIGxlYXN0IGZhbWlsaWFyLlxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIGA8dXNlPmAgZWxlbWVudCBsaW5rZWQgdG8gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgYDx1c2U+YCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdXNlLFxuICAgICAgICAgICAgaWQgPSB0aGlzLm5vZGUuaWQ7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICQodGhpcy5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIiB8fCB0aGlzLnR5cGUgPT0gXCJyYWRpYWxHcmFkaWVudFwiIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgIHVzZSA9IG1ha2UodGhpcy50eXBlLCB0aGlzLm5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1c2UgPSBtYWtlKFwidXNlXCIsIHRoaXMubm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAkKHVzZS5ub2RlLCB7XG4gICAgICAgICAgICBcInhsaW5rOmhyZWZcIjogXCIjXCIgKyBpZFxuICAgICAgICB9KTtcbiAgICAgICAgdXNlLm9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHVzZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpeGlkcyhlbCkge1xuICAgICAgICB2YXIgZWxzID0gZWwuc2VsZWN0QWxsKFwiKlwiKSxcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgdXJsID0gL15cXHMqdXJsXFwoKFwifCd8KSguKilcXDFcXClcXHMqJC8sXG4gICAgICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgICAgIHVzZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gdXJsdGVzdChpdCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICQoaXQubm9kZSwgbmFtZSk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsLm1hdGNoKHVybCk7XG4gICAgICAgICAgICB2YWwgPSB2YWwgJiYgdmFsWzJdO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuY2hhckF0KCkgPT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdXNlc1t2YWxdID0gKHVzZXNbdmFsXSB8fCBbXSkuY29uY2F0KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gU25hcC51cmwoaWQpO1xuICAgICAgICAgICAgICAgICAgICAkKGl0Lm5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmt0ZXN0KGl0KSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gJChpdC5ub2RlLCBcInhsaW5rOmhyZWZcIik7XG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbC5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB1c2VzW3ZhbF0gPSAodXNlc1t2YWxdIHx8IFtdKS5jb25jYXQoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LmF0dHIoXCJ4bGluazpocmVmXCIsIFwiI1wiICsgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVscy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpdCA9IGVsc1tpXTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwiZmlsbFwiKTtcbiAgICAgICAgICAgIHVybHRlc3QoaXQsIFwic3Ryb2tlXCIpO1xuICAgICAgICAgICAgdXJsdGVzdChpdCwgXCJmaWx0ZXJcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcIm1hc2tcIik7XG4gICAgICAgICAgICB1cmx0ZXN0KGl0LCBcImNsaXAtcGF0aFwiKTtcbiAgICAgICAgICAgIGxpbmt0ZXN0KGl0KTtcbiAgICAgICAgICAgIHZhciBvbGRpZCA9ICQoaXQubm9kZSwgXCJpZFwiKTtcbiAgICAgICAgICAgIGlmIChvbGRpZCkge1xuICAgICAgICAgICAgICAgICQoaXQubm9kZSwge2lkOiBpdC5pZH0pO1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBvbGRpZCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0LmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZzID0gdXNlc1tpZHNbaV0ub2xkXTtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGZzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZnNbal0oaWRzW2ldLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xvbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgZWxlbWVudCBhbmQgaW5zZXJ0cyBpdCBhZnRlciB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICA9IChFbGVtZW50KSB0aGUgY2xvbmVcbiAgICBcXCovXG4gICAgZWxwcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcCh0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgaWYgKCQoY2xvbmUubm9kZSwgXCJpZFwiKSkge1xuICAgICAgICAgICAgJChjbG9uZS5ub2RlLCB7aWQ6IGNsb25lLmlkfSk7XG4gICAgICAgIH1cbiAgICAgICAgZml4aWRzKGNsb25lKTtcbiAgICAgICAgY2xvbmUuaW5zZXJ0QWZ0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvRGVmc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogTW92ZXMgZWxlbWVudCB0byB0aGUgc2hhcmVkIGA8ZGVmcz5gIGFyZWFcbiAgICAgKipcbiAgICAgPSAoRWxlbWVudCkgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by50b0RlZnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWZzID0gZ2V0U29tZURlZnModGhpcyk7XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC50b1BhdHRlcm5cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPHBhdHRlcm4+YCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAqKlxuICAgICAqIFRvIGNyZWF0ZSBhIHBhdHRlcm4geW91IGhhdmUgdG8gc3BlY2lmeSB0aGUgcGF0dGVybiByZWN0OlxuICAgICAtIHggKHN0cmluZ3xudW1iZXIpXG4gICAgIC0geSAoc3RyaW5nfG51bWJlcilcbiAgICAgLSB3aWR0aCAoc3RyaW5nfG51bWJlcilcbiAgICAgLSBoZWlnaHQgKHN0cmluZ3xudW1iZXIpXG4gICAgID0gKEVsZW1lbnQpIHRoZSBgPHBhdHRlcm4+YCBlbGVtZW50XG4gICAgICogWW91IGNhbiB1c2UgcGF0dGVybiBsYXRlciBvbiBhcyBhbiBhcmd1bWVudCBmb3IgYGZpbGxgIGF0dHJpYnV0ZTpcbiAgICAgfCB2YXIgcCA9IHBhcGVyLnBhdGgoXCJNMTAtNS0xMCwxNU0xNSwwLDAsMTVNMC01LTIwLDE1XCIpLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgIHwgICAgICAgICBzdHJva2U6IFwiI2JhZGE1NVwiLFxuICAgICB8ICAgICAgICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgfCAgICAgfSkucGF0dGVybigwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDIwMCwgMjAwLCAxMDApO1xuICAgICB8IGMuYXR0cih7XG4gICAgIHwgICAgIGZpbGw6IHBcbiAgICAgfCB9KTtcbiAgICBcXCovXG4gICAgZWxwcm90by5wYXR0ZXJuID0gZWxwcm90by50b1BhdHRlcm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgcCA9IG1ha2UoXCJwYXR0ZXJuXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiBcInhcIiBpbiB4KSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgd2lkdGggPSB4LndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG4gICAgICAgICQocC5ub2RlLCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsXG4gICAgICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgICAgIHZpZXdCb3g6IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XS5qb2luKFwiIFwiKVxuICAgICAgICB9KTtcbiAgICAgICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG4vLyBTSUVSUkEgRWxlbWVudC5tYXJrZXIoKTogY2xhcmlmeSB3aGF0IGEgcmVmZXJlbmNlIHBvaW50IGlzLiBFLmcuLCBoZWxwcyB5b3Ugb2Zmc2V0IHRoZSBvYmplY3QgZnJvbSBpdHMgZWRnZSBzdWNoIGFzIHdoZW4gY2VudGVyaW5nIGl0IG92ZXIgYSBwYXRoLlxuLy8gU0lFUlJBIEVsZW1lbnQubWFya2VyKCk6IEkgc3VnZ2VzdCB0aGUgbWV0aG9kIHNob3VsZCBhY2NlcHQgZGVmYXVsdCByZWZlcmVuY2UgcG9pbnQgdmFsdWVzLiAgUGVyaGFwcyBjZW50ZXJlZCB3aXRoIChyZWZYID0gd2lkdGgvMikgYW5kIChyZWZZID0gaGVpZ2h0LzIpPyBBbHNvLCBjb3VsZG4ndCBpdCBhc3N1bWUgdGhlIGVsZW1lbnQncyBjdXJyZW50IF93aWR0aF8gYW5kIF9oZWlnaHRfPyBBbmQgcGxlYXNlIHNwZWNpZnkgd2hhdCBfeF8gYW5kIF95XyBtZWFuOiBvZmZzZXRzPyBJZiBzbywgZnJvbSB3aGVyZT8gIENvdWxkbid0IHRoZXkgYWxzbyBiZSBhc3NpZ25lZCBkZWZhdWx0IHZhbHVlcz9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tYXJrZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSBgPG1hcmtlcj5gIGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgICogVG8gY3JlYXRlIGEgbWFya2VyIHlvdSBoYXZlIHRvIHNwZWNpZnkgdGhlIGJvdW5kaW5nIHJlY3QgYW5kIHJlZmVyZW5jZSBwb2ludDpcbiAgICAgLSB4IChudW1iZXIpXG4gICAgIC0geSAobnVtYmVyKVxuICAgICAtIHdpZHRoIChudW1iZXIpXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpXG4gICAgIC0gcmVmWCAobnVtYmVyKVxuICAgICAtIHJlZlkgKG51bWJlcilcbiAgICAgPSAoRWxlbWVudCkgdGhlIGA8bWFya2VyPmAgZWxlbWVudFxuICAgICAqIFlvdSBjYW4gc3BlY2lmeSB0aGUgbWFya2VyIGxhdGVyIGFzIGFuIGFyZ3VtZW50IGZvciBgbWFya2VyLXN0YXJ0YCwgYG1hcmtlci1lbmRgLCBgbWFya2VyLW1pZGAsIGFuZCBgbWFya2VyYCBhdHRyaWJ1dGVzLiBUaGUgYG1hcmtlcmAgYXR0cmlidXRlIHBsYWNlcyB0aGUgbWFya2VyIGF0IGV2ZXJ5IHBvaW50IGFsb25nIHRoZSBwYXRoLCBhbmQgYG1hcmtlci1taWRgIHBsYWNlcyB0aGVtIGF0IGV2ZXJ5IHBvaW50IGV4Y2VwdCB0aGUgc3RhcnQgYW5kIGVuZC5cbiAgICBcXCovXG4gICAgLy8gVE9ETyBhZGQgdXNhZ2UgZm9yIG1hcmtlcnNcbiAgICBlbHByb3RvLm1hcmtlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZWZYLCByZWZZKSB7XG4gICAgICAgIHZhciBwID0gbWFrZShcIm1hcmtlclwiLCBnZXRTb21lRGVmcyh0aGlzKSk7XG4gICAgICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmdldEJCb3goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoeCwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4geCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgcmVmWCA9IHgucmVmWCB8fCB4LmN4O1xuICAgICAgICAgICAgcmVmWSA9IHgucmVmWSB8fCB4LmN5O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICAkKHAubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgbWFya2VyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgbWFya2VySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBvcmllbnQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgcmVmWDogcmVmWCB8fCAwLFxuICAgICAgICAgICAgcmVmWTogcmVmWSB8fCAwLFxuICAgICAgICAgICAgaWQ6IHAuaWRcbiAgICAgICAgfSk7XG4gICAgICAgIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIHZhciBlbGRhdGEgPSB7fTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIG9yIHJldHJpZXZlcyBnaXZlbiB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggZ2l2ZW4ga2V5LiAoRG9u4oCZdCBjb25mdXNlXG4gICAgICogd2l0aCBgZGF0YS1gIGF0dHJpYnV0ZXMpXG4gICAgICpcbiAgICAgKiBTZWUgYWxzbyBARWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIC0ga2V5IChzdHJpbmcpIGtleSB0byBzdG9yZSBkYXRhXG4gICAgIC0gdmFsdWUgKGFueSkgI29wdGlvbmFsIHZhbHVlIHRvIHN0b3JlXG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICAgKiBvciwgaWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZDpcbiAgICAgPSAoYW55KSB2YWx1ZVxuICAgICA+IFVzYWdlXG4gICAgIHwgZm9yICh2YXIgaSA9IDAsIGkgPCA1LCBpKyspIHtcbiAgICAgfCAgICAgcGFwZXIuY2lyY2xlKDEwICsgMTUgKiBpLCAxMCwgMTApXG4gICAgIHwgICAgICAgICAgLmF0dHIoe2ZpbGw6IFwiIzAwMFwifSlcbiAgICAgfCAgICAgICAgICAuZGF0YShcImlcIiwgaSlcbiAgICAgfCAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICB8ICAgICAgICAgICAgIGFsZXJ0KHRoaXMuZGF0YShcImlcIikpO1xuICAgICB8ICAgICAgICAgIH0pO1xuICAgICB8IH1cbiAgICBcXCovXG4gICAgZWxwcm90by5kYXRhID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBlbGRhdGFbdGhpcy5pZF0gPSBlbGRhdGFbdGhpcy5pZF0gfHwge307XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGEsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKFNuYXAuaXMoa2V5LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4ga2V5KSBpZiAoa2V5W2hhc10oaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhKGksIGtleVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlKFwic25hcC5kYXRhLmdldC5cIiArIHRoaXMuaWQsIHRoaXMsIGRhdGFba2V5XSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgIGV2ZShcInNuYXAuZGF0YS5zZXQuXCIgKyB0aGlzLmlkLCB0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVEYXRhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhbiBlbGVtZW50IGJ5IGdpdmVuIGtleS5cbiAgICAgKiBJZiBrZXkgaXMgbm90IHByb3ZpZGVkLCByZW1vdmVzIGFsbCB0aGUgZGF0YSBvZiB0aGUgZWxlbWVudC5cbiAgICAgLSBrZXkgKHN0cmluZykgI29wdGlvbmFsIGtleVxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICBlbGRhdGFbdGhpcy5pZF0gPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZGF0YVt0aGlzLmlkXSAmJiBkZWxldGUgZWxkYXRhW3RoaXMuaWRdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5vdXRlclNWR1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnQsIGVxdWl2YWxlbnQgdG8gSFRNTCdzIGBvdXRlckhUTUxgLlxuICAgICAqXG4gICAgICogU2VlIGFsc28gQEVsZW1lbnQuaW5uZXJTVkdcbiAgICAgPSAoc3RyaW5nKSBTVkcgY29kZSBmb3IgdGhlIGVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9TdHJpbmdcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNlZSBARWxlbWVudC5vdXRlclNWR1xuICAgIFxcKi9cbiAgICBlbHByb3RvLm91dGVyU1ZHID0gZWxwcm90by50b1N0cmluZyA9IHRvU3RyaW5nKDEpO1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmlubmVyU1ZHXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudCdzIGNvbnRlbnRzLCBlcXVpdmFsZW50IHRvIEhUTUwncyBgaW5uZXJIVE1MYFxuICAgICA9IChzdHJpbmcpIFNWRyBjb2RlIGZvciB0aGUgZWxlbWVudFxuICAgIFxcKi9cbiAgICBlbHByb3RvLmlubmVyU1ZHID0gdG9TdHJpbmcoKTtcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gdHlwZSA/IFwiPFwiICsgdGhpcy50eXBlIDogXCJcIixcbiAgICAgICAgICAgICAgICBhdHRyID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgY2hsZCA9IHRoaXMubm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhdHRyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiIFwiICsgYXR0cltpXS5uYW1lICsgJz1cIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJbaV0udmFsdWUucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0eXBlICYmIChyZXMgKz0gXCI+XCIpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gY2hsZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSBjaGxkW2ldLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGxkW2ldLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyArPSB3cmFwKGNobGRbaV0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSAmJiAocmVzICs9IFwiLz5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuYnRvYSkge1xuICAgICAgICAgICAgdmFyIGJiID0gdGhpcy5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgc3ZnID0gU25hcC5mb3JtYXQoJzxzdmcgdmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB3aWR0aD1cInt3aWR0aH1cIiBoZWlnaHQ9XCJ7aGVpZ2h0fVwiIHZpZXdCb3g9XCJ7eH0ge3l9IHt3aWR0aH0ge2hlaWdodH1cIj57Y29udGVudHN9PC9zdmc+Jywge1xuICAgICAgICAgICAgICAgIHg6ICtiYi54LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgeTogK2JiLnkudG9GaXhlZCgzKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogK2JiLndpZHRoLnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiArYmIuaGVpZ2h0LnRvRml4ZWQoMyksXG4gICAgICAgICAgICAgICAgY29udGVudHM6IHRoaXMub3V0ZXJTVkcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3ZnKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0XG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3QgPSBlbHByb3RvLnNlbGVjdDtcbiAgICAvKlxcXG4gICAgICogRnJhZ21lbnQuc2VsZWN0QWxsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQEVsZW1lbnQuc2VsZWN0QWxsXG4gICAgXFwqL1xuICAgIEZyYWdtZW50LnByb3RvdHlwZS5zZWxlY3RBbGwgPSBlbHByb3RvLnNlbGVjdEFsbDtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgRSA9IFwiXCI7XG4gICAgZnVuY3Rpb24gTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCAmJiBvYmplY3RUb1N0cmluZy5jYWxsKGEpID09IFwiW29iamVjdCBTVkdNYXRyaXhdXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYSA9IGEuYTtcbiAgICAgICAgICAgIHRoaXMuYiA9IGEuYjtcbiAgICAgICAgICAgIHRoaXMuYyA9IGEuYztcbiAgICAgICAgICAgIHRoaXMuZCA9IGEuZDtcbiAgICAgICAgICAgIHRoaXMuZSA9IGEuZTtcbiAgICAgICAgICAgIHRoaXMuZiA9IGEuZjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmEgPSArYTtcbiAgICAgICAgICAgIHRoaXMuYiA9ICtiO1xuICAgICAgICAgICAgdGhpcy5jID0gK2M7XG4gICAgICAgICAgICB0aGlzLmQgPSArZDtcbiAgICAgICAgICAgIHRoaXMuZSA9ICtlO1xuICAgICAgICAgICAgdGhpcy5mID0gK2Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmEgPSAxO1xuICAgICAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgICAgIHRoaXMuYyA9IDA7XG4gICAgICAgICAgICB0aGlzLmQgPSAxO1xuICAgICAgICAgICAgdGhpcy5lID0gMDtcbiAgICAgICAgICAgIHRoaXMuZiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKGZ1bmN0aW9uIChtYXRyaXhwcm90bykge1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5hZGRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIEFkZHMgdGhlIGdpdmVuIG1hdHJpeCB0byBleGlzdGluZyBvbmVcbiAgICAgICAgIC0gYSAobnVtYmVyKVxuICAgICAgICAgLSBiIChudW1iZXIpXG4gICAgICAgICAtIGMgKG51bWJlcilcbiAgICAgICAgIC0gZCAobnVtYmVyKVxuICAgICAgICAgLSBlIChudW1iZXIpXG4gICAgICAgICAtIGYgKG51bWJlcilcbiAgICAgICAgICogb3JcbiAgICAgICAgIC0gbWF0cml4IChvYmplY3QpIEBNYXRyaXhcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5hZGQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICAgICAgaWYgKGEgJiYgYSBpbnN0YW5jZW9mIE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChhLmEsIGEuYiwgYS5jLCBhLmQsIGEuZSwgYS5mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhTmV3ID0gYSAqIHRoaXMuYSArIGIgKiB0aGlzLmMsXG4gICAgICAgICAgICAgICAgYk5ldyA9IGEgKiB0aGlzLmIgKyBiICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5lICs9IGUgKiB0aGlzLmEgKyBmICogdGhpcy5jO1xuICAgICAgICAgICAgdGhpcy5mICs9IGUgKiB0aGlzLmIgKyBmICogdGhpcy5kO1xuICAgICAgICAgICAgdGhpcy5jID0gYyAqIHRoaXMuYSArIGQgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmQgPSBjICogdGhpcy5iICsgZCAqIHRoaXMuZDtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYiA9IGJOZXc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgubXVsdExlZnRcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE11bHRpcGxpZXMgYSBwYXNzZWQgYWZmaW5lIHRyYW5zZm9ybSB0byB0aGUgbGVmdDogTSAqIHRoaXMuXG4gICAgICAgICAtIGEgKG51bWJlcilcbiAgICAgICAgIC0gYiAobnVtYmVyKVxuICAgICAgICAgLSBjIChudW1iZXIpXG4gICAgICAgICAtIGQgKG51bWJlcilcbiAgICAgICAgIC0gZSAobnVtYmVyKVxuICAgICAgICAgLSBmIChudW1iZXIpXG4gICAgICAgICAqIG9yXG4gICAgICAgICAtIG1hdHJpeCAob2JqZWN0KSBATWF0cml4XG4gICAgICAgIFxcKi9cbiAgICAgICAgTWF0cml4LnByb3RvdHlwZS5tdWx0TGVmdCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgICAgICBpZiAoYSAmJiBhIGluc3RhbmNlb2YgTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdExlZnQoYS5hLCBhLmIsIGEuYywgYS5kLCBhLmUsIGEuZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYU5ldyA9IGEgKiB0aGlzLmEgKyBjICogdGhpcy5iLFxuICAgICAgICAgICAgICAgIGNOZXcgPSBhICogdGhpcy5jICsgYyAqIHRoaXMuZCxcbiAgICAgICAgICAgICAgICBlTmV3ID0gYSAqIHRoaXMuZSArIGMgKiB0aGlzLmYgKyBlO1xuICAgICAgICAgICAgdGhpcy5iID0gYiAqIHRoaXMuYSArIGQgKiB0aGlzLmI7XG4gICAgICAgICAgICB0aGlzLmQgPSBiICogdGhpcy5jICsgZCAqIHRoaXMuZDtcbiAgICAgICAgICAgIHRoaXMuZiA9IGIgKiB0aGlzLmUgKyBkICogdGhpcy5mICsgZjtcblxuICAgICAgICAgICAgdGhpcy5hID0gYU5ldztcbiAgICAgICAgICAgIHRoaXMuYyA9IGNOZXc7XG4gICAgICAgICAgICB0aGlzLmUgPSBlTmV3O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LmludmVydFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmludmVydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgeCA9IG1lLmEgKiBtZS5kIC0gbWUuYiAqIG1lLmM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtZS5kIC8geCwgLW1lLmIgLyB4LCAtbWUuYyAvIHgsIG1lLmEgLyB4LCAobWUuYyAqIG1lLmYgLSBtZS5kICogbWUuZSkgLyB4LCAobWUuYiAqIG1lLmUgLSBtZS5hICogbWUuZikgLyB4KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguY2xvbmVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXhcbiAgICAgICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnRyYW5zbGF0ZVxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogVHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICAgICAgIC0geCAobnVtYmVyKSBob3Jpem9udGFsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICAgLSB5IChudW1iZXIpIHZlcnRpY2FsIG9mZnNldCBkaXN0YW5jZVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmUgKz0geCAqIHRoaXMuYSArIHkgKiB0aGlzLmM7XG4gICAgICAgICAgICB0aGlzLmYgKz0geCAqIHRoaXMuYiArIHkgKiB0aGlzLmQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2NhbGVcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNjYWxlcyB0aGUgbWF0cml4XG4gICAgICAgICAtIHggKG51bWJlcikgYW1vdW50IHRvIGJlIHNjYWxlZCwgd2l0aCBgMWAgcmVzdWx0aW5nIGluIG5vIGNoYW5nZVxuICAgICAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgdG8gc2NhbGUgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMuIChPdGhlcndpc2UgYHhgIGFwcGxpZXMgdG8gYm90aCBheGVzLilcbiAgICAgICAgIC0gY3ggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gc2NhbGVcbiAgICAgICAgIC0gY3kgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIG9yaWdpbiBwb2ludCBmcm9tIHdoaWNoIHRvIHNjYWxlXG4gICAgICAgICAqIERlZmF1bHQgY3gsIGN5IGlzIHRoZSBtaWRkbGUgcG9pbnQgb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2NhbGUgPSBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XG4gICAgICAgICAgICB5ID09IG51bGwgJiYgKHkgPSB4KTtcbiAgICAgICAgICAgIChjeCB8fCBjeSkgJiYgdGhpcy50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICAgICAgdGhpcy5iICo9IHg7XG4gICAgICAgICAgICB0aGlzLmMgKj0geTtcbiAgICAgICAgICAgIHRoaXMuZCAqPSB5O1xuICAgICAgICAgICAgKGN4IHx8IGN5KSAmJiB0aGlzLnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgucm90YXRlXG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSb3RhdGVzIHRoZSBtYXRyaXhcbiAgICAgICAgIC0gYSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvbiwgaW4gZGVncmVlc1xuICAgICAgICAgLSB4IChudW1iZXIpIGhvcml6b250YWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgICAtIHkgKG51bWJlcikgdmVydGljYWwgb3JpZ2luIHBvaW50IGZyb20gd2hpY2ggdG8gcm90YXRlXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8ucm90YXRlID0gZnVuY3Rpb24gKGEsIHgsIHkpIHtcbiAgICAgICAgICAgIGEgPSBTbmFwLnJhZChhKTtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgdmFyIGNvcyA9ICttYXRoLmNvcyhhKS50b0ZpeGVkKDkpLFxuICAgICAgICAgICAgICAgIHNpbiA9ICttYXRoLnNpbihhKS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdGhpcy5hZGQoY29zLCBzaW4sIC1zaW4sIGNvcywgeCwgeSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoMSwgMCwgMCwgMSwgLXgsIC15KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1hcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHgtYXhpc1xuICAgICAgICAgLSB4IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHgtYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1lcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFNrZXdzIHRoZSBtYXRyaXggYWxvbmcgdGhlIHktYXhpc1xuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgIFxcKi9cbiAgICAgICAgbWF0cml4cHJvdG8uc2tld1kgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2tldygwLCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXguc2tld1xuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogU2tld3MgdGhlIG1hdHJpeFxuICAgICAgICAgLSB5IChudW1iZXIpIEFuZ2xlIHRvIHNrZXcgYWxvbmcgdGhlIHktYXhpcyAoaW4gZGVncmVlcykuXG4gICAgICAgICAtIHggKG51bWJlcikgQW5nbGUgdG8gc2tldyBhbG9uZyB0aGUgeC1heGlzIChpbiBkZWdyZWVzKS5cbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5za2V3ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSB4IHx8IDA7XG4gICAgICAgICAgICB5ID0geSB8fCAwO1xuICAgICAgICAgICAgeCA9IFNuYXAucmFkKHgpO1xuICAgICAgICAgICAgeSA9IFNuYXAucmFkKHkpO1xuICAgICAgICAgICAgdmFyIGMgPSBtYXRoLnRhbih4KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgdmFyIGIgPSBtYXRoLnRhbih5KS50b0ZpeGVkKDkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKDEsIGIsIGMsIDEsIDAsIDApO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC54XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHggY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueVxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeFxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnggPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmEgKyB5ICogdGhpcy5jICsgdGhpcy5lO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC55XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBSZXR1cm5zIHkgY29vcmRpbmF0ZSBmb3IgZ2l2ZW4gcG9pbnQgYWZ0ZXIgdHJhbnNmb3JtYXRpb24gZGVzY3JpYmVkIGJ5IHRoZSBtYXRyaXguIFNlZSBhbHNvIEBNYXRyaXgueFxuICAgICAgICAgLSB4IChudW1iZXIpXG4gICAgICAgICAtIHkgKG51bWJlcilcbiAgICAgICAgID0gKG51bWJlcikgeVxuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnkgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKiB0aGlzLmIgKyB5ICogdGhpcy5kICsgdGhpcy5mO1xuICAgICAgICB9O1xuICAgICAgICBtYXRyaXhwcm90by5nZXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzW1N0ci5mcm9tQ2hhckNvZGUoOTcgKyBpKV0udG9GaXhlZCg0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWF0cml4cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJtYXRyaXgoXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV0uam9pbigpICsgXCIpXCI7XG4gICAgICAgIH07XG4gICAgICAgIG1hdHJpeHByb3RvLm9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5lLnRvRml4ZWQoNCksIHRoaXMuZi50b0ZpeGVkKDQpXTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gbm9ybShhKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUoYSkge1xuICAgICAgICAgICAgdmFyIG1hZyA9IG1hdGguc3FydChub3JtKGEpKTtcbiAgICAgICAgICAgIGFbMF0gJiYgKGFbMF0gLz0gbWFnKTtcbiAgICAgICAgICAgIGFbMV0gJiYgKGFbMV0gLz0gbWFnKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIE1hdHJpeC5kZXRlcm1pbmFudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogRmluZHMgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAgICAgICAgID0gKG51bWJlcikgZGV0ZXJtaW5hbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmEgKiB0aGlzLmQgLSB0aGlzLmIgKiB0aGlzLmM7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogTWF0cml4LnNwbGl0XG4gICAgICAgICBbIG1ldGhvZCBdXG4gICAgICAgICAqKlxuICAgICAgICAgKiBTcGxpdHMgbWF0cml4IGludG8gcHJpbWl0aXZlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgICAgICBvIGR4IChudW1iZXIpIHRyYW5zbGF0aW9uIGJ5IHhcbiAgICAgICAgIG8gZHkgKG51bWJlcikgdHJhbnNsYXRpb24gYnkgeVxuICAgICAgICAgbyBzY2FsZXggKG51bWJlcikgc2NhbGUgYnkgeFxuICAgICAgICAgbyBzY2FsZXkgKG51bWJlcikgc2NhbGUgYnkgeVxuICAgICAgICAgbyBzaGVhciAobnVtYmVyKSBzaGVhclxuICAgICAgICAgbyByb3RhdGUgKG51bWJlcikgcm90YXRpb24gaW4gZGVnXG4gICAgICAgICBvIGlzU2ltcGxlIChib29sZWFuKSBjb3VsZCBpdCBiZSByZXByZXNlbnRlZCB2aWEgc2ltcGxlIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICBcXCovXG4gICAgICAgIG1hdHJpeHByb3RvLnNwbGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRpb25cbiAgICAgICAgICAgIG91dC5keCA9IHRoaXMuZTtcbiAgICAgICAgICAgIG91dC5keSA9IHRoaXMuZjtcblxuICAgICAgICAgICAgLy8gc2NhbGUgYW5kIHNoZWFyXG4gICAgICAgICAgICB2YXIgcm93ID0gW1t0aGlzLmEsIHRoaXMuYl0sIFt0aGlzLmMsIHRoaXMuZF1dO1xuICAgICAgICAgICAgb3V0LnNjYWxleCA9IG1hdGguc3FydChub3JtKHJvd1swXSkpO1xuICAgICAgICAgICAgbm9ybWFsaXplKHJvd1swXSk7XG5cbiAgICAgICAgICAgIG91dC5zaGVhciA9IHJvd1swXVswXSAqIHJvd1sxXVswXSArIHJvd1swXVsxXSAqIHJvd1sxXVsxXTtcbiAgICAgICAgICAgIHJvd1sxXSA9IFtyb3dbMV1bMF0gLSByb3dbMF1bMF0gKiBvdXQuc2hlYXIsIHJvd1sxXVsxXSAtIHJvd1swXVsxXSAqIG91dC5zaGVhcl07XG5cbiAgICAgICAgICAgIG91dC5zY2FsZXkgPSBtYXRoLnNxcnQobm9ybShyb3dbMV0pKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShyb3dbMV0pO1xuICAgICAgICAgICAgb3V0LnNoZWFyIC89IG91dC5zY2FsZXk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRldGVybWluYW50KCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNjYWxleCA9IC1vdXQuc2NhbGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByb3RhdGlvblxuICAgICAgICAgICAgdmFyIHNpbiA9IHJvd1swXVsxXSxcbiAgICAgICAgICAgICAgICBjb3MgPSByb3dbMV1bMV07XG4gICAgICAgICAgICBpZiAoY29zIDwgMCkge1xuICAgICAgICAgICAgICAgIG91dC5yb3RhdGUgPSBTbmFwLmRlZyhtYXRoLmFjb3MoY29zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnJvdGF0ZSA9IDM2MCAtIG91dC5yb3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQucm90YXRlID0gU25hcC5kZWcobWF0aC5hc2luKHNpbikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXQuaXNTaW1wbGUgPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmIChvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpIHx8ICFvdXQucm90YXRlKTtcbiAgICAgICAgICAgIG91dC5pc1N1cGVyU2ltcGxlID0gIStvdXQuc2hlYXIudG9GaXhlZCg5KSAmJiBvdXQuc2NhbGV4LnRvRml4ZWQoOSkgPT0gb3V0LnNjYWxleS50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgb3V0Lm5vUm90YXRpb24gPSAhK291dC5zaGVhci50b0ZpeGVkKDkpICYmICFvdXQucm90YXRlO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBNYXRyaXgudG9UcmFuc2Zvcm1TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgdHJhbnNmb3JtIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgZ2l2ZW4gbWF0cml4XG4gICAgICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybSBzdHJpbmdcbiAgICAgICAgXFwqL1xuICAgICAgICBtYXRyaXhwcm90by50b1RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uIChzaG9ydGVyKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHNob3J0ZXIgfHwgdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgaWYgKCErcy5zaGVhci50b0ZpeGVkKDkpKSB7XG4gICAgICAgICAgICAgICAgcy5zY2FsZXggPSArcy5zY2FsZXgudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICBzLnNjYWxleSA9ICtzLnNjYWxleS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIHMucm90YXRlID0gK3Mucm90YXRlLnRvRml4ZWQoNCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICAocy5keCB8fCBzLmR5ID8gXCJ0XCIgKyBbK3MuZHgudG9GaXhlZCg0KSwgK3MuZHkudG9GaXhlZCg0KV0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5yb3RhdGUgPyBcInJcIiArIFsrcy5yb3RhdGUudG9GaXhlZCg0KSwgMCwgMF0gOiBFKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocy5zY2FsZXggIT0gMSB8fCBzLnNjYWxleSAhPSAxID8gXCJzXCIgKyBbcy5zY2FsZXgsIHMuc2NhbGV5LCAwLCAwXSA6IEUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtXCIgKyBbdGhpcy5nZXQoMCksIHRoaXMuZ2V0KDEpLCB0aGlzLmdldCgyKSwgdGhpcy5nZXQoMyksIHRoaXMuZ2V0KDQpLCB0aGlzLmdldCg1KV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoTWF0cml4LnByb3RvdHlwZSk7XG4gICAgLypcXFxuICAgICAqIFNuYXAuTWF0cml4XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBNYXRyaXggY29uc3RydWN0b3IsIGV4dGVuZCBvbiB5b3VyIG93biByaXNrLlxuICAgICAqIFRvIGNyZWF0ZSBtYXRyaWNlcyB1c2UgQFNuYXAubWF0cml4LlxuICAgIFxcKi9cbiAgICBTbmFwLk1hdHJpeCA9IE1hdHJpeDtcbiAgICAvKlxcXG4gICAgICogU25hcC5tYXRyaXhcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcGFyYW1ldGVyc1xuICAgICAtIGEgKG51bWJlcilcbiAgICAgLSBiIChudW1iZXIpXG4gICAgIC0gYyAobnVtYmVyKVxuICAgICAtIGQgKG51bWJlcilcbiAgICAgLSBlIChudW1iZXIpXG4gICAgIC0gZiAobnVtYmVyKVxuICAgICAqIG9yXG4gICAgIC0gc3ZnTWF0cml4IChTVkdNYXRyaXgpXG4gICAgID0gKG9iamVjdCkgQE1hdHJpeFxuICAgIFxcKi9cbiAgICBTbmFwLm1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciBoYXMgPSBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgIG1ha2UgPSBTbmFwLl8ubWFrZSxcbiAgICAgICAgd3JhcCA9IFNuYXAuXy53cmFwLFxuICAgICAgICBpcyA9IFNuYXAuaXMsXG4gICAgICAgIGdldFNvbWVEZWZzID0gU25hcC5fLmdldFNvbWVEZWZzLFxuICAgICAgICByZVVSTFZhbHVlID0gL151cmxcXCgoWydcIl0/KShbXildKylcXDFcXCkkLyxcbiAgICAgICAgJCA9IFNuYXAuXy4kLFxuICAgICAgICBVUkwgPSBTbmFwLnVybCxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICBzZXBhcmF0b3IgPSBTbmFwLl8uc2VwYXJhdG9yLFxuICAgICAgICBFID0gXCJcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5kZXVybFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVW53cmFwcyBwYXRoIGZyb20gYFwidXJsKDxwYXRoPilcImAuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgdXJsIHBhdGhcbiAgICAgPSAoc3RyaW5nKSB1bndyYXBwZWQgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLmRldXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBTdHJpbmcodmFsdWUpLm1hdGNoKHJlVVJMVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzID8gcmVzWzJdIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIEF0dHJpYnV0ZXMgZXZlbnQgaGFuZGxlcnNcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXNrXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCAmJiB2YWx1ZS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBnZXRTb21lRGVmcyh0aGlzKS5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwibWFza1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFzayA9IG1ha2UoXCJtYXNrXCIsIGdldFNvbWVEZWZzKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBtYXNrLm5vZGUuYXBwZW5kQ2hpbGQodmFsdWUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhbWFzay5ub2RlLmlkICYmICQobWFzay5ub2RlLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG1hc2suaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBtYXNrOiBVUkwobWFzay5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKGZ1bmN0aW9uIChjbGlwSXQpIHtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFwiLCBjbGlwSXQpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5jbGlwLXBhdGhcIiwgY2xpcEl0KTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xpcFBhdGhcIiwgY2xpcEl0KTtcbiAgICB9KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgY2xpcCxcbiAgICAgICAgICAgICAgICBub2RlID0gdmFsdWUubm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09IFwiY2xpcFBhdGhcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gbmV3IEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGlwID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xpcCkge1xuICAgICAgICAgICAgICAgIGNsaXAgPSBtYWtlKFwiY2xpcFBhdGhcIiwgZ2V0U29tZURlZnModGhpcykpO1xuICAgICAgICAgICAgICAgIGNsaXAubm9kZS5hcHBlbmRDaGlsZCh2YWx1ZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAhY2xpcC5ub2RlLmlkICYmICQoY2xpcC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjbGlwLmlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgICAgIFwiY2xpcC1wYXRoXCI6IFVSTChjbGlwLm5vZGUuaWQgfHwgY2xpcC5pZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGZpbGxTdHJva2UobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnJhZ21lbnQgJiYgdmFsdWUubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicmFkaWFsR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwibGluZWFyR3JhZGllbnRcIiB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLm5vZGUuZmlyc3RDaGlsZC50YWdOYW1lID09IFwicGF0dGVyblwiKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGdldFNvbWVEZWZzKHRoaXMpLmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXAodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09IFwicmFkaWFsR3JhZGllbnRcIiB8fCB2YWx1ZS50eXBlID09IFwibGluZWFyR3JhZGllbnRcIlxuICAgICAgICAgICAgICAgICAgIHx8IHZhbHVlLnR5cGUgPT0gXCJwYXR0ZXJuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxsID0gVVJMKHZhbHVlLm5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZS5hdHRyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsbCA9IFNuYXAuY29sb3IodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkID0gU25hcChnZXRTb21lRGVmcyh0aGlzKS5vd25lclNWR0VsZW1lbnQpLmdyYWRpZW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ3JhZC5ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChncmFkLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGdyYWQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSBVUkwoZ3JhZC5ub2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSBTdHIoZmlsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGZpbGw7XG4gICAgICAgICAgICAkKHRoaXMubm9kZSwgYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW25hbWVdID0gRTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZmlsbFwiLCBmaWxsU3Ryb2tlKFwiZmlsbFwiKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuc3Ryb2tlXCIsIGZpbGxTdHJva2UoXCJzdHJva2VcIikpO1xuICAgIHZhciBncmFkcmcgPSAvXihbbHJdKSg/OlxcKChbXildKilcXCkpPyguKikkL2k7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdyYWQucGFyc2VcIiwgZnVuY3Rpb24gcGFyc2VHcmFkKHN0cmluZykge1xuICAgICAgICBzdHJpbmcgPSBTdHIoc3RyaW5nKTtcbiAgICAgICAgdmFyIHRva2VucyA9IHN0cmluZy5tYXRjaChncmFkcmcpO1xuICAgICAgICBpZiAoIXRva2Vucykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbnNbMV0sXG4gICAgICAgICAgICBwYXJhbXMgPSB0b2tlbnNbMl0sXG4gICAgICAgICAgICBzdG9wcyA9IHRva2Vuc1szXTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zLnNwbGl0KC9cXHMqLFxccyovKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gK2VsID09IGVsID8gK2VsIDogZWw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PSAxICYmIHBhcmFtc1swXSA9PSAwKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcyA9IHN0b3BzLnNwbGl0KFwiLVwiKTtcbiAgICAgICAgc3RvcHMgPSBzdG9wcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGVsWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGVsWzFdKSB7XG4gICAgICAgICAgICAgICAgb3V0Lm9mZnNldCA9IHBhcnNlRmxvYXQoZWxbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsZW4gPSBzdG9wcy5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgZnVuY3Rpb24gc2VlZChpLCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gKGVuZCAtIHN0YXJ0KSAvIChpIC0gaik7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gajsgayA8IGk7IGsrKykge1xuICAgICAgICAgICAgICAgIHN0b3BzW2tdLm9mZnNldCA9ICsoK3N0YXJ0ICsgc3RlcCAqIChrIC0gaikpLnRvRml4ZWQoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGxlbi0tO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBpZiAoXCJvZmZzZXRcIiBpbiBzdG9wc1tpXSkge1xuICAgICAgICAgICAgc2VlZChpLCBzdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BzW2xlbl0ub2Zmc2V0ID0gc3RvcHNbbGVuXS5vZmZzZXQgfHwgMTAwO1xuICAgICAgICBzZWVkKGxlbiwgc3RvcHNbbGVuXS5vZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgc3RvcHM6IHN0b3BzXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5kXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAoaXModmFsdWUsIFwiYXJyYXlcIikgJiYgaXModmFsdWVbMF0sIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gU25hcC5wYXRoLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gU3RyKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9bcnVvXS9pKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBTbmFwLnBhdGgudG9BYnNvbHV0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgJCh0aGlzLm5vZGUsIHtkOiB2YWx1ZX0pO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgdmFsdWUgPSBTdHIodmFsdWUpO1xuICAgICAgICB2YXIgdHh0ID0gZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHR4dCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnBhdGhcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMuYXR0cih7ZDogdmFsdWV9KTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuY2xhc3NcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IHZhbHVlO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci52aWV3Qm94XCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdmI7XG4gICAgICAgIGlmIChpcyh2YWx1ZSwgXCJvYmplY3RcIikgJiYgXCJ4XCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIHZiID0gW3ZhbHVlLngsIHZhbHVlLnksIHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHRdLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKHZhbHVlLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YiA9IHZhbHVlLmpvaW4oXCIgXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMubm9kZSwge1xuICAgICAgICAgICAgdmlld0JveDogdmJcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0odmFsdWUpO1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5yXCIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwicmVjdFwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICByeDogdmFsdWUsXG4gICAgICAgICAgICAgICAgcnk6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGlkLCB0cCwgbm9kZTtcbiAgICAgICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy50ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHAubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0cC5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50ZXh0UGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXModmFsdWUsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZnMgPSBnZXRTb21lRGVmcyh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHdyYXAoZGVmcy5wYXJlbnROb2RlKS5wYXRoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgubm9kZSk7XG4gICAgICAgICAgICAgICAgaWQgPSBwYXRoLmlkO1xuICAgICAgICAgICAgICAgIHBhdGguYXR0cih7aWQ6IGlkfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gd3JhcCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmF0dHIoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLmF0dHIoe2lkOiBpZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgdHAgPSB0aGlzLnRleHRQYXRoO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRwLmF0dHIoe1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHAgPSAkKFwidGV4dFBhdGhcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IFwiI1wiICsgaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwLmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0cCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dFBhdGggPSB3cmFwKHRwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIudGV4dFwiLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgdHVuZXIgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9ICQoXCJ0c3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKGNodW5rLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZENoaWxkKHR1bmVyKGNodW5rW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kQ2hpbGQoZ2xvYi5kb2MuY3JlYXRlVGV4dE5vZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQubm9ybWFsaXplICYmIG91dC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0dW5lZCA9IHR1bmVyKHZhbHVlKTtcbiAgICAgICAgICAgIHdoaWxlICh0dW5lZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0dW5lZC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgIH0pKC0xKTtcbiAgICBmdW5jdGlvbiBzZXRGb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICBpZiAodmFsdWUgPT0gK3ZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLmZvbnRTaXplID0gdmFsdWU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5hdHRyLmZvbnRTaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIuZm9udC1zaXplXCIsIHNldEZvbnRTaXplKSgtMSk7XG5cblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLnRyYW5zZm9ybVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgpO1xuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci50ZXh0cGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRQYXRoO1xuICAgIH0pKC0xKTtcbiAgICAvLyBNYXJrZXJzXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ2V0dGVyKGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdsb2IuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFya2VyLVwiICsgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTbmFwKGdsb2IuZG9jLmdldEVsZW1lbnRCeUlkKHN0eWxlLm1hdGNoKHJlVVJMVmFsdWUpWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIoZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFwibWFya2VyXCIgKyBlbmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIlwiIHx8ICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbbmFtZV0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHZhbHVlLm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodmFsdWUubm9kZSwge2lkOiB2YWx1ZS5pZH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVtuYW1lXSA9IFVSTChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1lbmRcIiwgZ2V0dGVyKFwiZW5kXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlckVuZFwiLCBnZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIubWFya2VyLXN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlclN0YXJ0XCIsIGdldHRlcihcInN0YXJ0XCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlci1taWRcIiwgZ2V0dGVyKFwibWlkXCIpKSgtMSk7XG4gICAgICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLm1hcmtlck1pZFwiLCBnZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLWVuZFwiLCBzZXR0ZXIoXCJlbmRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyRW5kXCIsIHNldHRlcihcImVuZFwiKSkoLTEpO1xuICAgICAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5tYXJrZXItc3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyU3RhcnRcIiwgc2V0dGVyKFwic3RhcnRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyLW1pZFwiLCBzZXR0ZXIoXCJtaWRcIikpKC0xKTtcbiAgICAgICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHIubWFya2VyTWlkXCIsIHNldHRlcihcIm1pZFwiKSkoLTEpO1xuICAgIH0oKSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJyZWN0XCIgJiYgJCh0aGlzLm5vZGUsIFwicnhcIikgPT0gJCh0aGlzLm5vZGUsIFwicnlcIikpIHtcbiAgICAgICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzLm5vZGUsIFwicnhcIik7XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gdGV4dEV4dHJhY3Qobm9kZSkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpLnRhZ05hbWUgPT0gXCJ0c3BhblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIGNoaS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goY2hpLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh0ZXh0RXh0cmFjdChjaGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gXCJ0ZXh0XCIgfHwgdGhpcy50eXBlID09IFwidHNwYW5cIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSB0ZXh0RXh0cmFjdCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG91dC5sZW5ndGggPT0gMSA/IG91dFswXSA6IG91dDtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci4jdGV4dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZShcInNuYXAudXRpbC5nZXRhdHRyLmZpbGxcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuc3Ryb2tlXCIsIGZ1bmN0aW9uIChpbnRlcm5hbCkge1xuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBldmUoXCJzbmFwLnV0aWwuZ2V0YXR0ci5zdHJva2VcIiwgdGhpcywgdHJ1ZSkuZmlyc3REZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBTbmFwKFNuYXAuZGV1cmwodmFsdWUpKSB8fCB2YWx1ZTtcbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIudmlld0JveFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciB2YiA9ICQodGhpcy5ub2RlLCBcInZpZXdCb3hcIik7XG4gICAgICAgIGlmICh2Yikge1xuICAgICAgICAgICAgdmIgPSB2Yi5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goK3ZiWzBdLCArdmJbMV0sICt2YlsyXSwgK3ZiWzNdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pKC0xKTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuZ2V0YXR0ci5wb2ludHNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9ICQodGhpcy5ub2RlLCBcInBvaW50c1wiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIucGF0aFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZFwiKTtcbiAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSkoLTEpO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmNsYXNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9KSgtMSk7XG4gICAgZnVuY3Rpb24gZ2V0Rm9udFNpemUoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGUuZm9udFNpemU7XG4gICAgfVxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZvbnRTaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmdldGF0dHIuZm9udC1zaXplXCIsIGdldEZvbnRTaXplKSgtMSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDE0IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iLCBGcmFnbWVudCkge1xuICAgIHZhciByZ05vdFNwYWNlID0gL1xcUysvZyxcbiAgICAgICAgcmdCYWRTcGFjZSA9IC9bXFx0XFxyXFxuXFxmXS9nLFxuICAgICAgICByZ1RyaW0gPSAvKF5cXHMrfFxccyskKS9nLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hZGRDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgIC0gdmFsdWUgKHN0cmluZykgY2xhc3MgbmFtZSBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lc1xuICAgICAqKlxuICAgICA9IChFbGVtZW50KSBvcmlnaW5hbCBlbGVtZW50LlxuICAgIFxcKi9cbiAgICBlbHByb3RvLmFkZENsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gU3RyKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgZWxlbSA9IHRoaXMubm9kZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lLmJhc2VWYWwsXG4gICAgICAgICAgICBjdXJDbGFzc2VzID0gY2xhc3NOYW1lLm1hdGNoKHJnTm90U3BhY2UpIHx8IFtdLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGNsYXp6LFxuICAgICAgICAgICAgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAoIX5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyQ2xhc3Nlcy5wdXNoKGNsYXp6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBjdXJDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuYmFzZVZhbCA9IGZpbmFsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5yZW1vdmVDbGFzc1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBnaXZlbiBjbGFzcyBuYW1lIG9yIGxpc3Qgb2YgY2xhc3MgbmFtZXMgZnJvbSB0aGUgZWxlbWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBTdHIodmFsdWUgfHwgXCJcIikubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW10sXG4gICAgICAgICAgICBqLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgY2xhenosXG4gICAgICAgICAgICBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAoY3VyQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gY3VyQ2xhc3Nlcy5pbmRleE9mKGNsYXp6KTtcbiAgICAgICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgICAgICBjdXJDbGFzc2VzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGN1ckNsYXNzZXMuam9pbihcIiBcIik7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lICE9IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lmhhc0NsYXNzXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGVsZW1lbnQgaGFzIGEgZ2l2ZW4gY2xhc3MgbmFtZSBpbiB0aGUgbGlzdCBvZiBjbGFzcyBuYW1lcyBhcHBsaWVkIHRvIGl0LlxuICAgICAtIHZhbHVlIChzdHJpbmcpIGNsYXNzIG5hbWVcbiAgICAgKipcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHRoZSBlbGVtZW50IGhhcyBnaXZlbiBjbGFzc1xuICAgIFxcKi9cbiAgICBlbHByb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWUuYmFzZVZhbCxcbiAgICAgICAgICAgIGN1ckNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2gocmdOb3RTcGFjZSkgfHwgW107XG4gICAgICAgIHJldHVybiAhIX5jdXJDbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG9nZ2xlQ2xhc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZCBvciByZW1vdmUgb25lIG9yIG1vcmUgY2xhc3NlcyBmcm9tIHRoZSBlbGVtZW50LCBkZXBlbmRpbmcgb24gZWl0aGVyXG4gICAgICogdGhlIGNsYXNz4oCZcyBwcmVzZW5jZSBvciB0aGUgdmFsdWUgb2YgdGhlIGBmbGFnYCBhcmd1bWVudC5cbiAgICAgLSB2YWx1ZSAoc3RyaW5nKSBjbGFzcyBuYW1lIG9yIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzIG5hbWVzXG4gICAgIC0gZmxhZyAoYm9vbGVhbikgdmFsdWUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNsYXNzIHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIG9yaWdpbmFsIGVsZW1lbnQuXG4gICAgXFwqL1xuICAgIGVscHJvdG8udG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAodmFsdWUsIGZsYWcpIHtcbiAgICAgICAgaWYgKGZsYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRDbGFzcyh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NlcyA9ICh2YWx1ZSB8fCBcIlwiKS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGVsZW0gPSB0aGlzLm5vZGUsXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsLFxuICAgICAgICAgICAgY3VyQ2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChyZ05vdFNwYWNlKSB8fCBbXSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBjbGF6eixcbiAgICAgICAgICAgIGZpbmFsVmFsdWU7XG4gICAgICAgIGogPSAwO1xuICAgICAgICB3aGlsZSAoY2xhenogPSBjbGFzc2VzW2orK10pIHtcbiAgICAgICAgICAgIHBvcyA9IGN1ckNsYXNzZXMuaW5kZXhPZihjbGF6eik7XG4gICAgICAgICAgICBpZiAofnBvcykge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ckNsYXNzZXMucHVzaChjbGF6eik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbFZhbHVlID0gY3VyQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5iYXNlVmFsID0gZmluYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYiwgRnJhZ21lbnQpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgICAgICAgXCIrXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgeTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCItXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIvXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4IC8geTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCIqXCI6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4ICogeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgcmVVbml0ID0gL1thLXpdKyQvaSxcbiAgICAgICAgcmVBZGRvbiA9IC9eXFxzKihbK1xcLVxcLypdKVxccyo9XFxzKihbXFxkLmVFK1xcLV0rKVxccyooW15cXGRcXHNdKyk/XFxzKiQvO1xuICAgIGZ1bmN0aW9uIGdldE51bWJlcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VW5pdCh1bml0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gK3ZhbC50b0ZpeGVkKDMpICsgdW5pdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXZlLm9uKFwic25hcC51dGlsLmF0dHJcIiwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgcGx1cyA9IFN0cih2YWwpLm1hdGNoKHJlQWRkb24pO1xuICAgICAgICBpZiAocGx1cykge1xuICAgICAgICAgICAgdmFyIGV2bnQgPSBldmUubnQoKSxcbiAgICAgICAgICAgICAgICBuYW1lID0gZXZudC5zdWJzdHJpbmcoZXZudC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKSxcbiAgICAgICAgICAgICAgICBhID0gdGhpcy5hdHRyKG5hbWUpLFxuICAgICAgICAgICAgICAgIGF0ciA9IHt9O1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHZhciB1bml0ID0gcGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW3BsdXNbMV1dO1xuICAgICAgICAgICAgaWYgKGFVbml0ICYmIGFVbml0ID09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvcChwYXJzZUZsb2F0KGEpLCArcGx1c1syXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmFzUFgobmFtZSk7XG4gICAgICAgICAgICAgICAgdmFsID0gb3AodGhpcy5hc1BYKG5hbWUpLCB0aGlzLmFzUFgobmFtZSwgcGx1c1syXSArIHVuaXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihhKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXRyW25hbWVdID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5hdHRyKGF0cik7XG4gICAgICAgIH1cbiAgICB9KSgtMTApO1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXMsXG4gICAgICAgICAgICBicGx1cyA9IFN0cihiKS5tYXRjaChyZUFkZG9uKTtcbiAgICAgICAgaWYgKGJwbHVzKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIHVuaXQgPSBicGx1c1szXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGFVbml0ID0gYS5tYXRjaChyZVVuaXQpLFxuICAgICAgICAgICAgICAgIG9wID0gb3BlcmF0b3JzW2JwbHVzWzFdXTtcbiAgICAgICAgICAgIGlmIChhVW5pdCAmJiBhVW5pdCA9PSB1bml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogcGFyc2VGbG9hdChhKSxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9wKHBhcnNlRmxvYXQoYSksICticGx1c1syXSksXG4gICAgICAgICAgICAgICAgICAgIGY6IGdldFVuaXQoYVVuaXQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuYXNQWChuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBhLFxuICAgICAgICAgICAgICAgICAgICB0bzogb3AoYSwgdGhpcy5hc1BYKG5hbWUsIGJwbHVzWzJdICsgdW5pdCkpLFxuICAgICAgICAgICAgICAgICAgICBmOiBnZXROdW1iZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoLTEwKTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIHByb3RvID0gUGFwZXIucHJvdG90eXBlLFxuICAgICAgICBpcyA9IFNuYXAuaXM7XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnJlY3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxlZnQgY29ybmVyXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lclxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoXG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIGhlaWdodFxuICAgICAtIHJ4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHJhZGl1cyBmb3Igcm91bmRlZCBjb3JuZXJzLCBkZWZhdWx0IGlzIDBcbiAgICAgLSByeSAobnVtYmVyKSAjb3B0aW9uYWwgdmVydGljYWwgcmFkaXVzIGZvciByb3VuZGVkIGNvcm5lcnMsIGRlZmF1bHQgaXMgcnggb3IgMFxuICAgICA9IChvYmplY3QpIHRoZSBgcmVjdGAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgLy8gcmVndWxhciByZWN0YW5nbGVcbiAgICAgfCB2YXIgYyA9IHBhcGVyLnJlY3QoMTAsIDEwLCA1MCwgNTApO1xuICAgICB8IC8vIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVyc1xuICAgICB8IHZhciBjID0gcGFwZXIucmVjdCg0MCwgNDAsIDUwLCA1MCwgMTApO1xuICAgIFxcKi9cbiAgICBwcm90by5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgsIHJ4LCByeSkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJ5ID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpICYmIHggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocnggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIucnggPSByeDtcbiAgICAgICAgICAgICAgICBhdHRyLnJ5ID0gcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJyZWN0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmNpcmNsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSBjaXJjbGVcbiAgICAgKipcbiAgICAgLSB4IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZVxuICAgICAtIHIgKG51bWJlcikgcmFkaXVzXG4gICAgID0gKG9iamVjdCkgdGhlIGBjaXJjbGVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuY2lyY2xlKDUwLCA1MCwgNDApO1xuICAgIFxcKi9cbiAgICBwcm90by5jaXJjbGUgPSBmdW5jdGlvbiAoY3gsIGN5LCByKSB7XG4gICAgICAgIHZhciBhdHRyO1xuICAgICAgICBpZiAoaXMoY3gsIFwib2JqZWN0XCIpICYmIGN4ID09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICAgIGF0dHIgPSBjeDtcbiAgICAgICAgfSBlbHNlIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcImNpcmNsZVwiLCBhdHRyKTtcbiAgICB9O1xuXG4gICAgdmFyIHByZWxvYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBvbmVycm9yKCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3JjLCBmKSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZ2xvYi5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKSxcbiAgICAgICAgICAgICAgICBib2R5ID0gZ2xvYi5kb2MuYm9keTtcbiAgICAgICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZi5jYWxsKGltZyk7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLypcXFxuICAgICAqIFBhcGVyLmltYWdlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBQbGFjZXMgYW4gaW1hZ2Ugb24gdGhlIHN1cmZhY2VcbiAgICAgKipcbiAgICAgLSBzcmMgKHN0cmluZykgVVJJIG9mIHRoZSBzb3VyY2UgaW1hZ2VcbiAgICAgLSB4IChudW1iZXIpIHggb2Zmc2V0IHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IG9mZnNldCBwb3NpdGlvblxuICAgICAtIHdpZHRoIChudW1iZXIpIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgICAtIGhlaWdodCAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAgID0gKG9iamVjdCkgdGhlIGBpbWFnZWAgZWxlbWVudFxuICAgICAqIG9yXG4gICAgID0gKG9iamVjdCkgU25hcCBlbGVtZW50IG9iamVjdCB3aXRoIHR5cGUgYGltYWdlYFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMgPSBwYXBlci5pbWFnZShcImFwcGxlLnBuZ1wiLCAxMCwgMTAsIDgwLCA4MCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmltYWdlID0gZnVuY3Rpb24gKHNyYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsKFwiaW1hZ2VcIik7XG4gICAgICAgIGlmIChpcyhzcmMsIFwib2JqZWN0XCIpICYmIFwic3JjXCIgaW4gc3JjKSB7XG4gICAgICAgICAgICBlbC5hdHRyKHNyYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzZXQgPSB7XG4gICAgICAgICAgICAgICAgXCJ4bGluazpocmVmXCI6IHNyYyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBcIm5vbmVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LnggPSB4O1xuICAgICAgICAgICAgICAgIHNldC55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0LndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgc2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZChzcmMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU25hcC5fLiQoZWwubm9kZSwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZWxsaXBzZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYW4gZWxsaXBzZVxuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBjZW50cmVcbiAgICAgLSB5IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlXG4gICAgIC0gcnggKG51bWJlcikgaG9yaXpvbnRhbCByYWRpdXNcbiAgICAgLSByeSAobnVtYmVyKSB2ZXJ0aWNhbCByYWRpdXNcbiAgICAgPSAob2JqZWN0KSB0aGUgYGVsbGlwc2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIuZWxsaXBzZSg1MCwgNTAsIDQwLCAyMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLmVsbGlwc2UgPSBmdW5jdGlvbiAoY3gsIGN5LCByeCwgcnkpIHtcbiAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgIGlmIChpcyhjeCwgXCJvYmplY3RcIikgJiYgY3ggPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICAgICAgYXR0ciA9IGN4O1xuICAgICAgICB9IGVsc2UgaWYgKGN4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPXtcbiAgICAgICAgICAgICAgICBjeDogY3gsXG4gICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgIHJ4OiByeCxcbiAgICAgICAgICAgICAgICByeTogcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJlbGxpcHNlXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLy8gU0lFUlJBIFBhcGVyLnBhdGgoKTogVW5jbGVhciBmcm9tIHRoZSBsaW5rIHdoYXQgYSBDYXRtdWxsLVJvbSBjdXJ2ZXRvIGlzLCBhbmQgd2h5IGl0IHdvdWxkIG1ha2UgbGlmZSBhbnkgZWFzaWVyLlxuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wYXRoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxwYXRoPmAgZWxlbWVudCB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIGFzIHRoZSBwYXRoJ3MgZGVmaW5pdGlvblxuICAgICAtIHBhdGhTdHJpbmcgKHN0cmluZykgI29wdGlvbmFsIHBhdGggc3RyaW5nIGluIFNWRyBmb3JtYXRcbiAgICAgKiBQYXRoIHN0cmluZyBjb25zaXN0cyBvZiBvbmUtbGV0dGVyIGNvbW1hbmRzLCBmb2xsb3dlZCBieSBjb21tYSBzZXByYXJhdGVkIGFyZ3VtZW50cyBpbiBudW1lcmljYWwgZm9ybS4gRXhhbXBsZTpcbiAgICAgfCBcIk0xMCwyMEwzMCw0MFwiXG4gICAgICogVGhpcyBleGFtcGxlIGZlYXR1cmVzIHR3byBjb21tYW5kczogYE1gLCB3aXRoIGFyZ3VtZW50cyBgKDEwLCAyMClgIGFuZCBgTGAgd2l0aCBhcmd1bWVudHMgYCgzMCwgNDApYC4gVXBwZXJjYXNlIGxldHRlciBjb21tYW5kcyBleHByZXNzIGNvb3JkaW5hdGVzIGluIGFic29sdXRlIHRlcm1zLCB3aGlsZSBsb3dlcmNhc2UgY29tbWFuZHMgZXhwcmVzcyB0aGVtIGluIHJlbGF0aXZlIHRlcm1zIGZyb20gdGhlIG1vc3QgcmVjZW50bHkgZGVjbGFyZWQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgIyA8cD5IZXJlIGlzIHNob3J0IGxpc3Qgb2YgY29tbWFuZHMgYXZhaWxhYmxlLCBmb3IgbW9yZSBkZXRhaWxzIHNlZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcIiB0aXRsZT1cIkRldGFpbHMgb2YgYSBwYXRoJ3MgZGF0YSBhdHRyaWJ1dGUncyBmb3JtYXQgYXJlIGRlc2NyaWJlZCBpbiB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXCI+U1ZHIHBhdGggc3RyaW5nIGZvcm1hdDwvYT4gb3IgPGEgaHJlZj1cImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NWRy9UdXRvcmlhbC9QYXRoc1wiPmFydGljbGUgYWJvdXQgcGF0aCBzdHJpbmdzIGF0IE1ETjwvYT4uPC9wPlxuICAgICAjIDx0YWJsZT48dGhlYWQ+PHRyPjx0aD5Db21tYW5kPC90aD48dGg+TmFtZTwvdGg+PHRoPlBhcmFtZXRlcnM8L3RoPjwvdHI+PC90aGVhZD48dGJvZHk+XG4gICAgICMgPHRyPjx0ZD5NPC90ZD48dGQ+bW92ZXRvPC90ZD48dGQ+KHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+WjwvdGQ+PHRkPmNsb3NlcGF0aDwvdGQ+PHRkPihub25lKTwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkw8L3RkPjx0ZD5saW5ldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5IPC90ZD48dGQ+aG9yaXpvbnRhbCBsaW5ldG88L3RkPjx0ZD54KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPlY8L3RkPjx0ZD52ZXJ0aWNhbCBsaW5ldG88L3RkPjx0ZD55KzwvdGQ+PC90cj5cbiAgICAgIyA8dHI+PHRkPkM8L3RkPjx0ZD5jdXJ2ZXRvPC90ZD48dGQ+KHgxIHkxIHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UzwvdGQ+PHRkPnNtb290aCBjdXJ2ZXRvPC90ZD48dGQ+KHgyIHkyIHggeSkrPC90ZD48L3RyPlxuICAgICAjIDx0cj48dGQ+UTwvdGQ+PHRkPnF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeDEgeTEgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5UPC90ZD48dGQ+c21vb3RoIHF1YWRyYXRpYyBCw6l6aWVyIGN1cnZldG88L3RkPjx0ZD4oeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5BPC90ZD48dGQ+ZWxsaXB0aWNhbCBhcmM8L3RkPjx0ZD4ocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSs8L3RkPjwvdHI+XG4gICAgICMgPHRyPjx0ZD5SPC90ZD48dGQ+PGEgaHJlZj1cImh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2F0bXVsbOKAk1JvbV9zcGxpbmUjQ2F0bXVsbC5FMi44MC45M1JvbV9zcGxpbmVcIj5DYXRtdWxsLVJvbSBjdXJ2ZXRvPC9hPio8L3RkPjx0ZD54MSB5MSAoeCB5KSs8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPlxuICAgICAqICogX0NhdG11bGwtUm9tIGN1cnZldG9fIGlzIGEgbm90IHN0YW5kYXJkIFNWRyBjb21tYW5kIGFuZCBhZGRlZCB0byBtYWtlIGxpZmUgZWFzaWVyLlxuICAgICAqIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gYSBwYXRoIGNvbnNpc3RzIG9mIG9ubHkgdGhyZWUgY29tbWFuZHM6IGBNMTAsMTBS4oCmemAuIEluIHRoaXMgY2FzZSB0aGUgcGF0aCBjb25uZWN0cyBiYWNrIHRvIGl0cyBzdGFydGluZyBwb2ludC5cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBjID0gcGFwZXIucGF0aChcIk0xMCAxMEw5MCA5MFwiKTtcbiAgICAgfCAvLyBkcmF3IGEgZGlhZ29uYWwgbGluZTpcbiAgICAgfCAvLyBtb3ZlIHRvIDEwLDEwLCBsaW5lIHRvIDkwLDkwXG4gICAgXFwqL1xuICAgIHByb3RvLnBhdGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgaWYgKGlzKGQsIFwib2JqZWN0XCIpICYmICFpcyhkLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0gZDtcbiAgICAgICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgICAgICBhdHRyID0ge2Q6IGR9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0aFwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5nXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgZ3JvdXAgZWxlbWVudFxuICAgICAqKlxuICAgICAtIHZhcmFyZ3MgKOKApikgI29wdGlvbmFsIGVsZW1lbnRzIHRvIG5lc3Qgd2l0aGluIHRoZSBncm91cFxuICAgICA9IChvYmplY3QpIHRoZSBgZ2AgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZyhjMiwgYzEpOyAvLyBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIGRpZmZlcmVudFxuICAgICAqIG9yXG4gICAgIHwgdmFyIGMxID0gcGFwZXIuY2lyY2xlKCksXG4gICAgIHwgICAgIGMyID0gcGFwZXIucmVjdCgpLFxuICAgICB8ICAgICBnID0gcGFwZXIuZygpO1xuICAgICB8IGcuYWRkKGMyLCBjMSk7XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5ncm91cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2VlIEBQYXBlci5nXG4gICAgXFwqL1xuICAgIHByb3RvLmdyb3VwID0gcHJvdG8uZyA9IGZ1bmN0aW9uIChmaXJzdCkge1xuICAgICAgICB2YXIgYXR0cixcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbChcImdcIik7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZmlyc3QgJiYgIWZpcnN0LnR5cGUpIHtcbiAgICAgICAgICAgIGVsLmF0dHIoZmlyc3QpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLmFkZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuc3ZnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgbmVzdGVkIFNWRyBlbGVtZW50LlxuICAgICAtIHggKG51bWJlcikgQG9wdGlvbmFsIFggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB5IChudW1iZXIpIEBvcHRpb25hbCBZIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gd2lkdGggKG51bWJlcikgQG9wdGlvbmFsIHdpZHRoIG9mIHRoZSBlbGVtZW50XG4gICAgIC0gaGVpZ2h0IChudW1iZXIpIEBvcHRpb25hbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB2YnggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggWFxuICAgICAtIHZieSAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBZXG4gICAgIC0gdmJ3IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IHdpZHRoXG4gICAgIC0gdmJoIChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IGhlaWdodFxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgc3ZnYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnN2ZyA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB2YngsIHZieSwgdmJ3LCB2YmgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSAmJiB5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YnggIT0gbnVsbCAmJiB2YnkgIT0gbnVsbCAmJiB2YncgIT0gbnVsbCAmJiB2YmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzLnZpZXdCb3ggPSBbdmJ4LCB2YnksIHZidywgdmJoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbChcInN2Z1wiLCBhdHRycyk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIubWFza1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRXF1aXZhbGVudCBpbiBiZWhhdmlvdXIgdG8gQFBhcGVyLmcsIGV4Y2VwdCBpdOKAmXMgYSBtYXNrLlxuICAgICAqKlxuICAgICA9IChvYmplY3QpIHRoZSBgbWFza2AgZWxlbWVudFxuICAgICAqKlxuICAgIFxcKi9cbiAgICBwcm90by5tYXNrID0gZnVuY3Rpb24gKGZpcnN0KSB7XG4gICAgICAgIHZhciBhdHRyLFxuICAgICAgICAgICAgZWwgPSB0aGlzLmVsKFwibWFza1wiKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBmaXJzdCAmJiAhZmlyc3QudHlwZSkge1xuICAgICAgICAgICAgZWwuYXR0cihmaXJzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWwuYWRkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wdHJuXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IGluIGJlaGF2aW91ciB0byBAUGFwZXIuZywgZXhjZXB0IGl04oCZcyBhIHBhdHRlcm4uXG4gICAgIC0geCAobnVtYmVyKSBAb3B0aW9uYWwgWCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHkgKG51bWJlcikgQG9wdGlvbmFsIFkgb2YgdGhlIGVsZW1lbnRcbiAgICAgLSB3aWR0aCAobnVtYmVyKSBAb3B0aW9uYWwgd2lkdGggb2YgdGhlIGVsZW1lbnRcbiAgICAgLSBoZWlnaHQgKG51bWJlcikgQG9wdGlvbmFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGBwYXR0ZXJuYCBlbGVtZW50XG4gICAgICoqXG4gICAgXFwqL1xuICAgIHByb3RvLnB0cm4gPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgdngsIHZ5LCB2dywgdmgpIHtcbiAgICAgICAgaWYgKGlzKHgsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyID0ge3BhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwifTtcbiAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgYXR0ci54ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgICAgICAgYXR0ci55ID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnggIT0gbnVsbCAmJiB2eSAhPSBudWxsICYmIHZ3ICE9IG51bGwgJiYgdmggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt2eCwgdnksIHZ3LCB2aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHIudmlld0JveCA9IFt4IHx8IDAsIHkgfHwgMCwgd2lkdGggfHwgMCwgaGVpZ2h0IHx8IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicGF0dGVyblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci51c2VcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8dXNlPiBlbGVtZW50LlxuICAgICAtIGlkIChzdHJpbmcpIEBvcHRpb25hbCBpZCBvZiBlbGVtZW50IHRvIGxpbmtcbiAgICAgKiBvclxuICAgICAtIGlkIChFbGVtZW50KSBAb3B0aW9uYWwgZWxlbWVudCB0byBsaW5rXG4gICAgICoqXG4gICAgID0gKG9iamVjdCkgdGhlIGB1c2VgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8udXNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaWQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZC5hdHRyKFwiaWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWQuYXR0cih7aWQ6IFNuYXAuXy5pZChpZCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBpZC5hdHRyKFwiaWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoU3RyaW5nKGlkKS5jaGFyQXQoKSA9PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ1c2VcIiwge1wieGxpbms6aHJlZlwiOiBcIiNcIiArIGlkfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUudXNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5zeW1ib2xcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENyZWF0ZXMgYSA8c3ltYm9sPiBlbGVtZW50LlxuICAgICAtIHZieCAobnVtYmVyKSBAb3B0aW9uYWwgdmlld2JveCBYXG4gICAgIC0gdmJ5IChudW1iZXIpIEBvcHRpb25hbCB2aWV3Ym94IFlcbiAgICAgLSB2YncgKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggd2lkdGhcbiAgICAgLSB2YmggKG51bWJlcikgQG9wdGlvbmFsIHZpZXdib3ggaGVpZ2h0XG4gICAgID0gKG9iamVjdCkgdGhlIGBzeW1ib2xgIGVsZW1lbnRcbiAgICAgKipcbiAgICBcXCovXG4gICAgcHJvdG8uc3ltYm9sID0gZnVuY3Rpb24gKHZ4LCB2eSwgdncsIHZoKSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmICh2eCAhPSBudWxsICYmIHZ5ICE9IG51bGwgJiYgdncgIT0gbnVsbCAmJiB2aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyLnZpZXdCb3ggPSBbdngsIHZ5LCB2dywgdmhdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJzeW1ib2xcIiwgYXR0cik7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIudGV4dFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogRHJhd3MgYSB0ZXh0IHN0cmluZ1xuICAgICAqKlxuICAgICAtIHggKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uXG4gICAgIC0geSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb25cbiAgICAgLSB0ZXh0IChzdHJpbmd8YXJyYXkpIFRoZSB0ZXh0IHN0cmluZyB0byBkcmF3IG9yIGFycmF5IG9mIHN0cmluZ3MgdG8gbmVzdCB3aXRoaW4gc2VwYXJhdGUgYDx0c3Bhbj5gIGVsZW1lbnRzXG4gICAgID0gKG9iamVjdCkgdGhlIGB0ZXh0YCBlbGVtZW50XG4gICAgICoqXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgdDEgPSBwYXBlci50ZXh0KDUwLCA1MCwgXCJTbmFwXCIpO1xuICAgICB8IHZhciB0MiA9IHBhcGVyLnRleHQoNTAsIDUwLCBbXCJTXCIsXCJuXCIsXCJhXCIsXCJwXCJdKTtcbiAgICAgfCAvLyBUZXh0IHBhdGggdXNhZ2VcbiAgICAgfCB0MS5hdHRyKHt0ZXh0cGF0aDogXCJNMTAsMTBMMTAwLDEwMFwifSk7XG4gICAgIHwgLy8gb3JcbiAgICAgfCB2YXIgcHRoID0gcGFwZXIucGF0aChcIk0xMCwxMEwxMDAsMTAwXCIpO1xuICAgICB8IHQxLmF0dHIoe3RleHRwYXRoOiBwdGh9KTtcbiAgICBcXCovXG4gICAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uICh4LCB5LCB0ZXh0KSB7XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyh4LCBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0IHx8IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJ0ZXh0XCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLmxpbmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIERyYXdzIGEgbGluZVxuICAgICAqKlxuICAgICAtIHgxIChudW1iZXIpIHggY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRcbiAgICAgLSB5MSAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0XG4gICAgIC0geDIgKG51bWJlcikgeCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBlbmRcbiAgICAgLSB5MiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgcG9zaXRpb24gb2YgdGhlIGVuZFxuICAgICA9IChvYmplY3QpIHRoZSBgbGluZWAgZWxlbWVudFxuICAgICAqKlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIHQxID0gcGFwZXIubGluZSg1MCwgNTAsIDEwMCwgMTAwKTtcbiAgICBcXCovXG4gICAgcHJvdG8ubGluZSA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICBpZiAoaXMoeDEsIFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBhdHRyID0geDE7XG4gICAgICAgIH0gZWxzZSBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtcbiAgICAgICAgICAgICAgICB4MTogeDEsXG4gICAgICAgICAgICAgICAgeDI6IHgyLFxuICAgICAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgICAgICB5MjogeTJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJsaW5lXCIsIGF0dHIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFBhcGVyLnBvbHlsaW5lXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlsaW5lXG4gICAgICoqXG4gICAgIC0gcG9pbnRzIChhcnJheSkgYXJyYXkgb2YgcG9pbnRzXG4gICAgICogb3JcbiAgICAgLSB2YXJhcmdzICjigKYpIHBvaW50c1xuICAgICA9IChvYmplY3QpIHRoZSBgcG9seWxpbmVgIGVsZW1lbnRcbiAgICAgKipcbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBwMSA9IHBhcGVyLnBvbHlsaW5lKFsxMCwgMTAsIDEwMCwgMTAwXSk7XG4gICAgIHwgdmFyIHAyID0gcGFwZXIucG9seWxpbmUoMTAsIDEwLCAxMDAsIDEwMCk7XG4gICAgXFwqL1xuICAgIHByb3RvLnBvbHlsaW5lID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgICAgaWYgKGlzKHBvaW50cywgXCJvYmplY3RcIikgJiYgIWlzKHBvaW50cywgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgYXR0ciA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0ciA9IHtwb2ludHM6IHBvaW50c307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwoXCJwb2x5bGluZVwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBQYXBlci5wb2x5Z29uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24uIFNlZSBAUGFwZXIucG9seWxpbmVcbiAgICBcXCovXG4gICAgcHJvdG8ucG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgIGlmIChpcyhwb2ludHMsIFwib2JqZWN0XCIpICYmICFpcyhwb2ludHMsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGF0dHIgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHIgPSB7cG9pbnRzOiBwb2ludHN9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsKFwicG9seWdvblwiLCBhdHRyKTtcbiAgICB9O1xuICAgIC8vIGdyYWRpZW50c1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkID0gU25hcC5fLiQ7XG4gICAgICAgIC8vIGdyYWRpZW50cycgaGVscGVyc1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogUmV0dXJucyBhcnJheSBvZiBncmFkaWVudCBzdG9wcyBlbGVtZW50cy5cbiAgICAgICAgID0gKGFycmF5KSB0aGUgc3RvcHMgYXJyYXkuXG4gICAgICAgIFxcKi9cbiAgICAgICAgZnVuY3Rpb24gR3N0b3BzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0QWxsKFwic3RvcFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuYWRkU3RvcFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogT25seSBmb3IgZ3JhZGllbnRzIVxuICAgICAgICAgKiBBZGRzIGFub3RoZXIgc3RvcCB0byB0aGUgZ3JhZGllbnQuXG4gICAgICAgICAtIGNvbG9yIChzdHJpbmcpIHN0b3BzIGNvbG9yXG4gICAgICAgICAtIG9mZnNldCAobnVtYmVyKSBzdG9wcyBvZmZzZXQgMC4uMTAwXG4gICAgICAgICA9IChvYmplY3QpIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBmdW5jdGlvbiBHYWRkU3RvcChjb2xvciwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9ICQoXCJzdG9wXCIpLFxuICAgICAgICAgICAgICAgIGF0dHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogK29mZnNldCArIFwiJVwiXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbG9yID0gU25hcC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBhdHRyW1wic3RvcC1jb2xvclwiXSA9IGNvbG9yLmhleDtcbiAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgIGF0dHJbXCJzdG9wLW9wYWNpdHlcIl0gPSBjb2xvci5vcGFjaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJChzdG9wLCBhdHRyKTtcbiAgICAgICAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMoKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRlZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcE9mZnNldCA9IHBhcnNlRmxvYXQoc3RvcHNbaV0uYXR0cihcIm9mZnNldFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BPZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShzdG9wLCBzdG9wc1tpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gR2dldEJCb3goKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwibGluZWFyR3JhZGllbnRcIikge1xuICAgICAgICAgICAgICAgIHZhciB4MSA9ICQodGhpcy5ub2RlLCBcIngxXCIpIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIHgyID0gJCh0aGlzLm5vZGUsIFwieDJcIikgfHwgMSxcbiAgICAgICAgICAgICAgICAgICAgeTEgPSAkKHRoaXMubm9kZSwgXCJ5MVwiKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB5MiA9ICQodGhpcy5ub2RlLCBcInkyXCIpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNuYXAuXy5ib3goeDEsIHkxLCBtYXRoLmFicyh4MiAtIHgxKSwgbWF0aC5hYnMoeTIgLSB5MSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSB0aGlzLm5vZGUuY3ggfHwgLjUsXG4gICAgICAgICAgICAgICAgICAgIGN5ID0gdGhpcy5ub2RlLmN5IHx8IC41LFxuICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5ub2RlLnIgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gU25hcC5fLmJveChjeCAtIHIsIGN5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxcXG4gICAgICAgICAqIEVsZW1lbnQuc2V0U3RvcHNcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIE9ubHkgZm9yIGdyYWRpZW50cyFcbiAgICAgICAgICogVXBkYXRlcyBzdG9wcyBvZiB0aGUgZ3JhZGllbnQgYmFzZWQgb24gcGFzc2VkIGdyYWRpZW50IGRlc2NyaXB0b3IuIFNlZSBAUHBhZXIuZ3JhZGllbnRcbiAgICAgICAgIC0gc3RyIChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3IgcGFydCBhZnRlciBgKClgLlxuICAgICAgICAgPSAob2JqZWN0KSBncmFkaWVudCBlbGVtZW50XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJsKDAsIDAsIDEsIDEpIzAwMC0jZjAwLSNmZmZcIik7XG4gICAgICAgICB8IGcuc2V0U3RvcHMoXCIjZmZmLSMwMDAtI2YwMC0jZmMwXCIpO1xuICAgICAgICBcXCovXG4gICAgICAgIGZ1bmN0aW9uIEdzZXRTdG9wcyhzdHIpIHtcbiAgICAgICAgICAgIHZhciBncmFkID0gc3RyLFxuICAgICAgICAgICAgICAgIHN0b3BzID0gdGhpcy5zdG9wcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBcImwoMCwwLDAsMSlcIiArIHN0cikuZmlyc3REZWZpbmVkKCkuc3RvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVNuYXAuaXMoZ3JhZCwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JhZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBTbmFwLmNvbG9yKGdyYWRbaV0uY29sb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IHtcIm9mZnNldFwiOiBncmFkW2ldLm9mZnNldCArIFwiJVwifTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3AtY29sb3JcIl0gPSBjb2xvci5oZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvci5vcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cltcInN0b3Atb3BhY2l0eVwiXSA9IGNvbG9yLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHNbaV0uYXR0cihhdHRyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSBzdG9wcy5sZW5ndGg7IGkgPCBncmFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTdG9wKGdyYWRbaV0uY29sb3IsIGdyYWRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdyYWRpZW50KGRlZnMsIHN0cikge1xuICAgICAgICAgICAgdmFyIGdyYWQgPSBldmUoXCJzbmFwLnV0aWwuZ3JhZC5wYXJzZVwiLCBudWxsLCBzdHIpLmZpcnN0RGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIGVsO1xuICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkLnBhcmFtcy51bnNoaWZ0KGRlZnMpO1xuICAgICAgICAgICAgaWYgKGdyYWQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwibFwiKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBncmFkaWVudExpbmVhci5hcHBseSgwLCBncmFkLnBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZ3JhZGllbnRSYWRpYWwuYXBwbHkoMCwgZ3JhZC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYWQudHlwZSAhPSBncmFkLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICQoZWwubm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdG9wcyA9IGdyYWQuc3RvcHMsXG4gICAgICAgICAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgICAgICAgZWwuYWRkU3RvcChzdG9wLmNvbG9yLCBzdG9wLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRMaW5lYXIoZGVmcywgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwibGluZWFyR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGVsLnNldFN0b3BzID0gR3NldFN0b3BzO1xuICAgICAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAkKGVsLm5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgICAgICAgICAgeTI6IHkyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3JhZGllbnRSYWRpYWwoZGVmcywgY3gsIGN5LCByLCBmeCwgZnkpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IFNuYXAuXy5tYWtlKFwicmFkaWFsR3JhZGllbnRcIiwgZGVmcyk7XG4gICAgICAgICAgICBlbC5zdG9wcyA9IEdzdG9wcztcbiAgICAgICAgICAgIGVsLmFkZFN0b3AgPSBHYWRkU3RvcDtcbiAgICAgICAgICAgIGVsLmdldEJCb3ggPSBHZ2V0QkJveDtcbiAgICAgICAgICAgIGlmIChjeCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnggIT0gbnVsbCAmJiBmeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgJChlbC5ub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ4OiBmeCxcbiAgICAgICAgICAgICAgICAgICAgZnk6IGZ5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5ncmFkaWVudFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgICAgICoqXG4gICAgICAgICAtIGdyYWRpZW50IChzdHJpbmcpIGdyYWRpZW50IGRlc2NyaXB0b3JcbiAgICAgICAgID4gR3JhZGllbnQgRGVzY3JpcHRvclxuICAgICAgICAgKiBUaGUgZ3JhZGllbnQgZGVzY3JpcHRvciBpcyBhbiBleHByZXNzaW9uIGZvcm1hdHRlZCBhc1xuICAgICAgICAgKiBmb2xsb3dzOiBgPHR5cGU+KDxjb29yZHM+KTxjb2xvcnM+YC4gIFRoZSBgPHR5cGU+YCBjYW4gYmVcbiAgICAgICAgICogZWl0aGVyIGxpbmVhciBvciByYWRpYWwuICBUaGUgdXBwZXJjYXNlIGBMYCBvciBgUmAgbGV0dGVyc1xuICAgICAgICAgKiBpbmRpY2F0ZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBvZmZzZXQgZnJvbSB0aGUgU1ZHIHN1cmZhY2UuXG4gICAgICAgICAqIExvd2VyY2FzZSBgbGAgb3IgYHJgIGxldHRlcnMgaW5kaWNhdGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICogY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZ3JhZGllbnQgaXNcbiAgICAgICAgICogYXBwbGllZC4gIENvb3JkaW5hdGVzIHNwZWNpZnkgYSBsaW5lYXIgZ3JhZGllbnQgdmVjdG9yIGFzXG4gICAgICAgICAqIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAsIG9yIGEgcmFkaWFsIGdyYWRpZW50IGFzIGBjeGAsIGBjeWAsXG4gICAgICAgICAqIGByYCBhbmQgb3B0aW9uYWwgYGZ4YCwgYGZ5YCBzcGVjaWZ5aW5nIGEgZm9jYWwgcG9pbnQgYXdheVxuICAgICAgICAgKiBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gU3BlY2lmeSBgPGNvbG9ycz5gIGFzIGEgbGlzdFxuICAgICAgICAgKiBvZiBkYXNoLXNlcGFyYXRlZCBDU1MgY29sb3IgdmFsdWVzLiAgRWFjaCBjb2xvciBtYXkgYmVcbiAgICAgICAgICogZm9sbG93ZWQgYnkgYSBjdXN0b20gb2Zmc2V0IHZhbHVlLCBzZXBhcmF0ZWQgd2l0aCBhIGNvbG9uXG4gICAgICAgICAqIGNoYXJhY3Rlci5cbiAgICAgICAgID4gRXhhbXBsZXNcbiAgICAgICAgICogTGluZWFyIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRvcC1sZWZ0IGNvcm5lciB0byBib3R0b20tcmlnaHRcbiAgICAgICAgICogY29ybmVyLCBmcm9tIGJsYWNrIHRocm91Z2ggcmVkIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwibCgwLCAwLCAxLCAxKSMwMDAtI2YwMC0jZmZmXCIpO1xuICAgICAgICAgKiBMaW5lYXIgZ3JhZGllbnQsIGFic29sdXRlIGZyb20gKDAsIDApIHRvICgxMDAsIDEwMCksIGZyb20gYmxhY2tcbiAgICAgICAgICogdGhyb3VnaCByZWQgYXQgMjUlIHRvIHdoaXRlOlxuICAgICAgICAgfCB2YXIgZyA9IHBhcGVyLmdyYWRpZW50KFwiTCgwLCAwLCAxMDAsIDEwMCkjMDAwLSNmMDA6MjUtI2ZmZlwiKTtcbiAgICAgICAgICogUmFkaWFsIGdyYWRpZW50LCByZWxhdGl2ZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgd2l0aCByYWRpdXNcbiAgICAgICAgICogaGFsZiB0aGUgd2lkdGgsIGZyb20gYmxhY2sgdG8gd2hpdGU6XG4gICAgICAgICB8IHZhciBnID0gcGFwZXIuZ3JhZGllbnQoXCJyKDAuNSwgMC41LCAwLjUpIzAwMC0jZmZmXCIpO1xuICAgICAgICAgKiBUbyBhcHBseSB0aGUgZ3JhZGllbnQ6XG4gICAgICAgICB8IHBhcGVyLmNpcmNsZSg1MCwgNTAsIDQwKS5hdHRyKHtcbiAgICAgICAgIHwgICAgIGZpbGw6IGdcbiAgICAgICAgIHwgfSk7XG4gICAgICAgICA9IChvYmplY3QpIHRoZSBgZ3JhZGllbnRgIGVsZW1lbnRcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by5ncmFkaWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBncmFkaWVudCh0aGlzLmRlZnMsIHN0cik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50TGluZWFyID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRMaW5lYXIodGhpcy5kZWZzLCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvLmdyYWRpZW50UmFkaWFsID0gZnVuY3Rpb24gKGN4LCBjeSwgciwgZngsIGZ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZGllbnRSYWRpYWwodGhpcy5kZWZzLCBjeCwgY3ksIHIsIGZ4LCBmeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qXFxcbiAgICAgICAgICogUGFwZXIudG9TdHJpbmdcbiAgICAgICAgIFsgbWV0aG9kIF1cbiAgICAgICAgICoqXG4gICAgICAgICAqIFJldHVybnMgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgID0gKHN0cmluZykgU1ZHIGNvZGUgZm9yIHRoZSBAUGFwZXJcbiAgICAgICAgXFwqL1xuICAgICAgICBwcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgICAgICAgICBkID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICAgICAgc3ZnID0gdGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICAgICAgICByZXM7XG4gICAgICAgICAgICBmLmFwcGVuZENoaWxkKGQpO1xuICAgICAgICAgICAgZC5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICAgICAgU25hcC5fLiQoc3ZnLCB7eG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0pO1xuICAgICAgICAgICAgcmVzID0gZC5pbm5lckhUTUw7XG4gICAgICAgICAgICBmLnJlbW92ZUNoaWxkKGYuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICAvKlxcXG4gICAgICAgICAqIFBhcGVyLnRvRGF0YVVSTFxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmV0dXJucyBTVkcgY29kZSBmb3IgdGhlIEBQYXBlciBhcyBEYXRhIFVSSSBzdHJpbmcuXG4gICAgICAgICA9IChzdHJpbmcpIERhdGEgVVJJIHN0cmluZ1xuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLnRvRGF0YVVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmJ0b2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGhpcykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLypcXFxuICAgICAgICAgKiBQYXBlci5jbGVhclxuICAgICAgICAgWyBtZXRob2QgXVxuICAgICAgICAgKipcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgY2hpbGQgbm9kZXMgb2YgdGhlIHBhcGVyLCBleGNlcHQgPGRlZnM+LlxuICAgICAgICBcXCovXG4gICAgICAgIHByb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0O1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lICE9IFwiZGVmc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm90by5jbGVhci5jYWxsKHtub2RlOiBub2RlfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG59KTtcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuU25hcC5wbHVnaW4oZnVuY3Rpb24gKFNuYXAsIEVsZW1lbnQsIFBhcGVyLCBnbG9iKSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBjbG9uZSA9IFNuYXAuXy5jbG9uZSxcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBwMnMgPSAvLD8oW2Etel0pLD8vZ2ksXG4gICAgICAgIHRvRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgICBtYXRoID0gTWF0aCxcbiAgICAgICAgUEkgPSBtYXRoLlBJLFxuICAgICAgICBtbWluID0gbWF0aC5taW4sXG4gICAgICAgIG1tYXggPSBtYXRoLm1heCxcbiAgICAgICAgcG93ID0gbWF0aC5wb3csXG4gICAgICAgIGFicyA9IG1hdGguYWJzO1xuICAgIGZ1bmN0aW9uIHBhdGhzKHBzKSB7XG4gICAgICAgIHZhciBwID0gcGF0aHMucHMgPSBwYXRocy5wcyB8fCB7fTtcbiAgICAgICAgaWYgKHBbcHNdKSB7XG4gICAgICAgICAgICBwW3BzXS5zbGVlcCA9IDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBbcHNdID0ge1xuICAgICAgICAgICAgICAgIHNsZWVwOiAxMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcCkgaWYgKHBbaGFzXShrZXkpICYmIGtleSAhPSBwcykge1xuICAgICAgICAgICAgICAgIHBba2V5XS5zbGVlcC0tO1xuICAgICAgICAgICAgICAgICFwW2tleV0uc2xlZXAgJiYgZGVsZXRlIHBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwW3BzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm94KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICAgICAgeCA9IHkgPSB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHdpZHRoID0geC53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHggKyB3aWR0aCxcbiAgICAgICAgICAgIHkyOiB5ICsgaGVpZ2h0LFxuICAgICAgICAgICAgY3g6IHggKyB3aWR0aCAvIDIsXG4gICAgICAgICAgICBjeTogeSArIGhlaWdodCAvIDIsXG4gICAgICAgICAgICByMTogbWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcjI6IG1hdGgubWF4KHdpZHRoLCBoZWlnaHQpIC8gMixcbiAgICAgICAgICAgIHIwOiBtYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgcGF0aDogcmVjdFBhdGgoeCwgeSwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgICAgICB2YjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLmpvaW4oXCIgXCIpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luKFwiLFwiKS5yZXBsYWNlKHAycywgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aENsb25lKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcmVzID0gY2xvbmUocGF0aEFycmF5KTtcbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmV6bGVuKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kRG90c0F0U2VnbWVudChwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeSxcbiAgICAgICAgICAgICAgICBnZXRUb3RMZW4ocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIGxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlbmd0aEZhY3RvcnkoaXN0b3RhbCwgc3VicGF0aCkge1xuICAgICAgICBmdW5jdGlvbiBPKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICsoK3ZhbCkudG9GaXhlZCgzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5fLmNhY2hlcihmdW5jdGlvbiAocGF0aCwgbGVuZ3RoLCBvbmx5c3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmF0dHIoXCJkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgICAgICB2YXIgeCwgeSwgcCwgbCwgc3AgPSBcIlwiLCBzdWJwYXRocyA9IHt9LCBwb2ludCxcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcCA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBbMF0gPT0gXCJNXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gK3BbMl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGdldFBvaW50QXRTZWdtZW50TGVuZ3RoKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVuICsgbCA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnBhdGggJiYgIXN1YnBhdGhzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBnZXRQb2ludEF0U2VnbWVudExlbmd0aCh4LCB5LCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCBwWzZdLCBsZW5ndGggLSBsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwICs9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDXCIgKyBPKHBvaW50LnN0YXJ0LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnN0YXJ0LnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50Lm0ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubS55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlzdGFydCkge3JldHVybiBzcDt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicGF0aHMuc3RhcnQgPSBzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNXCIgKyBPKHBvaW50LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBvaW50LnkpICsgXCJDXCIgKyBPKHBvaW50Lm4ueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQubi55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTyhwb2ludC5lbmQueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE8ocG9pbnQuZW5kLnkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPKHBbNl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtwWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArcFs2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXN0b3RhbCAmJiAhc3VicGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gZ2V0UG9pbnRBdFNlZ21lbnRMZW5ndGgoeCwgeSwgcFsxXSwgcFsyXSwgcFszXSwgcFs0XSwgcFs1XSwgcFs2XSwgbGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IGw7XG4gICAgICAgICAgICAgICAgICAgIHggPSArcFs1XTtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICtwWzZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcCArPSBwLnNoaWZ0KCkgKyBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicGF0aHMuZW5kID0gc3A7XG4gICAgICAgICAgICBwb2ludCA9IGlzdG90YWwgPyBsZW4gOiBzdWJwYXRoID8gc3VicGF0aHMgOiBmaW5kRG90c0F0U2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSwgbnVsbCwgU25hcC5fLmNsb25lKTtcbiAgICB9XG4gICAgdmFyIGdldFRvdGFsTGVuZ3RoID0gZ2V0TGVuZ3RoRmFjdG9yeSgxKSxcbiAgICAgICAgZ2V0UG9pbnRBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoKSxcbiAgICAgICAgZ2V0U3VicGF0aHNBdExlbmd0aCA9IGdldExlbmd0aEZhY3RvcnkoMCwgMSk7XG4gICAgZnVuY3Rpb24gZmluZERvdHNBdFNlZ21lbnQocDF4LCBwMXksIGMxeCwgYzF5LCBjMngsIGMyeSwgcDJ4LCBwMnksIHQpIHtcbiAgICAgICAgdmFyIHQxID0gMSAtIHQsXG4gICAgICAgICAgICB0MTMgPSBwb3codDEsIDMpLFxuICAgICAgICAgICAgdDEyID0gcG93KHQxLCAyKSxcbiAgICAgICAgICAgIHQyID0gdCAqIHQsXG4gICAgICAgICAgICB0MyA9IHQyICogdCxcbiAgICAgICAgICAgIHggPSB0MTMgKiBwMXggKyB0MTIgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgdDMgKiBwMngsXG4gICAgICAgICAgICB5ID0gdDEzICogcDF5ICsgdDEyICogMyAqIHQgKiBjMXkgKyB0MSAqIDMgKiB0ICogdCAqIGMyeSArIHQzICogcDJ5LFxuICAgICAgICAgICAgbXggPSBwMXggKyAyICogdCAqIChjMXggLSBwMXgpICsgdDIgKiAoYzJ4IC0gMiAqIGMxeCArIHAxeCksXG4gICAgICAgICAgICBteSA9IHAxeSArIDIgKiB0ICogKGMxeSAtIHAxeSkgKyB0MiAqIChjMnkgLSAyICogYzF5ICsgcDF5KSxcbiAgICAgICAgICAgIG54ID0gYzF4ICsgMiAqIHQgKiAoYzJ4IC0gYzF4KSArIHQyICogKHAyeCAtIDIgKiBjMnggKyBjMXgpLFxuICAgICAgICAgICAgbnkgPSBjMXkgKyAyICogdCAqIChjMnkgLSBjMXkpICsgdDIgKiAocDJ5IC0gMiAqIGMyeSArIGMxeSksXG4gICAgICAgICAgICBheCA9IHQxICogcDF4ICsgdCAqIGMxeCxcbiAgICAgICAgICAgIGF5ID0gdDEgKiBwMXkgKyB0ICogYzF5LFxuICAgICAgICAgICAgY3ggPSB0MSAqIGMyeCArIHQgKiBwMngsXG4gICAgICAgICAgICBjeSA9IHQxICogYzJ5ICsgdCAqIHAyeSxcbiAgICAgICAgICAgIGFscGhhID0gOTAgLSBtYXRoLmF0YW4yKG14IC0gbngsIG15IC0gbnkpICogMTgwIC8gUEk7XG4gICAgICAgIC8vIChteCA+IG54IHx8IG15IDwgbnkpICYmIChhbHBoYSArPSAxODApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBtOiB7eDogbXgsIHk6IG15fSxcbiAgICAgICAgICAgIG46IHt4OiBueCwgeTogbnl9LFxuICAgICAgICAgICAgc3RhcnQ6IHt4OiBheCwgeTogYXl9LFxuICAgICAgICAgICAgZW5kOiB7eDogY3gsIHk6IGN5fSxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZXppZXJCQm94KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGlmICghU25hcC5pcyhwMXgsIFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIHAxeCA9IFtwMXgsIHAxeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCBwMngsIHAyeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJib3ggPSBjdXJ2ZURpbS5hcHBseShudWxsLCBwMXgpO1xuICAgICAgICByZXR1cm4gYm94KFxuICAgICAgICAgICAgYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWluLnksXG4gICAgICAgICAgICBiYm94Lm1heC54IC0gYmJveC5taW4ueCxcbiAgICAgICAgICAgIGJib3gubWF4LnkgLSBiYm94Lm1pbi55XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVCQm94KGJib3gsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuICB4ID49IGJib3gueCAmJlxuICAgICAgICAgICAgICAgIHggPD0gYmJveC54ICsgYmJveC53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHkgPj0gYmJveC55ICYmXG4gICAgICAgICAgICAgICAgeSA8PSBiYm94LnkgKyBiYm94LmhlaWdodDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCQm94SW50ZXJzZWN0KGJib3gxLCBiYm94Mikge1xuICAgICAgICBiYm94MSA9IGJveChiYm94MSk7XG4gICAgICAgIGJib3gyID0gYm94KGJib3gyKTtcbiAgICAgICAgcmV0dXJuIGlzUG9pbnRJbnNpZGVCQm94KGJib3gyLCBiYm94MS54LCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngsIGJib3gxLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDIsIGJib3gxLngyLCBiYm94MS55MilcbiAgICAgICAgICAgIHx8IGlzUG9pbnRJbnNpZGVCQm94KGJib3gxLCBiYm94Mi54LCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55KVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngsIGJib3gyLnkyKVxuICAgICAgICAgICAgfHwgaXNQb2ludEluc2lkZUJCb3goYmJveDEsIGJib3gyLngyLCBiYm94Mi55MilcbiAgICAgICAgICAgIHx8IChiYm94MS54IDwgYmJveDIueDIgJiYgYmJveDEueCA+IGJib3gyLnhcbiAgICAgICAgICAgICAgICB8fCBiYm94Mi54IDwgYmJveDEueDIgJiYgYmJveDIueCA+IGJib3gxLngpXG4gICAgICAgICAgICAmJiAoYmJveDEueSA8IGJib3gyLnkyICYmIGJib3gxLnkgPiBiYm94Mi55XG4gICAgICAgICAgICAgICAgfHwgYmJveDIueSA8IGJib3gxLnkyICYmIGJib3gyLnkgPiBiYm94MS55KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzZTModCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgdmFyIHQxID0gLTMgKiBwMSArIDkgKiBwMiAtIDkgKiBwMyArIDMgKiBwNCxcbiAgICAgICAgICAgIHQyID0gdCAqIHQxICsgNiAqIHAxIC0gMTIgKiBwMiArIDYgKiBwMztcbiAgICAgICAgcmV0dXJuIHQgKiB0MiAtIDMgKiBwMSArIDMgKiBwMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmV6bGVuKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgeikge1xuICAgICAgICBpZiAoeiA9PSBudWxsKSB7XG4gICAgICAgICAgICB6ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB6ID0geiA+IDEgPyAxIDogeiA8IDAgPyAwIDogejtcbiAgICAgICAgdmFyIHoyID0geiAvIDIsXG4gICAgICAgICAgICBuID0gMTIsXG4gICAgICAgICAgICBUdmFsdWVzID0gWy0uMTI1MiwuMTI1MiwtLjM2NzgsLjM2NzgsLS41ODczLC41ODczLC0uNzY5OSwuNzY5OSwtLjkwNDEsLjkwNDEsLS45ODE2LC45ODE2XSxcbiAgICAgICAgICAgIEN2YWx1ZXMgPSBbMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLFxuICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdCA9IHoyICogVHZhbHVlc1tpXSArIHoyLFxuICAgICAgICAgICAgICAgIHhiYXNlID0gYmFzZTMoY3QsIHgxLCB4MiwgeDMsIHg0KSxcbiAgICAgICAgICAgICAgICB5YmFzZSA9IGJhc2UzKGN0LCB5MSwgeTIsIHkzLCB5NCksXG4gICAgICAgICAgICAgICAgY29tYiA9IHhiYXNlICogeGJhc2UgKyB5YmFzZSAqIHliYXNlO1xuICAgICAgICAgICAgc3VtICs9IEN2YWx1ZXNbaV0gKiBtYXRoLnNxcnQoY29tYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoyICogc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUb3RMZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsbCkge1xuICAgICAgICBpZiAobGwgPCAwIHx8IGJlemxlbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIDwgbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdCA9IDEsXG4gICAgICAgICAgICBzdGVwID0gdCAvIDIsXG4gICAgICAgICAgICB0MiA9IHQgLSBzdGVwLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGUgPSAuMDE7XG4gICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIHdoaWxlIChhYnMobCAtIGxsKSA+IGUpIHtcbiAgICAgICAgICAgIHN0ZXAgLz0gMjtcbiAgICAgICAgICAgIHQyICs9IChsIDwgbGwgPyAxIDogLTEpICogc3RlcDtcbiAgICAgICAgICAgIGwgPSBiZXpsZW4oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0Mik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1tYXgoeDEsIHgyKSA8IG1taW4oeDMsIHg0KSB8fFxuICAgICAgICAgICAgbW1pbih4MSwgeDIpID4gbW1heCh4MywgeDQpIHx8XG4gICAgICAgICAgICBtbWF4KHkxLCB5MikgPCBtbWluKHkzLCB5NCkgfHxcbiAgICAgICAgICAgIG1taW4oeTEsIHkyKSA+IG1tYXgoeTMsIHk0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnggPSAoeDEgKiB5MiAtIHkxICogeDIpICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogKHgzICogeTQgLSB5MyAqIHg0KSxcbiAgICAgICAgICAgIG55ID0gKHgxICogeTIgLSB5MSAqIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAqIHk0IC0geTMgKiB4NCksXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcblxuICAgICAgICBpZiAoIWRlbm9taW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHB4ID0gbnggLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB5ID0gbnkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIHB4MiA9ICtweC50b0ZpeGVkKDIpLFxuICAgICAgICAgICAgcHkyID0gK3B5LnRvRml4ZWQoMik7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHB4MiA8ICttbWluKHgxLCB4MikudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHgyID4gK21tYXgoeDEsIHgyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweDIgPCArbW1pbih4MywgeDQpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB4MiA+ICttbWF4KHgzLCB4NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyIDwgK21taW4oeTEsIHkyKS50b0ZpeGVkKDIpIHx8XG4gICAgICAgICAgICBweTIgPiArbW1heCh5MSwgeTIpLnRvRml4ZWQoMikgfHxcbiAgICAgICAgICAgIHB5MiA8ICttbWluKHkzLCB5NCkudG9GaXhlZCgyKSB8fFxuICAgICAgICAgICAgcHkyID4gK21tYXgoeTMsIHk0KS50b0ZpeGVkKDIpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7eDogcHgsIHk6IHB5fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXIoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyQ291bnQoYmV6MSwgYmV6Mikge1xuICAgICAgICByZXR1cm4gaW50ZXJIZWxwZXIoYmV6MSwgYmV6MiwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCkge1xuICAgICAgICB2YXIgYmJveDEgPSBiZXppZXJCQm94KGJlejEpLFxuICAgICAgICAgICAgYmJveDIgPSBiZXppZXJCQm94KGJlejIpO1xuICAgICAgICBpZiAoIWlzQkJveEludGVyc2VjdChiYm94MSwgYmJveDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsMSA9IGJlemxlbi5hcHBseSgwLCBiZXoxKSxcbiAgICAgICAgICAgIGwyID0gYmV6bGVuLmFwcGx5KDAsIGJlejIpLFxuICAgICAgICAgICAgbjEgPSB+fihsMSAvIDgpLFxuICAgICAgICAgICAgbjIgPSB+fihsMiAvIDgpLFxuICAgICAgICAgICAgZG90czEgPSBbXSxcbiAgICAgICAgICAgIGRvdHMyID0gW10sXG4gICAgICAgICAgICB4eSA9IHt9LFxuICAgICAgICAgICAgcmVzID0ganVzdENvdW50ID8gMCA6IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4xICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejEuY29uY2F0KGkgLyBuMSkpO1xuICAgICAgICAgICAgZG90czEucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMiArIDE7IGkrKykge1xuICAgICAgICAgICAgcCA9IGZpbmREb3RzQXRTZWdtZW50LmFwcGx5KDAsIGJlejIuY29uY2F0KGkgLyBuMikpO1xuICAgICAgICAgICAgZG90czIucHVzaCh7eDogcC54LCB5OiBwLnksIHQ6IGkgLyBuMn0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG4yOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGkgPSBkb3RzMVtpXSxcbiAgICAgICAgICAgICAgICAgICAgZGkxID0gZG90czFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkaiA9IGRvdHMyW2pdLFxuICAgICAgICAgICAgICAgICAgICBkajEgPSBkb3RzMltqICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIGNpID0gYWJzKGRpMS54IC0gZGkueCkgPCAuMDAxID8gXCJ5XCIgOiBcInhcIixcbiAgICAgICAgICAgICAgICAgICAgY2ogPSBhYnMoZGoxLnggLSBkai54KSA8IC4wMDEgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICBpcyA9IGludGVyc2VjdChkaS54LCBkaS55LCBkaTEueCwgZGkxLnksIGRqLngsIGRqLnksIGRqMS54LCBkajEueSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4eVtpcy54LnRvRml4ZWQoNCldID09IGlzLnkudG9GaXhlZCg0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeHlbaXMueC50b0ZpeGVkKDQpXSA9IGlzLnkudG9GaXhlZCg0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gZGkudCArIGFicygoaXNbY2ldIC0gZGlbY2ldKSAvIChkaTFbY2ldIC0gZGlbY2ldKSkgKiAoZGkxLnQgLSBkaS50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gZGoudCArIGFicygoaXNbY2pdIC0gZGpbY2pdKSAvIChkajFbY2pdIC0gZGpbY2pdKSkgKiAoZGoxLnQgLSBkai50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSAmJiB0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqdXN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyOiB0MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhJbnRlcnNlY3Rpb24ocGF0aDEsIHBhdGgyKSB7XG4gICAgICAgIHJldHVybiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aEludGVyc2VjdGlvbk51bWJlcihwYXRoMSwgcGF0aDIpIHtcbiAgICAgICAgcmV0dXJuIGludGVyUGF0aEhlbHBlcihwYXRoMSwgcGF0aDIsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlclBhdGhIZWxwZXIocGF0aDEsIHBhdGgyLCBqdXN0Q291bnQpIHtcbiAgICAgICAgcGF0aDEgPSBwYXRoMmN1cnZlKHBhdGgxKTtcbiAgICAgICAgcGF0aDIgPSBwYXRoMmN1cnZlKHBhdGgyKTtcbiAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MW0sIHkxbSwgeDJtLCB5Mm0sIGJlejEsIGJlejIsXG4gICAgICAgICAgICByZXMgPSBqdXN0Q291bnQgPyAwIDogW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhdGgxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwaSA9IHBhdGgxW2ldO1xuICAgICAgICAgICAgaWYgKHBpWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeDEgPSB4MW0gPSBwaVsxXTtcbiAgICAgICAgICAgICAgICB5MSA9IHkxbSA9IHBpWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGlbMF0gPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmV6MSA9IFt4MSwgeTFdLmNvbmNhdChwaS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYmV6MVs2XTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBiZXoxWzddO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlejEgPSBbeDEsIHkxLCB4MSwgeTEsIHgxbSwgeTFtLCB4MW0sIHkxbV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0geDFtO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IHkxbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcGF0aDIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGogPSBwYXRoMltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBqWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHgybSA9IHBqWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm0gPSBwalsyXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwalswXSA9PSBcIkNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyXS5jb25jYXQocGouc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gYmV6Mls2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IGJlejJbN107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlejIgPSBbeDIsIHkyLCB4MiwgeTIsIHgybSwgeTJtLCB4Mm0sIHkybV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5Mm07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVySGVscGVyKGJlejEsIGJlejIsIGp1c3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVzdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IGludHI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IGludHIubGVuZ3RoOyBrIDwga2s7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRyW2tdLnNlZ21lbnQxID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50cltrXS5zZWdtZW50MiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MSA9IGJlejE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJba10uYmV6MiA9IGJlejI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoaW50cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBhdGgocGF0aCwgeCwgeSkge1xuICAgICAgICB2YXIgYmJveCA9IHBhdGhCQm94KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNQb2ludEluc2lkZUJCb3goYmJveCwgeCwgeSkgJiZcbiAgICAgICAgICAgICAgIGludGVyUGF0aEhlbHBlcihwYXRoLCBbW1wiTVwiLCB4LCB5XSwgW1wiSFwiLCBiYm94LngyICsgMTBdXSwgMSkgJSAyID09IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhCQm94KHBhdGgpIHtcbiAgICAgICAgdmFyIHB0aCA9IHBhdGhzKHBhdGgpO1xuICAgICAgICBpZiAocHRoLmJib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZShwdGguYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm94KCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgWCA9IFtdLFxuICAgICAgICAgICAgWSA9IFtdLFxuICAgICAgICAgICAgcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChwWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBbMV07XG4gICAgICAgICAgICAgICAgeSA9IHBbMl07XG4gICAgICAgICAgICAgICAgWC5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIFkucHVzaCh5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpbSA9IGN1cnZlRGltKHgsIHksIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0sIHBbNl0pO1xuICAgICAgICAgICAgICAgIFggPSBYLmNvbmNhdChkaW0ubWluLngsIGRpbS5tYXgueCk7XG4gICAgICAgICAgICAgICAgWSA9IFkuY29uY2F0KGRpbS5taW4ueSwgZGltLm1heC55KTtcbiAgICAgICAgICAgICAgICB4ID0gcFs1XTtcbiAgICAgICAgICAgICAgICB5ID0gcFs2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgeG1pbiA9IG1taW4uYXBwbHkoMCwgWCksXG4gICAgICAgICAgICB5bWluID0gbW1pbi5hcHBseSgwLCBZKSxcbiAgICAgICAgICAgIHhtYXggPSBtbWF4LmFwcGx5KDAsIFgpLFxuICAgICAgICAgICAgeW1heCA9IG1tYXguYXBwbHkoMCwgWSksXG4gICAgICAgICAgICBiYiA9IGJveCh4bWluLCB5bWluLCB4bWF4IC0geG1pbiwgeW1heCAtIHltaW4pO1xuICAgICAgICBwdGguYmJveCA9IGNsb25lKGJiKTtcbiAgICAgICAgcmV0dXJuIGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN0UGF0aCh4LCB5LCB3LCBoLCByKSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtcIk1cIiwgK3ggKyArciwgeV0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCB3IC0gciAqIDIsIDBdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCBoIC0gciAqIDJdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgLXIsIHJdLFxuICAgICAgICAgICAgICAgIFtcImxcIiwgciAqIDIgLSB3LCAwXSxcbiAgICAgICAgICAgICAgICBbXCJhXCIsIHIsIHIsIDAsIDAsIDEsIC1yLCAtcl0sXG4gICAgICAgICAgICAgICAgW1wibFwiLCAwLCByICogMiAtIGhdLFxuICAgICAgICAgICAgICAgIFtcImFcIiwgciwgciwgMCwgMCwgMSwgciwgLXJdLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IFtbXCJNXCIsIHgsIHldLCBbXCJsXCIsIHcsIDBdLCBbXCJsXCIsIDAsIGhdLCBbXCJsXCIsIC13LCAwXSwgW1wielwiXV07XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGxpcHNlUGF0aCh4LCB5LCByeCwgcnksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gbnVsbCAmJiByeSA9PSBudWxsKSB7XG4gICAgICAgICAgICByeSA9IHJ4O1xuICAgICAgICB9XG4gICAgICAgIHggPSAreDtcbiAgICAgICAgeSA9ICt5O1xuICAgICAgICByeCA9ICtyeDtcbiAgICAgICAgcnkgPSArcnk7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgICAgICAgIHgxID0geCArIHJ4ICogTWF0aC5jb3MoLXJ5ICogcmFkKSxcbiAgICAgICAgICAgICAgICB4MiA9IHggKyByeCAqIE1hdGguY29zKC1hICogcmFkKSxcbiAgICAgICAgICAgICAgICB5MSA9IHkgKyByeCAqIE1hdGguc2luKC1yeSAqIHJhZCksXG4gICAgICAgICAgICAgICAgeTIgPSB5ICsgcnggKiBNYXRoLnNpbigtYSAqIHJhZCksXG4gICAgICAgICAgICAgICAgcmVzID0gW1tcIk1cIiwgeDEsIHkxXSwgW1wiQVwiLCByeCwgcngsIDAsICsoYSAtIHJ5ID4gMTgwKSwgMCwgeDIsIHkyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBbXG4gICAgICAgICAgICAgICAgW1wiTVwiLCB4LCB5XSxcbiAgICAgICAgICAgICAgICBbXCJtXCIsIDAsIC1yeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIDIgKiByeV0sXG4gICAgICAgICAgICAgICAgW1wiYVwiLCByeCwgcnksIDAsIDEsIDEsIDAsIC0yICogcnldLFxuICAgICAgICAgICAgICAgIFtcInpcIl1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZhciB1bml0MnB4ID0gU25hcC5fdW5pdDJweCxcbiAgICAgICAgZ2V0UGF0aCA9IHtcbiAgICAgICAgcGF0aDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuYXR0cihcInBhdGhcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGNpcmNsZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0ciA9IHVuaXQycHgoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VQYXRoKGF0dHIuY3gsIGF0dHIuY3ksIGF0dHIucik7XG4gICAgICAgIH0sXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbGxpcHNlUGF0aChhdHRyLmN4IHx8IDAsIGF0dHIuY3kgfHwgMCwgYXR0ci5yeCwgYXR0ci5yeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0LCBhdHRyLnJ4LCBhdHRyLnJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSB1bml0MnB4KGVsKTtcbiAgICAgICAgICAgIHJldHVybiByZWN0UGF0aChhdHRyLnggfHwgMCwgYXR0ci55IHx8IDAsIGF0dHIud2lkdGgsIGF0dHIuaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNXCIgKyBbZWwuYXR0cihcIngxXCIpIHx8IDAsIGVsLmF0dHIoXCJ5MVwiKSB8fCAwLCBlbC5hdHRyKFwieDJcIiksIGVsLmF0dHIoXCJ5MlwiKV07XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlsaW5lOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGVsLmF0dHIoXCJwb2ludHNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb246IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTVwiICsgZWwuYXR0cihcInBvaW50c1wiKSArIFwielwiO1xuICAgICAgICB9LFxuICAgICAgICBkZWZsdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IGVsLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RQYXRoKGJib3gueCwgYmJveC55LCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhdGhUb1JlbGF0aXZlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XG4gICAgICAgIGlmIChwdGgucmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aENsb25lKHB0aC5yZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU25hcC5pcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIVNuYXAuaXMocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSwgXCJhcnJheVwiKSkge1xuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gcGF0aEFycmF5WzBdWzFdO1xuICAgICAgICAgICAgeSA9IHBhdGhBcnJheVswXVsyXTtcbiAgICAgICAgICAgIG14ID0geDtcbiAgICAgICAgICAgIG15ID0geTtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgICAgICByZXMucHVzaChbXCJNXCIsIHgsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gcmVzW2ldID0gW10sXG4gICAgICAgICAgICAgICAgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAocGFbMF0gIT0gbG93ZXJDYXNlLmNhbGwocGFbMF0pKSB7XG4gICAgICAgICAgICAgICAgclswXSA9IGxvd2VyQ2FzZS5jYWxsKHBhWzBdKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArKHBhWzZdIC0geCkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbN10gPSArKHBhWzddIC0geSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICsocGFbMV0gLSB5KS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gKyhwYVtqXSAtIChqICUgMiA/IHggOiB5KSkudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHIgPSByZXNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocGFbMF0gPT0gXCJtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXggPSBwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgIG15ID0gcGFbMl0gKyB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwYS5sZW5ndGg7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tpXVtrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSByZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgc3dpdGNoIChyZXNbaV1bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwielwiOlxuICAgICAgICAgICAgICAgICAgICB4ID0gbXg7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBteTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcbiAgICAgICAgICAgICAgICAgICAgeCArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgICAgICB5ICs9ICtyZXNbaV1bbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHggKz0gK3Jlc1tpXVtsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSArcmVzW2ldW2xlbiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBwdGgucmVsID0gcGF0aENsb25lKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuICAgICAgICB2YXIgcHRoID0gcGF0aHMocGF0aEFycmF5KTtcbiAgICAgICAgaWYgKHB0aC5hYnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmFicyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpcyhwYXRoQXJyYXksIFwiYXJyYXlcIikgfHwgIWlzKHBhdGhBcnJheSAmJiBwYXRoQXJyYXlbMF0sIFwiYXJyYXlcIikpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgcGF0aEFycmF5ID0gU25hcC5wYXJzZVBhdGhTdHJpbmcocGF0aEFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGhBcnJheSB8fCAhcGF0aEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtbXCJNXCIsIDAsIDBdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwLFxuICAgICAgICAgICAgbXggPSAwLFxuICAgICAgICAgICAgbXkgPSAwLFxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgcGEwO1xuICAgICAgICBpZiAocGF0aEFycmF5WzBdWzBdID09IFwiTVwiKSB7XG4gICAgICAgICAgICB4ID0gK3BhdGhBcnJheVswXVsxXTtcbiAgICAgICAgICAgIHkgPSArcGF0aEFycmF5WzBdWzJdO1xuICAgICAgICAgICAgbXggPSB4O1xuICAgICAgICAgICAgbXkgPSB5O1xuICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgIHJlc1swXSA9IFtcIk1cIiwgeCwgeV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNyeiA9IHBhdGhBcnJheS5sZW5ndGggPT0gMyAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzBdWzBdID09IFwiTVwiICYmXG4gICAgICAgICAgICBwYXRoQXJyYXlbMV1bMF0udG9VcHBlckNhc2UoKSA9PSBcIlJcIiAmJlxuICAgICAgICAgICAgcGF0aEFycmF5WzJdWzBdLnRvVXBwZXJDYXNlKCkgPT0gXCJaXCI7XG4gICAgICAgIGZvciAodmFyIHIsIHBhLCBpID0gc3RhcnQsIGlpID0gcGF0aEFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKHIgPSBbXSk7XG4gICAgICAgICAgICBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIHBhMCA9IHBhWzBdO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBwYTAudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbM10gPSBwYVszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbNl0gPSArcGFbNl0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdHMgPSBbeCwgeV0uY29uY2F0KHBhLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAyLCBqaiA9IGRvdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdHNbal0gPSArZG90c1tqXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90c1srK2pdID0gK2RvdHNbal0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChjYXRtdWxsUm9tMmJlemllcihkb3RzLCBjcnopKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiT1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGRvdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJVXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KGVsbGlwc2VQYXRoKHgsIHksIHBhWzFdLCBwYVsyXSwgcGFbM10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gK3BhWzJdICsgeTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDEsIGpqID0gcGEubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoaiAlIDIgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYTAgPT0gXCJSXCIpIHtcbiAgICAgICAgICAgICAgICBkb3RzID0gW3gsIHldLmNvbmNhdChwYS5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoY2F0bXVsbFJvbTJiZXppZXIoZG90cywgY3J6KSk7XG4gICAgICAgICAgICAgICAgciA9IFtcIlJcIl0uY29uY2F0KHBhLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhMCA9PSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHJlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBkb3RzID0gZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdKTtcbiAgICAgICAgICAgICAgICBkb3RzLnB1c2goZG90c1swXSk7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChkb3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGEwID09IFwiVVwiKSB7XG4gICAgICAgICAgICAgICAgcmVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoZWxsaXBzZVBhdGgoeCwgeSwgcGFbMV0sIHBhWzJdLCBwYVszXSkpO1xuICAgICAgICAgICAgICAgIHIgPSBbXCJVXCJdLmNvbmNhdChyZXNbcmVzLmxlbmd0aCAtIDFdLnNsaWNlKC0yKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBhLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcltrXSA9IHBhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhMCA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHBhMCAhPSBcIk9cIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICtteDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSArbXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbXggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBteSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSByW3IubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICAgICAgcHRoLmFicyA9IHBhdGhDbG9uZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsMmMoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIF8xMyA9IDEgLyAzLFxuICAgICAgICAgICAgXzIzID0gMiAvIDM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgXzEzICogeDEgKyBfMjMgKiBheCxcbiAgICAgICAgICAgICAgICBfMTMgKiB5MSArIF8yMyAqIGF5LFxuICAgICAgICAgICAgICAgIF8xMyAqIHgyICsgXzIzICogYXgsXG4gICAgICAgICAgICAgICAgXzEzICogeTIgKyBfMjMgKiBheSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MlxuICAgICAgICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgIC8vIGZvciBtb3JlIGluZm9ybWF0aW9uIG9mIHdoZXJlIHRoaXMgbWF0aCBjYW1lIGZyb20gdmlzaXQ6XG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICB2YXIgXzEyMCA9IFBJICogMTIwIC8gMTgwLFxuICAgICAgICAgICAgcmFkID0gUEkgLyAxODAgKiAoK2FuZ2xlIHx8IDApLFxuICAgICAgICAgICAgcmVzID0gW10sXG4gICAgICAgICAgICB4eSxcbiAgICAgICAgICAgIHJvdGF0ZSA9IFNuYXAuXy5jYWNoZXIoZnVuY3Rpb24gKHgsIHksIHJhZCkge1xuICAgICAgICAgICAgICAgIHZhciBYID0geCAqIG1hdGguY29zKHJhZCkgLSB5ICogbWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgICAgICAgICAgWSA9IHggKiBtYXRoLnNpbihyYWQpICsgeSAqIG1hdGguY29zKHJhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt4OiBYLCB5OiBZfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJ4IHx8ICFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgIHgxID0geHkueDtcbiAgICAgICAgICAgIHkxID0geHkueTtcbiAgICAgICAgICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICB5MiA9IHh5Lnk7XG4gICAgICAgICAgICB2YXIgY29zID0gbWF0aC5jb3MoUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgc2luID0gbWF0aC5zaW4oUEkgLyAxODAgKiBhbmdsZSksXG4gICAgICAgICAgICAgICAgeCA9ICh4MSAtIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgICAgICB2YXIgaCA9IHggKiB4IC8gKHJ4ICogcngpICsgeSAqIHkgLyAocnkgKiByeSk7XG4gICAgICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgICAgICBoID0gbWF0aC5zcXJ0KGgpO1xuICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgICAgICAgICAgcnkyID0gcnkgKiByeSxcbiAgICAgICAgICAgICAgICBrID0gKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcgPyAtMSA6IDEpICpcbiAgICAgICAgICAgICAgICAgICAgbWF0aC5zcXJ0KGFicygocngyICogcnkyIC0gcngyICogeSAqIHkgLSByeTIgKiB4ICogeCkgLyAocngyICogeSAqIHkgKyByeTIgKiB4ICogeCkpKSxcbiAgICAgICAgICAgICAgICBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgICAgICAgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMixcbiAgICAgICAgICAgICAgICBmMSA9IG1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpLFxuICAgICAgICAgICAgICAgIGYyID0gbWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICAgICAgICAgIGYxID0geDEgPCBjeCA/IFBJIC0gZjEgOiBmMTtcbiAgICAgICAgICAgIGYyID0geDIgPCBjeCA/IFBJIC0gZjIgOiBmMjtcbiAgICAgICAgICAgIGYxIDwgMCAmJiAoZjEgPSBQSSAqIDIgKyBmMSk7XG4gICAgICAgICAgICBmMiA8IDAgJiYgKGYyID0gUEkgKiAyICsgZjIpO1xuICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgICAgIGYxID0gZjEgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkge1xuICAgICAgICAgICAgICAgIGYyID0gZjIgLSBQSSAqIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgY3ggPSByZWN1cnNpdmVbMl07XG4gICAgICAgICAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICBpZiAoYWJzKGRmKSA+IF8xMjApIHtcbiAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyLFxuICAgICAgICAgICAgICAgIHgyb2xkID0geDIsXG4gICAgICAgICAgICAgICAgeTJvbGQgPSB5MjtcbiAgICAgICAgICAgIGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICB4MiA9IGN4ICsgcnggKiBtYXRoLmNvcyhmMik7XG4gICAgICAgICAgICB5MiA9IGN5ICsgcnkgKiBtYXRoLnNpbihmMik7XG4gICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICB9XG4gICAgICAgIGRmID0gZjIgLSBmMTtcbiAgICAgICAgdmFyIGMxID0gbWF0aC5jb3MoZjEpLFxuICAgICAgICAgICAgczEgPSBtYXRoLnNpbihmMSksXG4gICAgICAgICAgICBjMiA9IG1hdGguY29zKGYyKSxcbiAgICAgICAgICAgIHMyID0gbWF0aC5zaW4oZjIpLFxuICAgICAgICAgICAgdCA9IG1hdGgudGFuKGRmIC8gNCksXG4gICAgICAgICAgICBoeCA9IDQgLyAzICogcnggKiB0LFxuICAgICAgICAgICAgaHkgPSA0IC8gMyAqIHJ5ICogdCxcbiAgICAgICAgICAgIG0xID0gW3gxLCB5MV0sXG4gICAgICAgICAgICBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV0sXG4gICAgICAgICAgICBtMyA9IFt4MiArIGh4ICogczIsIHkyIC0gaHkgKiBjMl0sXG4gICAgICAgICAgICBtNCA9IFt4MiwgeTJdO1xuICAgICAgICBtMlswXSA9IDIgKiBtMVswXSAtIG0yWzBdO1xuICAgICAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSByZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld3Jlc1tpXSA9IGkgJSAyID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kRG90QXRTZWdtZW50KHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5LCB0KSB7XG4gICAgICAgIHZhciB0MSA9IDEgLSB0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG93KHQxLCAzKSAqIHAxeCArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeCArIHQxICogMyAqIHQgKiB0ICogYzJ4ICsgcG93KHQsIDMpICogcDJ4LFxuICAgICAgICAgICAgeTogcG93KHQxLCAzKSAqIHAxeSArIHBvdyh0MSwgMikgKiAzICogdCAqIGMxeSArIHQxICogMyAqIHQgKiB0ICogYzJ5ICsgcG93KHQsIDMpICogcDJ5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBib3VuZGluZyBib3ggb2YgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgIC8vIFNvdXJjZTogaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gT3JpZ2luYWwgdmVyc2lvbjogTklTSElPIEhpcm9rYXp1XG4gICAgLy8gTW9kaWZpY2F0aW9uczogaHR0cHM6Ly9naXRodWIuY29tL3RpbW8yMjM0NVxuICAgIGZ1bmN0aW9uIGN1cnZlRGltKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgICB2YXIgdHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICBzcXJ0YjJhYyA9IG1hdGguc3FydChiMmFjKTtcbiAgICAgICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGpsZW4gPSBqLFxuICAgICAgICAgICAgbXQ7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcbiAgICAgICAgICAgIGJvdW5kc1swXVtqXSA9IG10ICogbXQgKiBtdCAqIHgwICsgMyAqIG10ICogbXQgKiB0ICogeDEgKyAzICogbXQgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgICAgICAgICBib3VuZHNbMV1bal0gPSBtdCAqIG10ICogbXQgKiB5MCArIDMgKiBtdCAqIG10ICogdCAqIHkxICsgMyAqIG10ICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICAgICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWluOiB7eDogbW1pbi5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBtbWluLmFwcGx5KDAsIGJvdW5kc1sxXSl9LFxuICAgICAgICAgIG1heDoge3g6IG1tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogbW1heC5hcHBseSgwLCBib3VuZHNbMV0pfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGgyY3VydmUocGF0aCwgcGF0aDIpIHtcbiAgICAgICAgdmFyIHB0aCA9ICFwYXRoMiAmJiBwYXRocyhwYXRoKTtcbiAgICAgICAgaWYgKCFwYXRoMiAmJiBwdGguY3VydmUpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQ2xvbmUocHRoLmN1cnZlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpLFxuICAgICAgICAgICAgcDIgPSBwYXRoMiAmJiBwYXRoVG9BYnNvbHV0ZShwYXRoMiksXG4gICAgICAgICAgICBhdHRycyA9IHt4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbH0sXG4gICAgICAgICAgICBhdHRyczIgPSB7eDogMCwgeTogMCwgYng6IDAsIGJ5OiAwLCBYOiAwLCBZOiAwLCBxeDogbnVsbCwgcXk6IG51bGx9LFxuICAgICAgICAgICAgcHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgZCwgcGNvbSkge1xuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJDXCIsIGQueCwgZC55LCBkLngsIGQueSwgZC54LCBkLnldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhKHBhdGhbMF0gaW4ge1Q6IDEsIFE6IDF9KSAmJiAoZC5xeCA9IGQucXkgPSBudWxsKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09IFwiQ1wiIHx8IHBjb20gPT0gXCJTXCIpIHsgLy8gSW4gXCJTXCIgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBDL1MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLnggKiAyIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnkgKiAyIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3Igc29tZSBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueSA9IGQueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCIsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PSBcIlFcIiB8fCBwY29tID09IFwiVFwiKSB7IC8vIEluIFwiVFwiIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgUS9ULlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXggPSBkLnggKiAyIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IGQueSAqIDIgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSBcIlNcIi5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJRXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KHEyYyhkLngsIGQueSwgcGF0aFsxXSwgcGF0aFsyXSwgcGF0aFszXSwgcGF0aFs0XSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbXCJDXCJdLmNvbmNhdChsMmMoZC54LCBkLnksIHBhdGhbMV0sIGQueSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gW1wiQ1wiXS5jb25jYXQobDJjKGQueCwgZC55LCBkLngsIHBhdGhbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtcIkNcIl0uY29uY2F0KGwyYyhkLngsIGQueSwgZC5YLCBkLlkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhBcmMgPSBmdW5jdGlvbiAocHAsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHBbaV0ubGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXMxW2ldID0gXCJBXCI7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgQzpzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyICYmIChwY29tczJbaV0gPSBcIkFcIik7IC8vIHRoZSBzYW1lIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbXCJDXCJdLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlpID0gbW1heChwLmxlbmd0aCwgcDIgJiYgcDIubGVuZ3RoIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXhNID0gZnVuY3Rpb24gKHBhdGgxLCBwYXRoMiwgYTEsIGEyLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgxICYmIHBhdGgyICYmIHBhdGgxW2ldWzBdID09IFwiTVwiICYmIHBhdGgyW2ldWzBdICE9IFwiTVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgyLnNwbGljZShpLCAwLCBbXCJNXCIsIGEyLngsIGEyLnldKTtcbiAgICAgICAgICAgICAgICAgICAgYTEuYnggPSAwO1xuICAgICAgICAgICAgICAgICAgICBhMS5ieSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGExLnggPSBwYXRoMVtpXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYTEueSA9IHBhdGgxW2ldWzJdO1xuICAgICAgICAgICAgICAgICAgICBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGNvbXMxID0gW10sIC8vIHBhdGggY29tbWFuZHMgb2Ygb3JpZ2luYWwgcGF0aCBwXG4gICAgICAgICAgICBwY29tczIgPSBbXSwgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHAyXG4gICAgICAgICAgICBwZmlyc3QgPSBcIlwiLCAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgIHBjb20gPSBcIlwiOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1tYXgocC5sZW5ndGgsIHAyICYmIHAyLmxlbmd0aCB8fCAwKTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHBbaV0gJiYgKHBmaXJzdCA9IHBbaV1bMF0pOyAvLyBzYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG5cbiAgICAgICAgICAgIGlmIChwZmlyc3QgIT0gXCJDXCIpIC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwY29tczFbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBpICYmICggcGNvbSA9IHBjb21zMVtpIC0gMV0pOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbaV0gPSBwcm9jZXNzUGF0aChwW2ldLCBhdHRycywgcGNvbSk7IC8vIFByZXZpb3VzIHBhdGggY29tbWFuZCBpcyBpbnB1dHRlZCB0byBwcm9jZXNzUGF0aFxuXG4gICAgICAgICAgICBpZiAocGNvbXMxW2ldICE9IFwiQVwiICYmIHBmaXJzdCA9PSBcIkNcIikgcGNvbXMxW2ldID0gXCJDXCI7IC8vIEEgaXMgdGhlIG9ubHkgY29tbWFuZFxuICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgQzpzXG4gICAgICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IEMgaXMgYWxzbyBDIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgQTpzIHRvIHBjb21zMVxuXG4gICAgICAgICAgICBpZiAocDIpIHsgLy8gdGhlIHNhbWUgcHJvY2VkdXJlcyBpcyBkb25lIHRvIHAyXG4gICAgICAgICAgICAgICAgcDJbaV0gJiYgKHBmaXJzdCA9IHAyW2ldWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocGZpcnN0ICE9IFwiQ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBjb21zMltpXSA9IHBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgaSAmJiAocGNvbSA9IHBjb21zMltpIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwMltpXSA9IHByb2Nlc3NQYXRoKHAyW2ldLCBhdHRyczIsIHBjb20pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBjb21zMltpXSAhPSBcIkFcIiAmJiBwZmlyc3QgPT0gXCJDXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGNvbXMyW2ldID0gXCJDXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZml4QXJjKHAyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpeE0ocCwgcDIsIGF0dHJzLCBhdHRyczIsIGkpO1xuICAgICAgICAgICAgZml4TShwMiwgcCwgYXR0cnMyLCBhdHRycywgaSk7XG4gICAgICAgICAgICB2YXIgc2VnID0gcFtpXSxcbiAgICAgICAgICAgICAgICBzZWcyID0gcDIgJiYgcDJbaV0sXG4gICAgICAgICAgICAgICAgc2VnbGVuID0gc2VnLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWcybGVuID0gcDIgJiYgc2VnMi5sZW5ndGg7XG4gICAgICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMueSA9IHNlZ1tzZWdsZW4gLSAxXTtcbiAgICAgICAgICAgIGF0dHJzLmJ4ID0gdG9GbG9hdChzZWdbc2VnbGVuIC0gNF0pIHx8IGF0dHJzLng7XG4gICAgICAgICAgICBhdHRycy5ieSA9IHRvRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICAgICAgYXR0cnMyLmJ4ID0gcDIgJiYgKHRvRmxvYXQoc2VnMltzZWcybGVuIC0gNF0pIHx8IGF0dHJzMi54KTtcbiAgICAgICAgICAgIGF0dHJzMi5ieSA9IHAyICYmICh0b0Zsb2F0KHNlZzJbc2VnMmxlbiAtIDNdKSB8fCBhdHRyczIueSk7XG4gICAgICAgICAgICBhdHRyczIueCA9IHAyICYmIHNlZzJbc2VnMmxlbiAtIDJdO1xuICAgICAgICAgICAgYXR0cnMyLnkgPSBwMiAmJiBzZWcyW3NlZzJsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAyKSB7XG4gICAgICAgICAgICBwdGguY3VydmUgPSBwYXRoQ2xvbmUocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAyID8gW3AsIHAyXSA6IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcFBhdGgocGF0aCwgbWF0cml4KSB7XG4gICAgICAgIGlmICghbWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCwgeSwgaSwgaiwgaWksIGpqLCBwYXRoaTtcbiAgICAgICAgcGF0aCA9IHBhdGgyY3VydmUocGF0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcGF0aC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBwYXRoaSA9IHBhdGhbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhpLmxlbmd0aDsgaiA8IGpqOyBqICs9IDIpIHtcbiAgICAgICAgICAgICAgICB4ID0gbWF0cml4LngocGF0aGlbal0sIHBhdGhpW2ogKyAxXSk7XG4gICAgICAgICAgICAgICAgeSA9IG1hdHJpeC55KHBhdGhpW2pdLCBwYXRoaVtqICsgMV0pO1xuICAgICAgICAgICAgICAgIHBhdGhpW2pdID0geDtcbiAgICAgICAgICAgICAgICBwYXRoaVtqICsgMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9zY2hlcGVycy5jYy9nZXR0aW5nLXRvLXRoZS1wb2ludFxuICAgIGZ1bmN0aW9uIGNhdG11bGxSb20yYmV6aWVyKGNycCwgeikge1xuICAgICAgICB2YXIgZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNycC5sZW5ndGg7IGlMZW4gLSAyICogIXogPiBpOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBwID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSAtIDJdLCB5OiArY3JwW2kgLSAxXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7eDogK2NycFtpXSwgICAgIHk6ICtjcnBbaSArIDFdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt4OiArY3JwW2kgKyAyXSwgeTogK2NycFtpICsgM119LFxuICAgICAgICAgICAgICAgICAgICAgICAge3g6ICtjcnBbaSArIDRdLCB5OiArY3JwW2kgKyA1XX1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSB7eDogK2NycFtpTGVuIC0gMl0sIHk6ICtjcnBbaUxlbiAtIDFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSA0ID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlMZW4gLSAyID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFsyXSA9IHt4OiArY3JwWzBdLCB5OiArY3JwWzFdfTtcbiAgICAgICAgICAgICAgICAgICAgcFszXSA9IHt4OiArY3JwWzJdLCB5OiArY3JwWzNdfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpTGVuIC0gNCA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbM10gPSBwWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWkpIHtcbiAgICAgICAgICAgICAgICAgICAgcFswXSA9IHt4OiArY3JwW2ldLCB5OiArY3JwW2kgKyAxXX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZC5wdXNoKFtcIkNcIixcbiAgICAgICAgICAgICAgICAgICgtcFswXS54ICsgNiAqIHBbMV0ueCArIHBbMl0ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKC1wWzBdLnkgKyA2ICogcFsxXS55ICsgcFsyXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICAocFsxXS54ICsgNiAqIHBbMl0ueCAtIHBbM10ueCkgLyA2LFxuICAgICAgICAgICAgICAgICAgKHBbMV0ueSArIDYqcFsyXS55IC0gcFszXS55KSAvIDYsXG4gICAgICAgICAgICAgICAgICBwWzJdLngsXG4gICAgICAgICAgICAgICAgICBwWzJdLnlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0XG4gICAgU25hcC5wYXRoID0gcGF0aHM7XG5cbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIHBhdGggaW4gcGl4ZWxzXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgKipcbiAgICAgPSAobnVtYmVyKSBsZW5ndGhcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFRvdGFsTGVuZ3RoID0gZ2V0VG90YWxMZW5ndGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5nZXRQb2ludEF0TGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIGFsb25nIHRoZSBnaXZlbiBwYXRoXG4gICAgICoqXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBTVkcgcGF0aCBzdHJpbmdcbiAgICAgLSBsZW5ndGggKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoLCBleGNsdWRpbmcgbm9uLXJlbmRlcmluZyBqdW1wc1xuICAgICAqKlxuICAgICA9IChvYmplY3QpIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwb2ludDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlLFxuICAgICBvICAgICBhbHBoYTogKG51bWJlcikgYW5nbGUgb2YgZGVyaXZhdGl2ZVxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFBvaW50QXRMZW5ndGggPSBnZXRQb2ludEF0TGVuZ3RoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyB0aGUgc3VicGF0aCBvZiBhIGdpdmVuIHBhdGggYmV0d2VlbiBnaXZlbiBzdGFydCBhbmQgZW5kIGxlbmd0aHNcbiAgICAgKipcbiAgICAgLSBwYXRoIChzdHJpbmcpIFNWRyBwYXRoIHN0cmluZ1xuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmdldFN1YnBhdGggPSBmdW5jdGlvbiAocGF0aCwgZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG90YWxMZW5ndGgocGF0aCkgLSB0byA8IDFlLTYpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdWJwYXRoc0F0TGVuZ3RoKHBhdGgsIGZyb20pLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IGdldFN1YnBhdGhzQXRMZW5ndGgocGF0aCwgdG8sIDEpO1xuICAgICAgICByZXR1cm4gZnJvbSA/IGdldFN1YnBhdGhzQXRMZW5ndGgoYSwgZnJvbSkuZW5kIDogYTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmdldFRvdGFsTGVuZ3RoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggaW4gcGl4ZWxzIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgID0gKG51bWJlcikgbGVuZ3RoXG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0VG90YWxMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aCgpL0VsZW1lbnQuZ2V0VG90YWxMZW5ndGgoKTogSWYgYSA8cGF0aD4gaXMgYnJva2VuIGludG8gZGlmZmVyZW50IHNlZ21lbnRzLCBpcyB0aGUganVtcCBkaXN0YW5jZSB0byB0aGUgbmV3IGNvb3JkaW5hdGVzIHNldCBieSB0aGUgX01fIG9yIF9tXyBjb21tYW5kcyBjYWxjdWxhdGVkIGFzIHBhcnQgb2YgdGhlIHBhdGgncyB0b3RhbCBsZW5ndGg/XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0UG9pbnRBdExlbmd0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgbG9jYXRlZCBhdCB0aGUgZ2l2ZW4gbGVuZ3RoIG9uIHRoZSBnaXZlbiBwYXRoIChvbmx5IHdvcmtzIGZvciBgcGF0aGAgZWxlbWVudHMpXG4gICAgICoqXG4gICAgIC0gbGVuZ3RoIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCwgZXhjbHVkaW5nIG5vbi1yZW5kZXJpbmcganVtcHNcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcG9pbnQ6XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIGRlcml2YXRpdmVcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvaW50QXRMZW5ndGgodGhpcy5hdHRyKFwiZFwiKSwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIC8vIFNJRVJSQSBFbGVtZW50LmdldFN1YnBhdGgoKTogU2ltaWxhciB0byB0aGUgcHJvYmxlbSBmb3IgRWxlbWVudC5nZXRQb2ludEF0TGVuZ3RoKCkuIFVuY2xlYXIgaG93IHRoaXMgd291bGQgd29yayBmb3IgYSBzZWdtZW50ZWQgcGF0aC4gT3ZlcmFsbCwgdGhlIGNvbmNlcHQgb2YgX3N1YnBhdGhfIGFuZCB3aGF0IEknbSBjYWxsaW5nIGEgX3NlZ21lbnRfIChzZXJpZXMgb2Ygbm9uLV9NXyBvciBfWl8gY29tbWFuZHMpIGlzIHVuY2xlYXIuXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZ2V0U3VicGF0aFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzdWJwYXRoIG9mIGEgZ2l2ZW4gZWxlbWVudCBmcm9tIGdpdmVuIHN0YXJ0IGFuZCBlbmQgbGVuZ3RocyAob25seSB3b3JrcyBmb3IgYHBhdGhgIGVsZW1lbnRzKVxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcikgbGVuZ3RoLCBpbiBwaXhlbHMsIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBwYXRoIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAtIHRvIChudW1iZXIpIGxlbmd0aCwgaW4gcGl4ZWxzLCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgcGF0aCB0byB0aGUgZW5kIG9mIHRoZSBzZWdtZW50XG4gICAgICoqXG4gICAgID0gKHN0cmluZykgcGF0aCBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIHNlZ21lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5nZXRTdWJwYXRoID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnBhdGguZ2V0U3VicGF0aCh0aGlzLmF0dHIoXCJkXCIpLCBmcm9tLCB0byk7XG4gICAgfTtcbiAgICBTbmFwLl8uYm94ID0gYm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZmluZERvdHNBdFNlZ21lbnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogRmluZHMgZG90IGNvb3JkaW5hdGVzIG9uIHRoZSBnaXZlbiBjdWJpYyBiZXppw6lyIGN1cnZlIGF0IHRoZSBnaXZlbiB0XG4gICAgIC0gcDF4IChudW1iZXIpIHggb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBjMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeSAobnVtYmVyKSB5IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzJ5IChudW1iZXIpIHkgb2YgdGhlIHNlY29uZCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gcDJ4IChudW1iZXIpIHggb2YgdGhlIHNlY29uZCBwb2ludCBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHQgKG51bWJlcikgcG9zaXRpb24gb24gdGhlIGN1cnZlICgwLi4xKVxuICAgICA9IChvYmplY3QpIHBvaW50IGluZm9ybWF0aW9uIGluIGZvcm1hdDpcbiAgICAgbyB7XG4gICAgIG8gICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQsXG4gICAgIG8gICAgIG06IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBhbmNob3IsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgYW5jaG9yXG4gICAgIG8gICAgIH0sXG4gICAgIG8gICAgIG46IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYW5jaG9yLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBhbmNob3JcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgc3RhcnQ6IHtcbiAgICAgbyAgICAgICAgIHg6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnZlLFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgZW5kOiB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmUsXG4gICAgIG8gICAgICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgbyAgICAgfSxcbiAgICAgbyAgICAgYWxwaGE6IChudW1iZXIpIGFuZ2xlIG9mIHRoZSBjdXJ2ZSBkZXJpdmF0aXZlIGF0IHRoZSBwb2ludFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmZpbmREb3RzQXRTZWdtZW50ID0gZmluZERvdHNBdFNlZ21lbnQ7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5iZXppZXJCQm94XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdpdmVuIGN1YmljIGJlemnDqXIgY3VydmVcbiAgICAgLSBwMXggKG51bWJlcikgeCBvZiB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgIC0gcDF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIGMxeCAobnVtYmVyKSB4IG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhlIGN1cnZlXG4gICAgIC0gYzF5IChudW1iZXIpIHkgb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBjMnkgKG51bWJlcikgeSBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGUgY3VydmVcbiAgICAgLSBwMnggKG51bWJlcikgeCBvZiB0aGUgc2Vjb25kIHBvaW50IG9mIHRoZSBjdXJ2ZVxuICAgICAtIHAyeSAobnVtYmVyKSB5IG9mIHRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGN1cnZlXG4gICAgICogb3JcbiAgICAgLSBiZXogKGFycmF5KSBhcnJheSBvZiBzaXggcG9pbnRzIGZvciBiZXppw6lyIGN1cnZlXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94XG4gICAgIG8ge1xuICAgICBvICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHk6IChudW1iZXIpIHkgY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCB0b3AgcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgeDI6IChudW1iZXIpIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgYm90dG9tIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHkyOiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB3aWR0aDogKG51bWJlcikgd2lkdGggb2YgdGhlIGJveCxcbiAgICAgbyAgICAgaGVpZ2h0OiAobnVtYmVyKSBoZWlnaHQgb2YgdGhlIGJveFxuICAgICBvIH1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmJlemllckJCb3ggPSBiZXppZXJCQm94O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNQb2ludEluc2lkZUJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gcG9pbnQgaXMgaW5zaWRlIGJvdW5kaW5nIGJveFxuICAgICAtIGJib3ggKHN0cmluZykgYm91bmRpbmcgYm94XG4gICAgIC0geCAoc3RyaW5nKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgIC0geSAoc3RyaW5nKSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBwb2ludCBpcyBpbnNpZGVcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzUG9pbnRJbnNpZGVCQm94ID0gaXNQb2ludEluc2lkZUJCb3g7XG4gICAgU25hcC5jbG9zZXN0ID0gZnVuY3Rpb24gKHgsIHksIFgsIFkpIHtcbiAgICAgICAgdmFyIHIgPSAxMDAsXG4gICAgICAgICAgICBiID0gYm94KHggLSByIC8gMiwgeSAtIHIgLyAyLCByLCByKSxcbiAgICAgICAgICAgIGluc2lkZSA9IFtdLFxuICAgICAgICAgICAgZ2V0dGVyID0gWFswXS5oYXNPd25Qcm9wZXJ0eShcInhcIikgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0ueCxcbiAgICAgICAgICAgICAgICAgICAgeTogWFtpXS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFhbaV0sXG4gICAgICAgICAgICAgICAgICAgIHk6IFlbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvdW5kID0gMDtcbiAgICAgICAgd2hpbGUgKHIgPD0gMWU2ICYmICFmb3VuZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gWC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHh5ID0gZ2V0dGVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1BvaW50SW5zaWRlQkJveChiLCB4eS54LCB4eS55KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUucHVzaCh4eSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICByICo9IDI7XG4gICAgICAgICAgICAgICAgYiA9IGJveCh4IC0gciAvIDIsIHkgLSByIC8gMiwgciwgcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAociA9PSAxZTYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gSW5maW5pdHksXG4gICAgICAgICAgICByZXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW5zaWRlLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsID0gU25hcC5sZW4oeCwgeSwgaW5zaWRlW2ldLngsIGluc2lkZVtpXS55KTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBsKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gbDtcbiAgICAgICAgICAgICAgICBpbnNpZGVbaV0ubGVuID0gbDtcbiAgICAgICAgICAgICAgICByZXMgPSBpbnNpZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguaXNCQm94SW50ZXJzZWN0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHR3byBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICAgLSBiYm94MSAoc3RyaW5nKSBmaXJzdCBib3VuZGluZyBib3hcbiAgICAgLSBiYm94MiAoc3RyaW5nKSBzZWNvbmQgYm91bmRpbmcgYm94XG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBib3VuZGluZyBib3hlcyBpbnRlcnNlY3RcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmlzQkJveEludGVyc2VjdCA9IGlzQkJveEludGVyc2VjdDtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLmludGVyc2VjdGlvblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBGaW5kcyBpbnRlcnNlY3Rpb25zIG9mIHR3byBwYXRoc1xuICAgICAtIHBhdGgxIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0gcGF0aDIgKHN0cmluZykgcGF0aCBzdHJpbmdcbiAgICAgPSAoYXJyYXkpIGRvdHMgb2YgaW50ZXJzZWN0aW9uXG4gICAgIG8gW1xuICAgICBvICAgICB7XG4gICAgIG8gICAgICAgICB4OiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LFxuICAgICBvICAgICAgICAgeTogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCxcbiAgICAgbyAgICAgICAgIHQxOiAobnVtYmVyKSB0IHZhbHVlIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgdDI6IChudW1iZXIpIHQgdmFsdWUgZm9yIHNlZ21lbnQgb2YgcGF0aDIsXG4gICAgIG8gICAgICAgICBzZWdtZW50MTogKG51bWJlcikgb3JkZXIgbnVtYmVyIGZvciBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgc2VnbWVudDI6IChudW1iZXIpIG9yZGVyIG51bWJlciBmb3Igc2VnbWVudCBvZiBwYXRoMixcbiAgICAgbyAgICAgICAgIGJlejE6IChhcnJheSkgZWlnaHQgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIGJlemnDqXIgY3VydmUgZm9yIHRoZSBzZWdtZW50IG9mIHBhdGgxLFxuICAgICBvICAgICAgICAgYmV6MjogKGFycmF5KSBlaWdodCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgYmV6acOpciBjdXJ2ZSBmb3IgdGhlIHNlZ21lbnQgb2YgcGF0aDJcbiAgICAgbyAgICAgfVxuICAgICBvIF1cbiAgICBcXCovXG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbiA9IHBhdGhJbnRlcnNlY3Rpb247XG4gICAgU25hcC5wYXRoLmludGVyc2VjdGlvbk51bWJlciA9IHBhdGhJbnRlcnNlY3Rpb25OdW1iZXI7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5pc1BvaW50SW5zaWRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHBvaW50IGlzIGluc2lkZSBhIGdpdmVuIGNsb3NlZCBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZTogZmlsbCBtb2RlIGRvZXNu4oCZdCBhZmZlY3QgdGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgIC0geCAobnVtYmVyKSB4IG9mIHRoZSBwb2ludFxuICAgICAtIHkgKG51bWJlcikgeSBvZiB0aGUgcG9pbnRcbiAgICAgPSAoYm9vbGVhbikgYHRydWVgIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgcGF0aFxuICAgIFxcKi9cbiAgICBTbmFwLnBhdGguaXNQb2ludEluc2lkZSA9IGlzUG9pbnRJbnNpZGVQYXRoO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGguZ2V0QkJveFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggb2YgYSBnaXZlbiBwYXRoXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChvYmplY3QpIGJvdW5kaW5nIGJveFxuICAgICBvIHtcbiAgICAgbyAgICAgeDogKG51bWJlcikgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHRvcCBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5OiAobnVtYmVyKSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgdG9wIHBvaW50IG9mIHRoZSBib3gsXG4gICAgIG8gICAgIHgyOiAobnVtYmVyKSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGJvdHRvbSBwb2ludCBvZiB0aGUgYm94LFxuICAgICBvICAgICB5MjogKG51bWJlcikgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBib3R0b20gcG9pbnQgb2YgdGhlIGJveCxcbiAgICAgbyAgICAgd2lkdGg6IChudW1iZXIpIHdpZHRoIG9mIHRoZSBib3gsXG4gICAgIG8gICAgIGhlaWdodDogKG51bWJlcikgaGVpZ2h0IG9mIHRoZSBib3hcbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5nZXRCQm94ID0gcGF0aEJCb3g7XG4gICAgU25hcC5wYXRoLmdldCA9IGdldFBhdGg7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC50b1JlbGF0aXZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZFxuICAgICAqKlxuICAgICAqIENvbnZlcnRzIHBhdGggY29vcmRpbmF0ZXMgaW50byByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgLSBwYXRoIChzdHJpbmcpIHBhdGggc3RyaW5nXG4gICAgID0gKGFycmF5KSBwYXRoIHN0cmluZ1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9SZWxhdGl2ZSA9IHBhdGhUb1JlbGF0aXZlO1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnBhdGgudG9BYnNvbHV0ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogVXRpbGl0eSBtZXRob2RcbiAgICAgKipcbiAgICAgKiBDb252ZXJ0cyBwYXRoIGNvb3JkaW5hdGVzIGludG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICA9IChhcnJheSkgcGF0aCBzdHJpbmdcbiAgICBcXCovXG4gICAgU25hcC5wYXRoLnRvQWJzb2x1dGUgPSBwYXRoVG9BYnNvbHV0ZTtcbiAgICAvKlxcXG4gICAgICogU25hcC5wYXRoLnRvQ3ViaWNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFV0aWxpdHkgbWV0aG9kXG4gICAgICoqXG4gICAgICogQ29udmVydHMgcGF0aCB0byBhIG5ldyBwYXRoIHdoZXJlIGFsbCBzZWdtZW50cyBhcmUgY3ViaWMgYmV6acOpciBjdXJ2ZXNcbiAgICAgLSBwYXRoU3RyaW5nIChzdHJpbmd8YXJyYXkpIHBhdGggc3RyaW5nIG9yIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgID0gKGFycmF5KSBhcnJheSBvZiBzZWdtZW50c1xuICAgIFxcKi9cbiAgICBTbmFwLnBhdGgudG9DdWJpYyA9IHBhdGgyY3VydmU7XG4gICAgLypcXFxuICAgICAqIFNuYXAucGF0aC5tYXBcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgcGF0aCBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWF0cml4XG4gICAgIC0gcGF0aCAoc3RyaW5nKSBwYXRoIHN0cmluZ1xuICAgICAtIG1hdHJpeCAob2JqZWN0KSBzZWUgQE1hdHJpeFxuICAgICA9IChzdHJpbmcpIHRyYW5zZm9ybWVkIHBhdGggc3RyaW5nXG4gICAgXFwqL1xuICAgIFNuYXAucGF0aC5tYXAgPSBtYXBQYXRoO1xuICAgIFNuYXAucGF0aC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIFNuYXAucGF0aC5jbG9uZSA9IHBhdGhDbG9uZTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbW1heCA9IE1hdGgubWF4LFxuICAgICAgICBtbWluID0gTWF0aC5taW47XG5cbiAgICAvLyBTZXRcbiAgICB2YXIgU2V0ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcblx0dGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic2V0XCI7XG4gICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaXRlbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3RoaXMuaXRlbXMubGVuZ3RoXSA9IHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRwcm90byA9IFNldC5wcm90b3R5cGU7XG4gICAgLypcXFxuICAgICAqIFNldC5wdXNoXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGVhY2ggYXJndW1lbnQgdG8gdGhlIGN1cnJlbnQgc2V0XG4gICAgID0gKG9iamVjdCkgb3JpZ2luYWwgZWxlbWVudFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSxcbiAgICAgICAgICAgIGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXNbbGVuXSA9IHRoaXMuaXRlbXNbbGVuXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQucG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGxhc3QgZWxlbWVudCBhbmQgcmV0dXJucyBpdFxuICAgICA9IChvYmplY3QpIGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCAmJiBkZWxldGUgdGhpc1t0aGlzLmxlbmd0aC0tXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMucG9wKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmZvckVhY2hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEV4ZWN1dGVzIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldFxuICAgICAqXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIGxvb3Agc3RvcHMgcnVubmluZy5cbiAgICAgKipcbiAgICAgLSBjYWxsYmFjayAoZnVuY3Rpb24pIGZ1bmN0aW9uIHRvIHJ1blxuICAgICAtIHRoaXNBcmcgKG9iamVjdCkgY29udGV4dCBvYmplY3QgZm9yIHRoZSBjYWxsYmFja1xuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuaXRlbXNbaV0sIGkpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyBlYWNoIGVsZW1lbnQgaW4gc2V0IGluIHN5bmMuXG4gICAgICpcbiAgICAgKipcbiAgICAgLSBhdHRycyAob2JqZWN0KSBrZXktdmFsdWUgcGFpcnMgb2YgZGVzdGluYXRpb24gYXR0cmlidXRlc1xuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgIC0gZWFzaW5nIChmdW5jdGlvbikgI29wdGlvbmFsIGVhc2luZyBmdW5jdGlvbiBmcm9tIEBtaW5hIG9yIGN1c3RvbVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHNcbiAgICAgKiBvclxuICAgICAtIGFuaW1hdGlvbiAoYXJyYXkpIGFycmF5IG9mIGFuaW1hdGlvbiBwYXJhbWV0ZXIgZm9yIGVhY2ggZWxlbWVudCBpbiBzZXQgaW4gZm9ybWF0IGBbYXR0cnMsIGR1cmF0aW9uLCBlYXNpbmcsIGNhbGxiYWNrXWBcbiAgICAgPiBVc2FnZVxuICAgICB8IC8vIGFuaW1hdGUgYWxsIGVsZW1lbnRzIGluIHNldCB0byByYWRpdXMgMTBcbiAgICAgfCBzZXQuYW5pbWF0ZSh7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluKTtcbiAgICAgfCAvLyBvclxuICAgICB8IC8vIGFuaW1hdGUgZmlyc3QgZWxlbWVudCB0byByYWRpdXMgMTAsIGJ1dCBzZWNvbmQgdG8gcmFkaXVzIDIwIGFuZCBpbiBkaWZmZXJlbnQgdGltZVxuICAgICB8IHNldC5hbmltYXRlKFt7cjogMTB9LCA1MDAsIG1pbmEuZWFzZWluXSwgW3tyOiAyMH0sIDE1MDAsIG1pbmEuZWFzZWluXSk7XG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIFNuYXAuXy5BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXR0cnMuY2FsbGJhY2s7XG4gICAgICAgICAgICBlYXNpbmcgPSBhdHRycy5lYXNpbmc7XG4gICAgICAgICAgICBtcyA9IGVhc2luZy5kdXI7XG4gICAgICAgICAgICBhdHRycyA9IGF0dHJzLmF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChTbmFwLmlzKGF0dHJzLCBcImFycmF5XCIpICYmIFNuYXAuaXMoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJlZ2luLFxuICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iID0gYmVnaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSB0aGlzLmI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNiID0gMCxcbiAgICAgICAgICAgIHNldCA9IHRoaXMsXG4gICAgICAgICAgICBjYWxsYmFja2VyID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgrK2NiID09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgZXZlLm9uY2UoXCJzbmFwLmFuaW1jcmVhdGVkLlwiICsgZWwuaWQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldICYmIGVsLmFuaW1hdGUuYXBwbHkoZWwsIGFyZ3NbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbC5hbmltYXRlKGF0dHJzLCBtcywgZWFzaW5nLCBjYWxsYmFja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnJlbW92ZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIHNldC5cbiAgICAgKlxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wKCkucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmJpbmRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFNwZWNpZmllcyBob3cgdG8gaGFuZGxlIGEgc3BlY2lmaWMgYXR0cmlidXRlIHdoZW4gYXBwbGllZFxuICAgICAqIHRvIGEgc2V0LlxuICAgICAqXG4gICAgICoqXG4gICAgIC0gYXR0ciAoc3RyaW5nKSBhdHRyaWJ1dGUgbmFtZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgZnVuY3Rpb24gdG8gcnVuXG4gICAgICogb3JcbiAgICAgLSBhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBuYW1lXG4gICAgIC0gZWxlbWVudCAoRWxlbWVudCkgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGUgc2V0IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgKiBvclxuICAgICAtIGF0dHIgKHN0cmluZykgYXR0cmlidXRlIG5hbWVcbiAgICAgLSBlbGVtZW50IChFbGVtZW50KSBzcGVjaWZpYyBlbGVtZW50IGluIHRoZSBzZXQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAtIGVhdHRyIChzdHJpbmcpIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCB0byBiaW5kIHRoZSBhdHRyaWJ1dGUgdG9cbiAgICAgPSAob2JqZWN0KSBTZXQgb2JqZWN0XG4gICAgXFwqL1xuICAgIHNldHByb3RvLmJpbmQgPSBmdW5jdGlvbiAoYXR0ciwgYSwgYikge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2F0dHJdID0gYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmFtZSA9IGIgfHwgYXR0cjtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbYXR0cl0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGRhdGFbYW5hbWVdID0gdjtcbiAgICAgICAgICAgICAgICBhLmF0dHIoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5hdHRyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBFcXVpdmFsZW50IG9mIEBFbGVtZW50LmF0dHIuXG4gICAgID0gKG9iamVjdCkgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5hdHRyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB1bmJvdW5kID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW2tdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1trXSh2YWx1ZVtrXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuYm91bmRba10gPSB2YWx1ZVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0uYXR0cih1bmJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTZXQuY2xlYXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LnNwbGljZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyByYW5nZSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBpbmRleCAobnVtYmVyKSBwb3NpdGlvbiBvZiB0aGUgZGVsZXRpb25cbiAgICAgLSBjb3VudCAobnVtYmVyKSBudW1iZXIgb2YgZWxlbWVudCB0byByZW1vdmVcbiAgICAgLSBpbnNlcnRpb27igKYgKG9iamVjdCkgI29wdGlvbmFsIGVsZW1lbnRzIHRvIGluc2VydFxuICAgICA9IChvYmplY3QpIHNldCBlbGVtZW50cyB0aGF0IHdlcmUgZGVsZXRlZFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5zcGxpY2UgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBpbnNlcnRpb24pIHtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBtbWF4KHRoaXMubGVuZ3RoICsgaW5kZXgsIDApIDogaW5kZXg7XG4gICAgICAgIGNvdW50ID0gbW1heCgwLCBtbWluKHRoaXMubGVuZ3RoIC0gaW5kZXgsIGNvdW50KSk7XG4gICAgICAgIHZhciB0YWlsID0gW10sXG4gICAgICAgICAgICB0b2RlbCA9IFtdLFxuICAgICAgICAgICAgYXJncyA9IFtdLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvZGVsLnB1c2godGhpc1tpbmRleCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdGFpbC5wdXNoKHRoaXNbaW5kZXggKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuICsgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleCArIGldID0gdGhpc1tpbmRleCArIGldID0gaSA8IGFyZ2xlbiA/IGFyZ3NbaV0gOiB0YWlsW2kgLSBhcmdsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCA9IHRoaXMubGVuZ3RoIC09IGNvdW50IC0gYXJnbGVuO1xuICAgICAgICB3aGlsZSAodGhpc1tpXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaSsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNldCh0b2RlbCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmV4Y2x1ZGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZWxlbWVudCBmcm9tIHRoZSBzZXRcbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCBpZiBvYmplY3Qgd2FzIGZvdW5kIGFuZCByZW1vdmVkIGZyb20gdGhlIHNldFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5leGNsdWRlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKHRoaXNbaV0gPT0gZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNldC5pbnNlcnRBZnRlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogSW5zZXJ0cyBzZXQgZWxlbWVudHMgYWZ0ZXIgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKipcbiAgICAgLSBlbGVtZW50IChvYmplY3QpIHNldCB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgZWxlbWVudFxuICAgICA9IChvYmplY3QpIFNldCBvYmplY3RcbiAgICBcXCovXG4gICAgc2V0cHJvdG8uaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5pbnNlcnRBZnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0LmdldEJCb3hcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFVuaW9uIG9mIGFsbCBiYm94ZXMgb2YgdGhlIHNldC4gU2VlIEBFbGVtZW50LmdldEJCb3guXG4gICAgID0gKG9iamVjdCkgYm91bmRpbmcgYm94IGRlc2NyaXB0b3IuIFNlZSBARWxlbWVudC5nZXRCQm94LlxuICAgIFxcKi9cbiAgICBzZXRwcm90by5nZXRCQm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeCA9IFtdLFxuICAgICAgICAgICAgeSA9IFtdLFxuICAgICAgICAgICAgeDIgPSBbXSxcbiAgICAgICAgICAgIHkyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaS0tOykgaWYgKCF0aGlzLml0ZW1zW2ldLnJlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSB0aGlzLml0ZW1zW2ldLmdldEJCb3goKTtcbiAgICAgICAgICAgIHgucHVzaChib3gueCk7XG4gICAgICAgICAgICB5LnB1c2goYm94LnkpO1xuICAgICAgICAgICAgeDIucHVzaChib3gueCArIGJveC53aWR0aCk7XG4gICAgICAgICAgICB5Mi5wdXNoKGJveC55ICsgYm94LmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgeCA9IG1taW4uYXBwbHkoMCwgeCk7XG4gICAgICAgIHkgPSBtbWluLmFwcGx5KDAsIHkpO1xuICAgICAgICB4MiA9IG1tYXguYXBwbHkoMCwgeDIpO1xuICAgICAgICB5MiA9IG1tYXguYXBwbHkoMCwgeTIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICB4MjogeDIsXG4gICAgICAgICAgICB5MjogeTIsXG4gICAgICAgICAgICB3aWR0aDogeDIgLSB4LFxuICAgICAgICAgICAgaGVpZ2h0OiB5MiAtIHksXG4gICAgICAgICAgICBjeDogeCArICh4MiAtIHgpIC8gMixcbiAgICAgICAgICAgIGN5OiB5ICsgKHkyIC0geSkgLyAyXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU2V0Lmluc2VydEFmdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIHNldC5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgIFxcKi9cbiAgICBzZXRwcm90by5jbG9uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHMgPSBuZXcgU2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHMucHVzaCh0aGlzLml0ZW1zW2ldLmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgc2V0cHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlNuYXBcXHUyMDE4cyBzZXRcIjtcbiAgICB9O1xuICAgIHNldHByb3RvLnR5cGUgPSBcInNldFwiO1xuICAgIC8vIGV4cG9ydFxuICAgIC8qXFxcbiAgICAgKiBTbmFwLlNldFxuICAgICBbIHByb3BlcnR5IF1cbiAgICAgKipcbiAgICAgKiBTZXQgY29uc3RydWN0b3IuXG4gICAgXFwqL1xuICAgIFNuYXAuU2V0ID0gU2V0O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLnNldFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBhbmQgZmlsbHMgaXQgd2l0aCBsaXN0IG9mIGFyZ3VtZW50cy5cbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBOZXcgU2V0IG9iamVjdFxuICAgICB8IHZhciByID0gcGFwZXIucmVjdCgwLCAwLCAxMCwgMTApLFxuICAgICB8ICAgICBzMSA9IFNuYXAuc2V0KCksIC8vIGVtcHR5IHNldFxuICAgICB8ICAgICBzMiA9IFNuYXAuc2V0KHIsIHBhcGVyLmNpcmNsZSgxMDAsIDEwMCwgMjApKTsgLy8gcHJlZmlsbGVkIHNldFxuICAgIFxcKi9cbiAgICBTbmFwLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQ7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXQucHVzaC5hcHBseShzZXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICB2YXIgbmFtZXMgPSB7fSxcbiAgICAgICAgcmVVbml0ID0gL1slYS16XSskL2ksXG4gICAgICAgIFN0ciA9IFN0cmluZztcbiAgICBuYW1lcy5zdHJva2UgPSBuYW1lcy5maWxsID0gXCJjb2xvdXJcIjtcbiAgICBmdW5jdGlvbiBnZXRFbXB0eShpdGVtKSB7XG4gICAgICAgIHZhciBsID0gaXRlbVswXTtcbiAgICAgICAgc3dpdGNoIChsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6IHJldHVybiBbbCwgMCwgMF07XG4gICAgICAgICAgICBjYXNlIFwibVwiOiByZXR1cm4gW2wsIDEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAgICAgICAgY2FzZSBcInJcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDAsIGl0ZW1bMl0sIGl0ZW1bM11dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInNcIjogaWYgKGl0ZW0ubGVuZ3RoID09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2wsIDEsIDEsIGl0ZW1bM10sIGl0ZW1bNF1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxLCAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsLCAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVhbGlzZVRyYW5zZm9ybSh0MSwgdDIsIGdldEJCb3gpIHtcbiAgICAgICAgdDEgPSB0MSB8fCBuZXcgU25hcC5NYXRyaXg7XG4gICAgICAgIHQyID0gdDIgfHwgbmV3IFNuYXAuTWF0cml4O1xuICAgICAgICB0MSA9IFNuYXAucGFyc2VUcmFuc2Zvcm1TdHJpbmcodDEudG9UcmFuc2Zvcm1TdHJpbmcoKSkgfHwgW107XG4gICAgICAgIHQyID0gU25hcC5wYXJzZVRyYW5zZm9ybVN0cmluZyh0Mi50b1RyYW5zZm9ybVN0cmluZygpKSB8fCBbXTtcbiAgICAgICAgdmFyIG1heGxlbmd0aCA9IE1hdGgubWF4KHQxLmxlbmd0aCwgdDIubGVuZ3RoKSxcbiAgICAgICAgICAgIGZyb20gPSBbXSxcbiAgICAgICAgICAgIHRvID0gW10sXG4gICAgICAgICAgICBpID0gMCwgaiwgamosXG4gICAgICAgICAgICB0dDEsIHR0MjtcbiAgICAgICAgZm9yICg7IGkgPCBtYXhsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHQxID0gdDFbaV0gfHwgZ2V0RW1wdHkodDJbaV0pO1xuICAgICAgICAgICAgdHQyID0gdDJbaV0gfHwgZ2V0RW1wdHkodHQxKTtcbiAgICAgICAgICAgIGlmICh0dDFbMF0gIT0gdHQyWzBdIHx8XG4gICAgICAgICAgICAgICAgdHQxWzBdLnRvTG93ZXJDYXNlKCkgPT0gXCJyXCIgJiYgKHR0MVsyXSAhPSB0dDJbMl0gfHwgdHQxWzNdICE9IHR0MlszXSkgfHxcbiAgICAgICAgICAgICAgICB0dDFbMF0udG9Mb3dlckNhc2UoKSA9PSBcInNcIiAmJiAodHQxWzNdICE9IHR0MlszXSB8fCB0dDFbNF0gIT0gdHQyWzRdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0MSA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQxLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICB0MiA9IFNuYXAuXy50cmFuc2Zvcm0ybWF0cml4KHQyLCBnZXRCQm94KCkpO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gW1tcIm1cIiwgdDEuYSwgdDEuYiwgdDEuYywgdDEuZCwgdDEuZSwgdDEuZl1dO1xuICAgICAgICAgICAgICAgICAgICB0byA9IFtbXCJtXCIsIHQyLmEsIHQyLmIsIHQyLmMsIHQyLmQsIHQyLmUsIHQyLmZdXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tW2ldID0gW107XG4gICAgICAgICAgICB0b1tpXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChqID0gMCwgamogPSBNYXRoLm1heCh0dDEubGVuZ3RoLCB0dDIubGVuZ3RoKTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICBqIGluIHR0MSAmJiAoZnJvbVtpXVtqXSA9IHR0MVtqXSk7XG4gICAgICAgICAgICAgICAgaiBpbiB0dDIgJiYgKHRvW2ldW2pdID0gdHQyW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShmcm9tKSxcbiAgICAgICAgICAgIHRvOiBwYXRoMmFycmF5KHRvKSxcbiAgICAgICAgICAgIGY6IGdldFBhdGgoZnJvbSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TnVtYmVyKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRVbml0KHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiArdmFsLnRvRml4ZWQoMykgKyB1bml0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3Qm94KHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb2xvdXIoY2xyKSB7XG4gICAgICAgIHJldHVybiBTbmFwLnJnYihjbHJbMF0sIGNsclsxXSwgY2xyWzJdLCBjbHJbM10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQYXRoKHBhdGgpIHtcbiAgICAgICAgdmFyIGsgPSAwLCBpLCBpaSwgaiwgamosIG91dCwgYSwgYiA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IHBhdGgubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgb3V0ID0gXCJbXCI7XG4gICAgICAgICAgICBhID0gWydcIicgKyBwYXRoW2ldWzBdICsgJ1wiJ107XG4gICAgICAgICAgICBmb3IgKGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGFbal0gPSBcInZhbFtcIiArIGsrKyArIFwiXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IGEgKyBcIl1cIjtcbiAgICAgICAgICAgIGJbaV0gPSBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwidmFsXCIsIFwicmV0dXJuIFNuYXAucGF0aC50b1N0cmluZy5jYWxsKFtcIiArIGIgKyBcIl0pXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXRoMmFycmF5KHBhdGgpIHtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXRoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxLCBqaiA9IHBhdGhbaV0ubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHBhdGhbaV1bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICAgICAgICBpZiAoIVNuYXAuaXMoYXJyMSwgXCJhcnJheVwiKSB8fCAhU25hcC5pcyhhcnIyLCBcImFycmF5XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjEudG9TdHJpbmcoKSA9PSBhcnIyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIEVsZW1lbnQucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKG5hbWUsIGIpIHtcbiAgICAgICAgcmV0dXJuIGV2ZShcInNuYXAudXRpbC5lcXVhbFwiLCB0aGlzLCBuYW1lLCBiKS5maXJzdERlZmluZWQoKTtcbiAgICB9O1xuICAgIGV2ZS5vbihcInNuYXAudXRpbC5lcXVhbFwiLCBmdW5jdGlvbiAobmFtZSwgYikge1xuICAgICAgICB2YXIgQSwgQiwgYSA9IFN0cih0aGlzLmF0dHIobmFtZSkgfHwgXCJcIiksXG4gICAgICAgICAgICBlbCA9IHRoaXM7XG4gICAgICAgIGlmIChuYW1lc1tuYW1lXSA9PSBcImNvbG91clwiKSB7XG4gICAgICAgICAgICBBID0gU25hcC5jb2xvcihhKTtcbiAgICAgICAgICAgIEIgPSBTbmFwLmNvbG9yKGIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBbQS5yLCBBLmcsIEEuYiwgQS5vcGFjaXR5XSxcbiAgICAgICAgICAgICAgICB0bzogW0IuciwgQi5nLCBCLmIsIEIub3BhY2l0eV0sXG4gICAgICAgICAgICAgICAgZjogZ2V0Q29sb3VyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidmlld0JveFwiKSB7XG4gICAgICAgICAgICBBID0gdGhpcy5hdHRyKG5hbWUpLnZiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIEIgPSBiLnNwbGl0KFwiIFwiKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogQSxcbiAgICAgICAgICAgICAgICB0bzogQixcbiAgICAgICAgICAgICAgICBmOiBnZXRWaWV3Qm94XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwidHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcImdyYWRpZW50VHJhbnNmb3JtXCIgfHwgbmFtZSA9PSBcInBhdHRlcm5UcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBiID0gU3RyKGIpLnJlcGxhY2UoL1xcLnszfXxcXHUyMDI2L2csIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IHRoaXMubWF0cml4O1xuICAgICAgICAgICAgaWYgKCFTbmFwLl8ucmdUcmFuc2Zvcm0udGVzdChiKSkge1xuICAgICAgICAgICAgICAgIGIgPSBTbmFwLl8udHJhbnNmb3JtMm1hdHJpeChTbmFwLl8uc3ZnVHJhbnNmb3JtMnN0cmluZyhiKSwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gU25hcC5fLnRyYW5zZm9ybTJtYXRyaXgoYiwgdGhpcy5nZXRCQm94KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVxdWFsaXNlVHJhbnNmb3JtKGEsIGIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0QkJveCgxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwiZFwiIHx8IG5hbWUgPT0gXCJwYXRoXCIpIHtcbiAgICAgICAgICAgIEEgPSBTbmFwLnBhdGgudG9DdWJpYyhhLCBiKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZnJvbTogcGF0aDJhcnJheShBWzBdKSxcbiAgICAgICAgICAgICAgICB0bzogcGF0aDJhcnJheShBWzFdKSxcbiAgICAgICAgICAgICAgICBmOiBnZXRQYXRoKEFbMF0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09IFwicG9pbnRzXCIpIHtcbiAgICAgICAgICAgIEEgPSBTdHIoYSkuc3BsaXQoU25hcC5fLnNlcGFyYXRvcik7XG4gICAgICAgICAgICBCID0gU3RyKGIpLnNwbGl0KFNuYXAuXy5zZXBhcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBBLFxuICAgICAgICAgICAgICAgIHRvOiBCLFxuICAgICAgICAgICAgICAgIGY6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1lcmljKGEpICYmIGlzTnVtZXJpYyhiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICAgICAgICAgIHRvOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYVVuaXQgPSBhLm1hdGNoKHJlVW5pdCksXG4gICAgICAgICAgICBiVW5pdCA9IFN0cihiKS5tYXRjaChyZVVuaXQpO1xuICAgICAgICBpZiAoYVVuaXQgJiYgYXJyYXlFcXVhbChhVW5pdCwgYlVuaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHBhcnNlRmxvYXQoYSksXG4gICAgICAgICAgICAgICAgdG86IHBhcnNlRmxvYXQoYiksXG4gICAgICAgICAgICAgICAgZjogZ2V0VW5pdChhVW5pdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IHRoaXMuYXNQWChuYW1lKSxcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hc1BYKG5hbWUsIGIpLFxuICAgICAgICAgICAgICAgIGY6IGdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy8gXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vIFxuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIHN1cHBvcnRzVG91Y2ggPSBcImNyZWF0ZVRvdWNoXCIgaW4gZ2xvYi5kb2MsXG4gICAgZXZlbnRzID0gW1xuICAgICAgICBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZWRvd25cIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLFxuICAgICAgICBcIm1vdXNlb3ZlclwiLCBcIm1vdXNldXBcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIixcbiAgICAgICAgXCJ0b3VjaGNhbmNlbFwiXG4gICAgXSxcbiAgICB0b3VjaE1hcCA9IHtcbiAgICAgICAgbW91c2Vkb3duOiBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgbW91c2Vtb3ZlOiBcInRvdWNobW92ZVwiLFxuICAgICAgICBtb3VzZXVwOiBcInRvdWNoZW5kXCJcbiAgICB9LFxuICAgIGdldFNjcm9sbCA9IGZ1bmN0aW9uICh4eSwgZWwpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB4eSA9PSBcInlcIiA/IFwic2Nyb2xsVG9wXCIgOiBcInNjcm9sbExlZnRcIixcbiAgICAgICAgICAgIGRvYyA9IGVsICYmIGVsLm5vZGUgPyBlbC5ub2RlLm93bmVyRG9jdW1lbnQgOiBnbG9iLmRvYztcbiAgICAgICAgcmV0dXJuIGRvY1tuYW1lIGluIGRvYy5kb2N1bWVudEVsZW1lbnQgPyBcImRvY3VtZW50RWxlbWVudFwiIDogXCJib2R5XCJdW25hbWVdO1xuICAgIH0sXG4gICAgcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9LFxuICAgIHByZXZlbnRUb3VjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBzdG9wVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChvYmosIHR5cGUsIGZuLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciByZWFsTmFtZSA9IHN1cHBvcnRzVG91Y2ggJiYgdG91Y2hNYXBbdHlwZV0gPyB0b3VjaE1hcFt0eXBlXSA6IHR5cGUsXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IGdldFNjcm9sbChcInlcIiwgZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoICYmIHRvdWNoTWFwW2hhc10odHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzW2ldLnRhcmdldCA9PSBvYmogfHwgb2JqLmNvbnRhaW5zKGUudGFyZ2V0VG91Y2hlc1tpXS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZGUgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBlLnRhcmdldFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50ID0gb2xkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gcHJldmVudFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFRvdWNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5jbGllbnRYICsgc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGUuY2xpZW50WSArIHNjcm9sbFk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbWVudCwgZSwgeCwgeSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlICE9PSByZWFsTmFtZSkge1xuICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIocmVhbE5hbWUsIGYsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHJlYWxOYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWFsTmFtZSwgZiwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkcmFnID0gW10sXG4gICAgZHJhZ01vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgICBzY3JvbGxZID0gZ2V0U2Nyb2xsKFwieVwiKSxcbiAgICAgICAgICAgIHNjcm9sbFggPSBnZXRTY3JvbGwoXCJ4XCIpLFxuICAgICAgICAgICAgZHJhZ2ksXG4gICAgICAgICAgICBqID0gZHJhZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIGRyYWdpID0gZHJhZ1tqXTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUudG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT0gZHJhZ2kuZWwuX2RyYWcuaWQgfHwgZHJhZ2kuZWwubm9kZS5jb250YWlucyh0b3VjaC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgKGUub3JpZ2luYWxFdmVudCA/IGUub3JpZ2luYWxFdmVudCA6IGUpLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkcmFnaS5lbC5ub2RlLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAvLyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIC8vIG8gPSBkcmFnaS5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIG5vZGUuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgICAgICAvLyBnbG9iLndpbi5vcGVyYSAmJiAobmV4dCA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgLy8gbyAmJiBldmUoXCJzbmFwLmRyYWcub3Zlci5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbCwgbyk7XG4gICAgICAgICAgICB4ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICB5ICs9IHNjcm9sbFk7XG4gICAgICAgICAgICBldmUoXCJzbmFwLmRyYWcubW92ZS5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5tb3ZlX3Njb3BlIHx8IGRyYWdpLmVsLCB4IC0gZHJhZ2kuZWwuX2RyYWcueCwgeSAtIGRyYWdpLmVsLl9kcmFnLnksIHgsIHksIGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkcmFnVXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBTbmFwLnVubW91c2Vtb3ZlKGRyYWdNb3ZlKS51bm1vdXNldXAoZHJhZ1VwKTtcbiAgICAgICAgdmFyIGkgPSBkcmFnLmxlbmd0aCxcbiAgICAgICAgICAgIGRyYWdpO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBkcmFnaSA9IGRyYWdbaV07XG4gICAgICAgICAgICBkcmFnaS5lbC5fZHJhZyA9IHt9O1xuICAgICAgICAgICAgZXZlKFwic25hcC5kcmFnLmVuZC5cIiArIGRyYWdpLmVsLmlkLCBkcmFnaS5lbmRfc2NvcGUgfHwgZHJhZ2kuc3RhcnRfc2NvcGUgfHwgZHJhZ2kubW92ZV9zY29wZSB8fCBkcmFnaS5lbCwgZSk7XG4gICAgICAgICAgICBldmUub2ZmKFwic25hcC5kcmFnLiouXCIgKyBkcmFnaS5lbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZyA9IFtdO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBjbGljayBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuZGJsY2xpY2tcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBkb3VibGUgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bmRibGNsaWNrXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgZG91YmxlIGNsaWNrIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZWRvd25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSBtb3VzZWRvd24gZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlZG93blxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNlZG93biBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQubW91c2Vtb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2Vtb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW5tb3VzZW1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSBtb3VzZW1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bm1vdXNlb3V0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdXQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50Lm1vdXNlb3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQWRkcyBhIG1vdXNlb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2VvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgbW91c2VvdmVyIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICBcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5tb3VzZXVwXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgbW91c2V1cCBldmVudCBoYW5kbGVyIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVubW91c2V1cFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhIG1vdXNldXAgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoc3RhcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFkZHMgYSB0b3VjaHN0YXJ0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaHN0YXJ0XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hzdGFydCBldmVudCBoYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudG91Y2htb3ZlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2htb3ZlIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVsZW1lbnRcbiAgICAgLSBoYW5kbGVyIChmdW5jdGlvbikgaGFuZGxlciBmb3IgdGhlIGV2ZW50XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQudW50b3VjaG1vdmVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgYSB0b3VjaG1vdmUgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoZW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hlbmQgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIFxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciB0byB0aGUgZWxlbWVudFxuICAgICAtIGhhbmRsZXIgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciB0aGUgZXZlbnRcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgIFxcKi9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC51bnRvdWNoY2FuY2VsXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZW1vdmVzIGEgdG91Y2hjYW5jZWwgZXZlbnQgaGFuZGxlciBmcm9tIHRoZSBlbGVtZW50XG4gICAgIC0gaGFuZGxlciAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIHRoZSBldmVudFxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGZvciAodmFyIGkgPSBldmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBTbmFwW2V2ZW50TmFtZV0gPSBlbHByb3RvW2V2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFNuYXAuaXMoZm4sIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmOiBmbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuYmluZDogYWRkRXZlbnQodGhpcy5ub2RlIHx8IGRvY3VtZW50LCBldmVudE5hbWUsIGZuLCBzY29wZSB8fCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmV2ZW50cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAodGhpcy5ldmVudHNbaV0ubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbaV0uZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTbmFwW1widW5cIiArIGV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgZWxwcm90b1tcInVuXCIgKyBldmVudE5hbWVdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBsID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobC0tKSBpZiAoZXZlbnRzW2xdLm5hbWUgPT0gZXZlbnROYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50c1tsXS5mID09IGZuIHx8ICFmbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW2xdLnVuYmluZCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaWNlKGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAhZXZlbnRzLmxlbmd0aCAmJiBkZWxldGUgdGhpcy5ldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGV2ZW50c1tpXSk7XG4gICAgfVxuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LmhvdmVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGhvdmVyIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBlbGVtZW50XG4gICAgIC0gZl9pbiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGhvdmVyIGluXG4gICAgIC0gZl9vdXQgKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBvdXRcbiAgICAgLSBpY29udGV4dCAob2JqZWN0KSAjb3B0aW9uYWwgY29udGV4dCBmb3IgaG92ZXIgaW4gaGFuZGxlclxuICAgICAtIG9jb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBob3ZlciBvdXQgaGFuZGxlclxuICAgICA9IChvYmplY3QpIEBFbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaG92ZXIgPSBmdW5jdGlvbiAoZl9pbiwgZl9vdXQsIHNjb3BlX2luLCBzY29wZV9vdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VvdmVyKGZfaW4sIHNjb3BlX2luKS5tb3VzZW91dChmX291dCwgc2NvcGVfb3V0IHx8IHNjb3BlX2luKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuaG92ZXJcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgaG92ZXIgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgZWxlbWVudFxuICAgICAtIGZfaW4gKGZ1bmN0aW9uKSBoYW5kbGVyIGZvciBob3ZlciBpblxuICAgICAtIGZfb3V0IChmdW5jdGlvbikgaGFuZGxlciBmb3IgaG92ZXIgb3V0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by51bmhvdmVyID0gZnVuY3Rpb24gKGZfaW4sIGZfb3V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVubW91c2VvdmVyKGZfaW4pLnVubW91c2VvdXQoZl9vdXQpO1xuICAgIH07XG4gICAgdmFyIGRyYWdnYWJsZSA9IFtdO1xuICAgIC8vIFNJRVJSQSB1bmNsZWFyIHdoYXQgX2NvbnRleHRfIHJlZmVycyB0byBmb3Igc3RhcnRpbmcsIGVuZGluZywgbW92aW5nIHRoZSBkcmFnIGdlc3R1cmUuXG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBfeCBwb3NpdGlvbiBvZiB0aGUgbW91c2VfOiBXaGVyZSBhcmUgdGhlIHgveSB2YWx1ZXMgb2Zmc2V0IGZyb20/XG4gICAgLy8gU0lFUlJBIEVsZW1lbnQuZHJhZygpOiBtdWNoIG9mIHRoaXMgbWVtYmVyJ3MgZG9jIGFwcGVhcnMgdG8gYmUgZHVwbGljYXRlZCBmb3Igc29tZSByZWFzb24uXG4gICAgLy8gU0lFUlJBIFVuY2xlYXIgYWJvdXQgdGhpcyBzZW50ZW5jZTogX0FkZGl0aW9uYWxseSBmb2xsb3dpbmcgZHJhZyBldmVudHMgd2lsbCBiZSB0cmlnZ2VyZWQ6IGRyYWcuc3RhcnQuPGlkPiBvbiBzdGFydCwgZHJhZy5lbmQuPGlkPiBvbiBlbmQgYW5kIGRyYWcubW92ZS48aWQ+IG9uIGV2ZXJ5IG1vdmUuXyBJcyB0aGVyZSBhIGdsb2JhbCBfZHJhZ18gb2JqZWN0IHRvIHdoaWNoIHlvdSBjYW4gYXNzaWduIGhhbmRsZXJzIGtleWVkIGJ5IGFuIGVsZW1lbnQncyBJRD9cbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5kcmFnXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhbiBlbGVtZW50J3MgZHJhZyBnZXN0dXJlXG4gICAgICoqXG4gICAgIC0gb25tb3ZlIChmdW5jdGlvbikgaGFuZGxlciBmb3IgbW92aW5nXG4gICAgIC0gb25zdGFydCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgc3RhcnRcbiAgICAgLSBvbmVuZCAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGRyYWcgZW5kXG4gICAgIC0gbWNvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIG1vdmluZyBoYW5kbGVyXG4gICAgIC0gc2NvbnRleHQgKG9iamVjdCkgI29wdGlvbmFsIGNvbnRleHQgZm9yIGRyYWcgc3RhcnQgaGFuZGxlclxuICAgICAtIGVjb250ZXh0IChvYmplY3QpICNvcHRpb25hbCBjb250ZXh0IGZvciBkcmFnIGVuZCBoYW5kbGVyXG4gICAgICogQWRkaXRpb25hbHkgZm9sbG93aW5nIGBkcmFnYCBldmVudHMgYXJlIHRyaWdnZXJlZDogYGRyYWcuc3RhcnQuPGlkPmAgb24gc3RhcnQsIFxuICAgICAqIGBkcmFnLmVuZC48aWQ+YCBvbiBlbmQgYW5kIGBkcmFnLm1vdmUuPGlkPmAgb24gZXZlcnkgbW92ZS4gV2hlbiBlbGVtZW50IGlzIGRyYWdnZWQgb3ZlciBhbm90aGVyIGVsZW1lbnQgXG4gICAgICogYGRyYWcub3Zlci48aWQ+YCBmaXJlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogU3RhcnQgZXZlbnQgYW5kIHN0YXJ0IGhhbmRsZXIgYXJlIGNhbGxlZCBpbiBzcGVjaWZpZWQgY29udGV4dCBvciBpbiBjb250ZXh0IG9mIHRoZSBlbGVtZW50IHdpdGggZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogTW92ZSBldmVudCBhbmQgbW92ZSBoYW5kbGVyIGFyZSBjYWxsZWQgaW4gc3BlY2lmaWVkIGNvbnRleHQgb3IgaW4gY29udGV4dCBvZiB0aGUgZWxlbWVudCB3aXRoIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgICBvIGR4IChudW1iZXIpIHNoaWZ0IGJ5IHggZnJvbSB0aGUgc3RhcnQgcG9pbnRcbiAgICAgbyBkeSAobnVtYmVyKSBzaGlmdCBieSB5IGZyb20gdGhlIHN0YXJ0IHBvaW50XG4gICAgIG8geCAobnVtYmVyKSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZVxuICAgICBvIHkgKG51bWJlcikgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2VcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgICogRW5kIGV2ZW50IGFuZCBlbmQgaGFuZGxlciBhcmUgY2FsbGVkIGluIHNwZWNpZmllZCBjb250ZXh0IG9yIGluIGNvbnRleHQgb2YgdGhlIGVsZW1lbnQgd2l0aCBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAgICAgbyBldmVudCAob2JqZWN0KSBET00gZXZlbnQgb2JqZWN0XG4gICAgID0gKG9iamVjdCkgQEVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5kcmFnID0gZnVuY3Rpb24gKG9ubW92ZSwgb25zdGFydCwgb25lbmQsIG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlLCBlbmRfc2NvcGUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcztcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zZm9ybTtcbiAgICAgICAgICAgIHJldHVybiBlbC5kcmFnKGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IG9yaWdUcmFuc2Zvcm0gKyAob3JpZ1RyYW5zZm9ybSA/IFwiVFwiIDogXCJ0XCIpICsgW2R4LCBkeV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvcmlnVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0oKS5sb2NhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIChlLm9yaWdpbmFsRXZlbnQgfHwgZSkucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGVsLl9kcmFnLnggPSB4O1xuICAgICAgICAgICAgZWwuX2RyYWcueSA9IHk7XG4gICAgICAgICAgICBlbC5fZHJhZy5pZCA9IGUuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICFkcmFnLmxlbmd0aCAmJiBTbmFwLm1vdXNlbW92ZShkcmFnTW92ZSkubW91c2V1cChkcmFnVXApO1xuICAgICAgICAgICAgZHJhZy5wdXNoKHtlbDogZWwsIG1vdmVfc2NvcGU6IG1vdmVfc2NvcGUsIHN0YXJ0X3Njb3BlOiBzdGFydF9zY29wZSwgZW5kX3Njb3BlOiBlbmRfc2NvcGV9KTtcbiAgICAgICAgICAgIG9uc3RhcnQgJiYgZXZlLm9uKFwic25hcC5kcmFnLnN0YXJ0LlwiICsgZWwuaWQsIG9uc3RhcnQpO1xuICAgICAgICAgICAgb25tb3ZlICYmIGV2ZS5vbihcInNuYXAuZHJhZy5tb3ZlLlwiICsgZWwuaWQsIG9ubW92ZSk7XG4gICAgICAgICAgICBvbmVuZCAmJiBldmUub24oXCJzbmFwLmRyYWcuZW5kLlwiICsgZWwuaWQsIG9uZW5kKTtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZy5zdGFydC5cIiArIGVsLmlkLCBzdGFydF9zY29wZSB8fCBtb3ZlX3Njb3BlIHx8IGVsLCB4LCB5LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KGUsIHgsIHkpIHtcbiAgICAgICAgICAgIGV2ZShcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgZWwsIGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZS5vbihcInNuYXAuZHJhZ2luaXQuXCIgKyBlbC5pZCwgc3RhcnQpO1xuICAgICAgICBlbC5fZHJhZyA9IHt9O1xuICAgICAgICBkcmFnZ2FibGUucHVzaCh7ZWw6IGVsLCBzdGFydDogc3RhcnQsIGluaXQ6IGluaXR9KTtcbiAgICAgICAgZWwubW91c2Vkb3duKGluaXQpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIEVsZW1lbnQub25EcmFnT3ZlclxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU2hvcnRjdXQgdG8gYXNzaWduIGV2ZW50IGhhbmRsZXIgZm9yIGBkcmFnLm92ZXIuPGlkPmAgZXZlbnQsIHdoZXJlIGBpZGAgaXMgdGhlIGVsZW1lbnQncyBgaWRgIChzZWUgQEVsZW1lbnQuaWQpXG4gICAgIC0gZiAoZnVuY3Rpb24pIGhhbmRsZXIgZm9yIGV2ZW50LCBmaXJzdCBhcmd1bWVudCB3b3VsZCBiZSB0aGUgZWxlbWVudCB5b3UgYXJlIGRyYWdnaW5nIG92ZXJcbiAgICBcXCovXG4gICAgLy8gZWxwcm90by5vbkRyYWdPdmVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAvLyAgICAgZiA/IGV2ZS5vbihcInNuYXAuZHJhZy5vdmVyLlwiICsgdGhpcy5pZCwgZikgOiBldmUudW5iaW5kKFwic25hcC5kcmFnLm92ZXIuXCIgKyB0aGlzLmlkKTtcbiAgICAvLyB9O1xuICAgIC8qXFxcbiAgICAgKiBFbGVtZW50LnVuZHJhZ1xuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmVtb3ZlcyBhbGwgZHJhZyBldmVudCBoYW5kbGVycyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8udW5kcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IGRyYWdnYWJsZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIGlmIChkcmFnZ2FibGVbaV0uZWwgPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy51bm1vdXNlZG93bihkcmFnZ2FibGVbaV0uaW5pdCk7XG4gICAgICAgICAgICBkcmFnZ2FibGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgZXZlLnVuYmluZChcInNuYXAuZHJhZy4qLlwiICsgdGhpcy5pZCk7XG4gICAgICAgICAgICBldmUudW5iaW5kKFwic25hcC5kcmFnaW5pdC5cIiArIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgICFkcmFnZ2FibGUubGVuZ3RoICYmIFNuYXAudW5tb3VzZW1vdmUoZHJhZ01vdmUpLnVubW91c2V1cChkcmFnVXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufSk7XG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblNuYXAucGx1Z2luKGZ1bmN0aW9uIChTbmFwLCBFbGVtZW50LCBQYXBlciwgZ2xvYikge1xuICAgIHZhciBlbHByb3RvID0gRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgIHBwcm90byA9IFBhcGVyLnByb3RvdHlwZSxcbiAgICAgICAgcmd1cmwgPSAvXlxccyp1cmxcXCgoLispXFwpLyxcbiAgICAgICAgU3RyID0gU3RyaW5nLFxuICAgICAgICAkID0gU25hcC5fLiQ7XG4gICAgU25hcC5maWx0ZXIgPSB7fTtcbiAgICAvKlxcXG4gICAgICogUGFwZXIuZmlsdGVyXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGEgYDxmaWx0ZXI+YCBlbGVtZW50XG4gICAgICoqXG4gICAgIC0gZmlsc3RyIChzdHJpbmcpIFNWRyBmcmFnbWVudCBvZiBmaWx0ZXIgcHJvdmlkZWQgYXMgYSBzdHJpbmdcbiAgICAgPSAob2JqZWN0KSBARWxlbWVudFxuICAgICAqIE5vdGU6IEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBmaWx0ZXJzIGVtYmVkZGVkIGludG8gdGhlIHBhZ2UgaW5zaWRlIGFuIGVtcHR5IFNWRyBlbGVtZW50LlxuICAgICA+IFVzYWdlXG4gICAgIHwgdmFyIGYgPSBwYXBlci5maWx0ZXIoJzxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCIyXCIvPicpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBwcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gKGZpbHN0cikge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzO1xuICAgICAgICBpZiAocGFwZXIudHlwZSAhPSBcInN2Z1wiKSB7XG4gICAgICAgICAgICBwYXBlciA9IHBhcGVyLnBhcGVyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gU25hcC5wYXJzZShTdHIoZmlsc3RyKSksXG4gICAgICAgICAgICBpZCA9IFNuYXAuXy5pZCgpLFxuICAgICAgICAgICAgd2lkdGggPSBwYXBlci5ub2RlLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gcGFwZXIubm9kZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBmaWx0ZXIgPSAkKFwiZmlsdGVyXCIpO1xuICAgICAgICAkKGZpbHRlciwge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZmlsdGVyVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGYubm9kZSk7XG4gICAgICAgIHBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQoZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGZpbHRlcik7XG4gICAgfTtcblxuICAgIGV2ZS5vbihcInNuYXAudXRpbC5nZXRhdHRyLmZpbHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV2ZS5zdG9wKCk7XG4gICAgICAgIHZhciBwID0gJCh0aGlzLm5vZGUsIFwiZmlsdGVyXCIpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gU3RyKHApLm1hdGNoKHJndXJsKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaCAmJiBTbmFwLnNlbGVjdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBldmUub24oXCJzbmFwLnV0aWwuYXR0ci5maWx0ZXJcIiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdmFsdWUudHlwZSA9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICBldmUuc3RvcCgpO1xuICAgICAgICAgICAgdmFyIGlkID0gdmFsdWUubm9kZS5pZDtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICAkKHZhbHVlLm5vZGUsIHtpZDogdmFsdWUuaWR9KTtcbiAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IFNuYXAudXJsKGlkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgZXZlLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuYmx1clxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGJsdXIgZmlsdGVyXG4gICAgICoqXG4gICAgIC0geCAobnVtYmVyKSBhbW91bnQgb2YgaG9yaXpvbnRhbCBibHVyLCBpbiBwaXhlbHNcbiAgICAgLSB5IChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgdmVydGljYWwgYmx1ciwgaW4gcGl4ZWxzXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgID4gVXNhZ2VcbiAgICAgfCB2YXIgZiA9IHBhcGVyLmZpbHRlcihTbmFwLmZpbHRlci5ibHVyKDUsIDEwKSksXG4gICAgIHwgICAgIGMgPSBwYXBlci5jaXJjbGUoMTAsIDEwLCAxMCkuYXR0cih7XG4gICAgIHwgICAgICAgICBmaWx0ZXI6IGZcbiAgICAgfCAgICAgfSk7XG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJsdXIgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PSBudWxsKSB7XG4gICAgICAgICAgICB4ID0gMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmID0geSA9PSBudWxsID8geCA6IFt4LCB5XTtcbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCdcXDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCJ7ZGVmfVwiLz4nLCB7XG4gICAgICAgICAgICBkZWY6IGRlZlxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJsdXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2hhZG93XG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2hhZG93IGZpbHRlclxuICAgICAqKlxuICAgICAtIGR4IChudW1iZXIpICNvcHRpb25hbCBob3Jpem9udGFsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGR5IChudW1iZXIpICNvcHRpb25hbCB2ZXJ0aWNhbCBzaGlmdCBvZiB0aGUgc2hhZG93LCBpbiBwaXhlbHNcbiAgICAgLSBibHVyIChudW1iZXIpICNvcHRpb25hbCBhbW91bnQgb2YgYmx1clxuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIG9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIGNvbG9yIChzdHJpbmcpICNvcHRpb25hbCBjb2xvciBvZiB0aGUgc2hhZG93XG4gICAgIC0gb3BhY2l0eSAobnVtYmVyKSAjb3B0aW9uYWwgYDAuLjFgIG9wYWNpdHkgb2YgdGhlIHNoYWRvd1xuICAgICAqIHdoaWNoIG1ha2VzIGJsdXIgZGVmYXVsdCB0byBgNGAuIE9yXG4gICAgIC0gZHggKG51bWJlcikgI29wdGlvbmFsIGhvcml6b250YWwgc2hpZnQgb2YgdGhlIHNoYWRvdywgaW4gcGl4ZWxzXG4gICAgIC0gZHkgKG51bWJlcikgI29wdGlvbmFsIHZlcnRpY2FsIHNoaWZ0IG9mIHRoZSBzaGFkb3csIGluIHBpeGVsc1xuICAgICAtIG9wYWNpdHkgKG51bWJlcikgI29wdGlvbmFsIGAwLi4xYCBvcGFjaXR5IG9mIHRoZSBzaGFkb3dcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICAgPiBVc2FnZVxuICAgICB8IHZhciBmID0gcGFwZXIuZmlsdGVyKFNuYXAuZmlsdGVyLnNoYWRvdygwLCAyLCAuMykpLFxuICAgICB8ICAgICBjID0gcGFwZXIuY2lyY2xlKDEwLCAxMCwgMTApLmF0dHIoe1xuICAgICB8ICAgICAgICAgZmlsdGVyOiBmXG4gICAgIHwgICAgIH0pO1xuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zaGFkb3cgPSBmdW5jdGlvbiAoZHgsIGR5LCBibHVyLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBibHVyO1xuICAgICAgICAgICAgICAgIGJsdXIgPSA0O1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjMDAwXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGJsdXI7XG4gICAgICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYmx1ciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IFNuYXAuY29sb3IoY29sb3IpO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwie2JsdXJ9XCIvPjxmZU9mZnNldCBkeD1cIntkeH1cIiBkeT1cIntkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwie2NvbG9yfVwiLz48ZmVDb21wb3NpdGUgaW4yPVwib2Zmc2V0Ymx1clwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY0EgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie29wYWNpdHl9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPicsIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgIGR5OiBkeSxcbiAgICAgICAgICAgIGJsdXI6IGJsdXIsXG4gICAgICAgICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2hhZG93LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmdyYXlzY2FsZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgbWFya3VwIHN0cmluZyBmb3IgdGhlIGdyYXlzY2FsZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5ncmF5c2NhbGUgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7Yn0ge2h9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuZ3JheXNjYWxlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLnNlcGlhXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgc2VwaWEgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuc2VwaWEgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCJ7YX0ge2J9IHtjfSAwIDAge2R9IHtlfSB7Zn0gMCAwIHtnfSB7aH0ge2l9IDAgMCAwIDAgMCAxIDBcIi8+Jywge1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2VwaWEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuc2F0dXJhdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBzYXR1cmF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5zYXR1cmF0ZSA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwie2Ftb3VudH1cIi8+Jywge1xuICAgICAgICAgICAgYW1vdW50OiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuc2F0dXJhdGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuaHVlUm90YXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGFuIFNWRyBtYXJrdXAgc3RyaW5nIGZvciB0aGUgaHVlLXJvdGF0ZSBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbmdsZSAobnVtYmVyKSBhbmdsZSBvZiByb3RhdGlvblxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCJ7YW5nbGV9XCIvPicsIHtcbiAgICAgICAgICAgIGFuZ2xlOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmh1ZVJvdGF0ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMoKTtcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZpbHRlci5pbnZlcnRcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBpbnZlcnQgZmlsdGVyXG4gICAgICoqXG4gICAgIC0gYW1vdW50IChudW1iZXIpIGFtb3VudCBvZiBmaWx0ZXIgKGAwLi4xYClcbiAgICAgPSAoc3RyaW5nKSBmaWx0ZXIgcmVwcmVzZW50YXRpb25cbiAgICBcXCovXG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0ID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFtb3VudCA9IDE7XG4gICAgICAgIH1cbi8vICAgICAgICA8ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiLTEgMCAwIDAgMSAgMCAtMSAwIDAgMSAgMCAwIC0xIDAgMSAgMCAwIDAgMSAwXCIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPVwic1JHQlwiLz5cbiAgICAgICAgcmV0dXJuIFNuYXAuZm9ybWF0KCc8ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cInthbW91bnR9IHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+Jywge1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuaW52ZXJ0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcygpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIFNuYXAuZmlsdGVyLmJyaWdodG5lc3NcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBicmlnaHRuZXNzIGZpbHRlclxuICAgICAqKlxuICAgICAtIGFtb3VudCAobnVtYmVyKSBhbW91bnQgb2YgZmlsdGVyIChgMC4uMWApXG4gICAgID0gKHN0cmluZykgZmlsdGVyIHJlcHJlc2VudGF0aW9uXG4gICAgXFwqL1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYW1vdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU25hcC5mb3JtYXQoJzxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cInthbW91bnR9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj4nLCB7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNuYXAuZmlsdGVyLmJyaWdodG5lc3MudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogU25hcC5maWx0ZXIuY29udHJhc3RcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJldHVybnMgYW4gU1ZHIG1hcmt1cCBzdHJpbmcgZm9yIHRoZSBjb250cmFzdCBmaWx0ZXJcbiAgICAgKipcbiAgICAgLSBhbW91bnQgKG51bWJlcikgYW1vdW50IG9mIGZpbHRlciAoYDAuLjFgKVxuICAgICA9IChzdHJpbmcpIGZpbHRlciByZXByZXNlbnRhdGlvblxuICAgIFxcKi9cbiAgICBTbmFwLmZpbHRlci5jb250cmFzdCA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTbmFwLmZvcm1hdCgnPGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwie2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCJ7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPicsIHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU25hcC5maWx0ZXIuY29udHJhc3QudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzKCk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGJveCA9IFNuYXAuXy5ib3gsXG4gICAgICAgIGlzID0gU25hcC5pcyxcbiAgICAgICAgZmlyc3RMZXR0ZXIgPSAvXlteYS16XSooW3RibWxyY10pL2ksXG4gICAgICAgIHRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVFwiICsgdGhpcy5keCArIFwiLFwiICsgdGhpcy5keTtcbiAgICAgICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5nZXRBbGlnblxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogUmV0dXJucyBzaGlmdCBuZWVkZWQgdG8gYWxpZ24gdGhlIGVsZW1lbnQgcmVsYXRpdmVseSB0byBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHNwZWNpZmllZCwgcGFyZW50IGA8c3ZnPmAgY29udGFpbmVyIHdpbGwgYmUgdXNlZC5cbiAgICAgLSBlbCAob2JqZWN0KSBAb3B0aW9uYWwgYWxpZ25tZW50IGVsZW1lbnRcbiAgICAgLSB3YXkgKHN0cmluZykgb25lIG9mIHNpeCB2YWx1ZXM6IGBcInRvcFwiYCwgYFwibWlkZGxlXCJgLCBgXCJib3R0b21cImAsIGBcImxlZnRcImAsIGBcImNlbnRlclwiYCwgYFwicmlnaHRcImBcbiAgICAgPSAob2JqZWN0fHN0cmluZykgT2JqZWN0IGluIGZvcm1hdCBge2R4OiAsIGR5OiB9YCBhbHNvIGhhcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBhIHRyYW5zZm9ybWF0aW9uIHN0cmluZ1xuICAgICA+IFVzYWdlXG4gICAgIHwgZWwudHJhbnNmb3JtKGVsLmdldEFsaWduKGVsMiwgXCJ0b3BcIikpO1xuICAgICAqIG9yXG4gICAgIHwgdmFyIGR5ID0gZWwuZ2V0QWxpZ24oZWwyLCBcInRvcFwiKS5keTtcbiAgICBcXCovXG4gICAgRWxlbWVudC5wcm90b3R5cGUuZ2V0QWxpZ24gPSBmdW5jdGlvbiAoZWwsIHdheSkge1xuICAgICAgICBpZiAod2F5ID09IG51bGwgJiYgaXMoZWwsIFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB3YXkgPSBlbDtcbiAgICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBieCA9IGVsLmdldEJCb3ggPyBlbC5nZXRCQm94KCkgOiBib3goZWwpLFxuICAgICAgICAgICAgYmIgPSB0aGlzLmdldEJCb3goKSxcbiAgICAgICAgICAgIG91dCA9IHt9O1xuICAgICAgICB3YXkgPSB3YXkgJiYgd2F5Lm1hdGNoKGZpcnN0TGV0dGVyKTtcbiAgICAgICAgd2F5ID0gd2F5ID8gd2F5WzFdLnRvTG93ZXJDYXNlKCkgOiBcImNcIjtcbiAgICAgICAgc3dpdGNoICh3YXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC55IC0gYmIueTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICBvdXQuZHggPSAwO1xuICAgICAgICAgICAgICAgIG91dC5keSA9IGJ4LnkyIC0gYmIueTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gMDtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSBieC5jeSAtIGJiLmN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LnggLSBiYi54O1xuICAgICAgICAgICAgICAgIG91dC5keSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgb3V0LmR4ID0gYngueDIgLSBiYi54MjtcbiAgICAgICAgICAgICAgICBvdXQuZHkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dC5keCA9IGJ4LmN4IC0gYmIuY3g7XG4gICAgICAgICAgICAgICAgb3V0LmR5ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG91dC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuYWxpZ25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEFsaWducyB0aGUgZWxlbWVudCByZWxhdGl2ZWx5IHRvIGdpdmVuIG9uZSB2aWEgdHJhbnNmb3JtYXRpb24uXG4gICAgICogSWYgbm8gZWxlbWVudHMgc3BlY2lmaWVkLCBwYXJlbnQgYDxzdmc+YCBjb250YWluZXIgd2lsbCBiZSB1c2VkLlxuICAgICAtIGVsIChvYmplY3QpIEBvcHRpb25hbCBhbGlnbm1lbnQgZWxlbWVudFxuICAgICAtIHdheSAoc3RyaW5nKSBvbmUgb2Ygc2l4IHZhbHVlczogYFwidG9wXCJgLCBgXCJtaWRkbGVcImAsIGBcImJvdHRvbVwiYCwgYFwibGVmdFwiYCwgYFwiY2VudGVyXCJgLCBgXCJyaWdodFwiYFxuICAgICA9IChvYmplY3QpIHRoaXMgZWxlbWVudFxuICAgICA+IFVzYWdlXG4gICAgIHwgZWwuYWxpZ24oZWwyLCBcInRvcFwiKTtcbiAgICAgKiBvclxuICAgICB8IGVsLmFsaWduKFwibWlkZGxlXCIpO1xuICAgIFxcKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5hbGlnbiA9IGZ1bmN0aW9uIChlbCwgd2F5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShcIi4uLlwiICsgdGhpcy5nZXRBbGlnbihlbCwgd2F5KSk7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IsIEZyYWdtZW50KSB7XG4gICAgdmFyIGVscHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgaXMgPSBTbmFwLmlzLFxuICAgICAgICBTdHIgPSBTdHJpbmcsXG4gICAgICAgIGhhcyA9IFwiaGFzT3duUHJvcGVydHlcIjtcbiAgICBmdW5jdGlvbiBzbGljZShmcm9tLCB0bywgZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGFyci5zbGljZShmcm9tLCB0byk7XG4gICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGYgPyBmKHJlcykgOiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMuZHVyID0gbXM7XG4gICAgICAgIGVhc2luZyAmJiAodGhpcy5lYXNpbmcgPSBlYXNpbmcpO1xuICAgICAgICBjYWxsYmFjayAmJiAodGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFNuYXAuXy5BbmltYXRpb24gPSBBbmltYXRpb247XG4gICAgLypcXFxuICAgICAqIFNuYXAuYW5pbWF0aW9uXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBDcmVhdGVzIGFuIGFuaW1hdGlvbiBvYmplY3RcbiAgICAgKipcbiAgICAgLSBhdHRyIChvYmplY3QpIGF0dHJpYnV0ZXMgb2YgZmluYWwgZGVzdGluYXRpb25cbiAgICAgLSBkdXJhdGlvbiAobnVtYmVyKSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgb25lIG9mIGVhc2luZyBmdW5jdGlvbnMgb2YgQG1pbmEgb3IgY3VzdG9tIG9uZVxuICAgICAtIGNhbGxiYWNrIChmdW5jdGlvbikgI29wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZmlyZXMgd2hlbiBhbmltYXRpb24gZW5kc1xuICAgICA9IChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3RcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRpb24gPSBmdW5jdGlvbiAoYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYXR0ciwgbXMsIGVhc2luZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuaW5BbmltXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIGFuaW1hdGlvbnMgdGhhdCBtYXkgYmUgYWJsZSB0byBtYW5pcHVsYXRlIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgKipcbiAgICAgPSAob2JqZWN0KSBpbiBmb3JtYXQ6XG4gICAgIG8ge1xuICAgICBvICAgICBhbmltIChvYmplY3QpIGFuaW1hdGlvbiBvYmplY3QsXG4gICAgIG8gICAgIG1pbmEgKG9iamVjdCkgQG1pbmEgb2JqZWN0LFxuICAgICBvICAgICBjdXJTdGF0dXMgKG51bWJlcikgMC4uMSDigJQgc3RhdHVzIG9mIHRoZSBhbmltYXRpb246IDAg4oCUIGp1c3Qgc3RhcnRlZCwgMSDigJQganVzdCBmaW5pc2hlZCxcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgXFwqL1xuICAgIGVscHJvdG8uaW5BbmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLFxuICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGlkIGluIGVsLmFuaW1zKSBpZiAoZWwuYW5pbXNbaGFzXShpZCkpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbTogbmV3IEFuaW1hdGlvbihhLl9hdHRycywgYS5kdXIsIGEuZWFzaW5nLCBhLl9jYWxsYmFjayksXG4gICAgICAgICAgICAgICAgICAgIG1pbmE6IGEsXG4gICAgICAgICAgICAgICAgICAgIGN1clN0YXR1czogYS5zdGF0dXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGF0dXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0oZWwuYW5pbXNbaWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmFuaW1hdGVcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJ1bnMgZ2VuZXJpYyBhbmltYXRpb24gb2Ygb25lIG51bWJlciBpbnRvIGFub3RoZXIgd2l0aCBhIGNhcmluZyBmdW5jdGlvblxuICAgICAqKlxuICAgICAtIGZyb20gKG51bWJlcnxhcnJheSkgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnNcbiAgICAgLSB0byAobnVtYmVyfGFycmF5KSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAtIHNldHRlciAoZnVuY3Rpb24pIGNhcmluZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIG51bWJlciBhcmd1bWVudFxuICAgICAtIGR1cmF0aW9uIChudW1iZXIpIGR1cmF0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGFuaW1hdGlvbiBlbmRzXG4gICAgID0gKG9iamVjdCkgYW5pbWF0aW9uIG9iamVjdCBpbiBAbWluYSBmb3JtYXRcbiAgICAgbyB7XG4gICAgIG8gICAgIGlkIChzdHJpbmcpIGFuaW1hdGlvbiBpZCwgY29uc2lkZXIgaXQgcmVhZC1vbmx5LFxuICAgICBvICAgICBkdXJhdGlvbiAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgZWFzaW5nIChmdW5jdGlvbikgZWFzaW5nLFxuICAgICBvICAgICBzcGVlZCAoZnVuY3Rpb24pIGdldHMgb3Igc2V0cyB0aGUgc3BlZWQgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RhdHVzIChmdW5jdGlvbikgZ2V0cyBvciBzZXRzIHRoZSBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbixcbiAgICAgbyAgICAgc3RvcCAoZnVuY3Rpb24pIHN0b3BzIHRoZSBhbmltYXRpb25cbiAgICAgbyB9XG4gICAgIHwgdmFyIHJlY3QgPSBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApO1xuICAgICB8IFNuYXAuYW5pbWF0ZSgwLCAxMCwgZnVuY3Rpb24gKHZhbCkge1xuICAgICB8ICAgICByZWN0LmF0dHIoe1xuICAgICB8ICAgICAgICAgeDogdmFsXG4gICAgIHwgICAgIH0pO1xuICAgICB8IH0sIDEwMDApO1xuICAgICB8IC8vIGluIGdpdmVuIGNvbnRleHQgaXMgZXF1aXZhbGVudCB0b1xuICAgICB8IHJlY3QuYW5pbWF0ZSh7eDogMTB9LCAxMDAwKTtcbiAgICBcXCovXG4gICAgU25hcC5hbmltYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzZXR0ZXIsIG1zLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nID09IFwiZnVuY3Rpb25cIiAmJiAhZWFzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICBlYXNpbmcgPSBtaW5hLmxpbmVhcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShmcm9tLCB0bywgbm93LCBub3cgKyBtcywgbWluYS50aW1lLCBzZXR0ZXIsIGVhc2luZyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGV2ZS5vbmNlKFwibWluYS5maW5pc2guXCIgKyBhbmltLmlkLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBhbmltO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIEVsZW1lbnQuc3RvcFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogU3RvcHMgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICoqXG4gICAgID0gKEVsZW1lbnQpIHRoZSBjdXJyZW50IGVsZW1lbnRcbiAgICBcXCovXG4gICAgZWxwcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW5pbXMgPSB0aGlzLmluQW5pbSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbmltcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBhbmltc1tpXS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogRWxlbWVudC5hbmltYXRlXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBBbmltYXRlcyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICAgICAqKlxuICAgICAtIGF0dHJzIChvYmplY3QpIGtleS12YWx1ZSBwYWlycyBvZiBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzXG4gICAgIC0gZHVyYXRpb24gKG51bWJlcikgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgLSBlYXNpbmcgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIGZyb20gQG1pbmEgb3IgY3VzdG9tXG4gICAgIC0gY2FsbGJhY2sgKGZ1bmN0aW9uKSAjb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIHRoZSBhbmltYXRpb24gZW5kc1xuICAgICA9IChFbGVtZW50KSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgXFwqL1xuICAgIGVscHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uIChhdHRycywgbXMsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlYXNpbmcgPT0gXCJmdW5jdGlvblwiICYmICFlYXNpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGVhc2luZztcbiAgICAgICAgICAgIGVhc2luZyA9IG1pbmEubGluZWFyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyBpbnN0YW5jZW9mIEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhdHRycy5jYWxsYmFjaztcbiAgICAgICAgICAgIGVhc2luZyA9IGF0dHJzLmVhc2luZztcbiAgICAgICAgICAgIG1zID0gYXR0cnMuZHVyO1xuICAgICAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBma2V5cyA9IFtdLCB0a2V5cyA9IFtdLCBrZXlzID0ge30sIGZyb20sIHRvLCBmLCBlcSxcbiAgICAgICAgICAgIGVsID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSBpZiAoYXR0cnNbaGFzXShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoZWwuZXF1YWwpIHtcbiAgICAgICAgICAgICAgICBlcSA9IGVsLmVxdWFsKGtleSwgU3RyKGF0dHJzW2tleV0pKTtcbiAgICAgICAgICAgICAgICBmcm9tID0gZXEuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IGVxLnRvO1xuICAgICAgICAgICAgICAgIGYgPSBlcS5mO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gK2VsLmF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB0byA9ICthdHRyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxlbiA9IGlzKGZyb20sIFwiYXJyYXlcIikgPyBmcm9tLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICBrZXlzW2tleV0gPSBzbGljZShma2V5cy5sZW5ndGgsIGZrZXlzLmxlbmd0aCArIGxlbiwgZik7XG4gICAgICAgICAgICBma2V5cyA9IGZrZXlzLmNvbmNhdChmcm9tKTtcbiAgICAgICAgICAgIHRrZXlzID0gdGtleXMuY29uY2F0KHRvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm93ID0gbWluYS50aW1lKCksXG4gICAgICAgICAgICBhbmltID0gbWluYShma2V5cywgdGtleXMsIG5vdywgbm93ICsgbXMsIG1pbmEudGltZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGtleXMpIGlmIChrZXlzW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyW2tleV0gPSBrZXlzW2tleV0odmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuYXR0cihhdHRyKTtcbiAgICAgICAgICAgIH0sIGVhc2luZyk7XG4gICAgICAgIGVsLmFuaW1zW2FuaW0uaWRdID0gYW5pbTtcbiAgICAgICAgYW5pbS5fYXR0cnMgPSBhdHRycztcbiAgICAgICAgYW5pbS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgZXZlKFwic25hcC5hbmltY3JlYXRlZC5cIiArIGVsLmlkLCBhbmltKTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLmZpbmlzaC5cIiArIGFuaW0uaWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5vZmYoXCJtaW5hLiouXCIgKyBhbmltLmlkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbC5hbmltc1thbmltLmlkXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlLm9uY2UoXCJtaW5hLnN0b3AuXCIgKyBhbmltLmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUub2ZmKFwibWluYS4qLlwiICsgYW5pbS5pZCk7XG4gICAgICAgICAgICBkZWxldGUgZWwuYW5pbXNbYW5pbS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfTtcbn0pO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTcgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5TbmFwLnBsdWdpbihmdW5jdGlvbiAoU25hcCwgRWxlbWVudCwgUGFwZXIsIGdsb2IpIHtcbiAgICAvLyBDb2xvdXJzIGFyZSBmcm9tIGh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY29cbiAgICB2YXIgcmVkICAgICAgICAgPSBcIiNmZmViZWUjZmZjZGQyI2VmOWE5YSNlNTczNzMjZWY1MzUwI2Y0NDMzNiNlNTM5MzUjZDMyZjJmI2M2MjgyOCNiNzFjMWMjZmY4YTgwI2ZmNTI1MiNmZjE3NDQjZDUwMDAwXCIsXG4gICAgICAgIHBpbmsgICAgICAgID0gXCIjRkNFNEVDI0Y4QkJEMCNGNDhGQjEjRjA2MjkyI0VDNDA3QSNFOTFFNjMjRDgxQjYwI0MyMTg1QiNBRDE0NTcjODgwRTRGI0ZGODBBQiNGRjQwODEjRjUwMDU3I0M1MTE2MlwiLFxuICAgICAgICBwdXJwbGUgICAgICA9IFwiI0YzRTVGNSNFMUJFRTcjQ0U5M0Q4I0JBNjhDOCNBQjQ3QkMjOUMyN0IwIzhFMjRBQSM3QjFGQTIjNkExQjlBIzRBMTQ4QyNFQTgwRkMjRTA0MEZCI0Q1MDBGOSNBQTAwRkZcIixcbiAgICAgICAgZGVlcHB1cnBsZSAgPSBcIiNFREU3RjYjRDFDNEU5I0IzOUREQiM5NTc1Q0QjN0U1N0MyIzY3M0FCNyM1RTM1QjEjNTEyREE4IzQ1MjdBMCMzMTFCOTIjQjM4OEZGIzdDNERGRiM2NTFGRkYjNjIwMEVBXCIsXG4gICAgICAgIGluZGlnbyAgICAgID0gXCIjRThFQUY2I0M1Q0FFOSM5RkE4REEjNzk4NkNCIzVDNkJDMCMzRjUxQjUjMzk0OUFCIzMwM0Y5RiMyODM1OTMjMUEyMzdFIzhDOUVGRiM1MzZERkUjM0Q1QUZFIzMwNEZGRVwiLFxuICAgICAgICBibHVlICAgICAgICA9IFwiI0UzRjJGRCNCQkRFRkIjOTBDQUY5IzY0QjVGNiM2NEI1RjYjMjE5NkYzIzFFODhFNSMxOTc2RDIjMTU2NUMwIzBENDdBMSM4MkIxRkYjNDQ4QUZGIzI5NzlGRiMyOTYyRkZcIixcbiAgICAgICAgbGlnaHRibHVlICAgPSBcIiNFMUY1RkUjQjNFNUZDIzgxRDRGQSM0RkMzRjcjMjlCNkY2IzAzQTlGNCMwMzlCRTUjMDI4OEQxIzAyNzdCRCMwMTU3OUIjODBEOEZGIzQwQzRGRiMwMEIwRkYjMDA5MUVBXCIsXG4gICAgICAgIGN5YW4gICAgICAgID0gXCIjRTBGN0ZBI0IyRUJGMiM4MERFRUEjNEREMEUxIzI2QzZEQSMwMEJDRDQjMDBBQ0MxIzAwOTdBNyMwMDgzOEYjMDA2MDY0Izg0RkZGRiMxOEZGRkYjMDBFNUZGIzAwQjhENFwiLFxuICAgICAgICB0ZWFsICAgICAgICA9IFwiI0UwRjJGMSNCMkRGREIjODBDQkM0IzREQjZBQyMyNkE2OUEjMDA5Njg4IzAwODk3QiMwMDc5NkIjMDA2OTVDIzAwNEQ0MCNBN0ZGRUIjNjRGRkRBIzFERTlCNiMwMEJGQTVcIixcbiAgICAgICAgZ3JlZW4gICAgICAgPSBcIiNFOEY1RTkjQzhFNkM5I0E1RDZBNyM4MUM3ODQjNjZCQjZBIzRDQUY1MCM0M0EwNDcjMzg4RTNDIzJFN0QzMiMxQjVFMjAjQjlGNkNBIzY5RjBBRSMwMEU2NzYjMDBDODUzXCIsXG4gICAgICAgIGxpZ2h0Z3JlZW4gID0gXCIjRjFGOEU5I0RDRURDOCNDNUUxQTUjQUVENTgxIzlDQ0M2NSM4QkMzNEEjN0NCMzQyIzY4OUYzOCM1NThCMkYjMzM2OTFFI0NDRkY5MCNCMkZGNTkjNzZGRjAzIzY0REQxN1wiLFxuICAgICAgICBsaW1lICAgICAgICA9IFwiI0Y5RkJFNyNGMEY0QzMjRTZFRTlDI0RDRTc3NSNENEUxNTcjQ0REQzM5I0MwQ0EzMyNBRkI0MkIjOUU5RDI0IzgyNzcxNyNGNEZGODEjRUVGRjQxI0M2RkYwMCNBRUVBMDBcIixcbiAgICAgICAgeWVsbG93ICAgICAgPSBcIiNGRkZERTcjRkZGOUM0I0ZGRjU5RCNGRkYxNzYjRkZFRTU4I0ZGRUIzQiNGREQ4MzUjRkJDMDJEI0Y5QTgyNSNGNTdGMTcjRkZGRjhEI0ZGRkYwMCNGRkVBMDAjRkZENjAwXCIsXG4gICAgICAgIGFtYmVyICAgICAgID0gXCIjRkZGOEUxI0ZGRUNCMyNGRkUwODIjRkZENTRGI0ZGQ0EyOCNGRkMxMDcjRkZCMzAwI0ZGQTAwMCNGRjhGMDAjRkY2RjAwI0ZGRTU3RiNGRkQ3NDAjRkZDNDAwI0ZGQUIwMFwiLFxuICAgICAgICBvcmFuZ2UgICAgICA9IFwiI0ZGRjNFMCNGRkUwQjIjRkZDQzgwI0ZGQjc0RCNGRkE3MjYjRkY5ODAwI0ZCOEMwMCNGNTdDMDAjRUY2QzAwI0U2NTEwMCNGRkQxODAjRkZBQjQwI0ZGOTEwMCNGRjZEMDBcIixcbiAgICAgICAgZGVlcG9yYW5nZSAgPSBcIiNGQkU5RTcjRkZDQ0JDI0ZGQUI5MSNGRjhBNjUjRkY3MDQzI0ZGNTcyMiNGNDUxMUUjRTY0QTE5I0Q4NDMxNSNCRjM2MEMjRkY5RTgwI0ZGNkU0MCNGRjNEMDAjREQyQzAwXCIsXG4gICAgICAgIGJyb3duICAgICAgID0gXCIjRUZFQkU5I0Q3Q0NDOCNCQ0FBQTQjQTE4ODdGIzhENkU2MyM3OTU1NDgjNkQ0QzQxIzVENDAzNyM0RTM0MkUjM0UyNzIzXCIsXG4gICAgICAgIGdyZXkgICAgICAgID0gXCIjRkFGQUZBI0Y1RjVGNSNFRUVFRUUjRTBFMEUwI0JEQkRCRCM5RTlFOUUjNzU3NTc1IzYxNjE2MSM0MjQyNDIjMjEyMTIxXCIsXG4gICAgICAgIGJsdWVncmV5ICAgID0gXCIjRUNFRkYxI0NGRDhEQyNCMEJFQzUjOTBBNEFFIzc4OTA5QyM2MDdEOEIjNTQ2RTdBIzQ1NUE2NCMzNzQ3NEYjMjYzMjM4XCI7XG4gICAgLypcXFxuICAgICAqIFNuYXAubXVpXG4gICAgIFsgcHJvcGVydHkgXVxuICAgICAqKlxuICAgICAqIENvbnRhaW4gTWF0ZXJpYWwgVUkgY29sb3Vycy5cbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IFNuYXAubXVpLmRlZXBwdXJwbGUsIHN0cm9rZTogU25hcC5tdWkuYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLm11aSA9IHt9O1xuICAgIC8qXFxcbiAgICAgKiBTbmFwLmZsYXRcbiAgICAgWyBwcm9wZXJ0eSBdXG4gICAgICoqXG4gICAgICogQ29udGFpbiBGbGF0IFVJIGNvbG91cnMuXG4gICAgIHwgU25hcCgpLnJlY3QoMCwgMCwgMTAsIDEwKS5hdHRyKHtmaWxsOiBTbmFwLmZsYXQuY2Fycm90LCBzdHJva2U6IFNuYXAuZmxhdC53ZXRhc3BoYWx0fSk7XG4gICAgICMgRm9yIGNvbG91ciByZWZlcmVuY2U6IDxhIGhyZWY9XCJodHRwczovL3d3dy5tYXRlcmlhbHVpLmNvXCI+aHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jbzwvYT4uXG4gICAgXFwqL1xuICAgIFNuYXAuZmxhdCA9IHt9O1xuICAgIGZ1bmN0aW9uIHNhdmVDb2xvcihjb2xvcnMpIHtcbiAgICAgICAgY29sb3JzID0gY29sb3JzLnNwbGl0KC8oPz0jKS8pO1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgU3RyaW5nKGNvbG9yc1s1XSk7XG4gICAgICAgIGNvbG9yWzUwXSA9IGNvbG9yc1swXTtcbiAgICAgICAgY29sb3JbMTAwXSA9IGNvbG9yc1sxXTtcbiAgICAgICAgY29sb3JbMjAwXSA9IGNvbG9yc1syXTtcbiAgICAgICAgY29sb3JbMzAwXSA9IGNvbG9yc1szXTtcbiAgICAgICAgY29sb3JbNDAwXSA9IGNvbG9yc1s0XTtcbiAgICAgICAgY29sb3JbNTAwXSA9IGNvbG9yc1s1XTtcbiAgICAgICAgY29sb3JbNjAwXSA9IGNvbG9yc1s2XTtcbiAgICAgICAgY29sb3JbNzAwXSA9IGNvbG9yc1s3XTtcbiAgICAgICAgY29sb3JbODAwXSA9IGNvbG9yc1s4XTtcbiAgICAgICAgY29sb3JbOTAwXSA9IGNvbG9yc1s5XTtcbiAgICAgICAgaWYgKGNvbG9yc1sxMF0pIHtcbiAgICAgICAgICAgIGNvbG9yLkExMDAgPSBjb2xvcnNbMTBdO1xuICAgICAgICAgICAgY29sb3IuQTIwMCA9IGNvbG9yc1sxMV07XG4gICAgICAgICAgICBjb2xvci5BNDAwID0gY29sb3JzWzEyXTtcbiAgICAgICAgICAgIGNvbG9yLkE3MDAgPSBjb2xvcnNbMTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgU25hcC5tdWkucmVkID0gc2F2ZUNvbG9yKHJlZCk7XG4gICAgU25hcC5tdWkucGluayA9IHNhdmVDb2xvcihwaW5rKTtcbiAgICBTbmFwLm11aS5wdXJwbGUgPSBzYXZlQ29sb3IocHVycGxlKTtcbiAgICBTbmFwLm11aS5kZWVwcHVycGxlID0gc2F2ZUNvbG9yKGRlZXBwdXJwbGUpO1xuICAgIFNuYXAubXVpLmluZGlnbyA9IHNhdmVDb2xvcihpbmRpZ28pO1xuICAgIFNuYXAubXVpLmJsdWUgPSBzYXZlQ29sb3IoYmx1ZSk7XG4gICAgU25hcC5tdWkubGlnaHRibHVlID0gc2F2ZUNvbG9yKGxpZ2h0Ymx1ZSk7XG4gICAgU25hcC5tdWkuY3lhbiA9IHNhdmVDb2xvcihjeWFuKTtcbiAgICBTbmFwLm11aS50ZWFsID0gc2F2ZUNvbG9yKHRlYWwpO1xuICAgIFNuYXAubXVpLmdyZWVuID0gc2F2ZUNvbG9yKGdyZWVuKTtcbiAgICBTbmFwLm11aS5saWdodGdyZWVuID0gc2F2ZUNvbG9yKGxpZ2h0Z3JlZW4pO1xuICAgIFNuYXAubXVpLmxpbWUgPSBzYXZlQ29sb3IobGltZSk7XG4gICAgU25hcC5tdWkueWVsbG93ID0gc2F2ZUNvbG9yKHllbGxvdyk7XG4gICAgU25hcC5tdWkuYW1iZXIgPSBzYXZlQ29sb3IoYW1iZXIpO1xuICAgIFNuYXAubXVpLm9yYW5nZSA9IHNhdmVDb2xvcihvcmFuZ2UpO1xuICAgIFNuYXAubXVpLmRlZXBvcmFuZ2UgPSBzYXZlQ29sb3IoZGVlcG9yYW5nZSk7XG4gICAgU25hcC5tdWkuYnJvd24gPSBzYXZlQ29sb3IoYnJvd24pO1xuICAgIFNuYXAubXVpLmdyZXkgPSBzYXZlQ29sb3IoZ3JleSk7XG4gICAgU25hcC5tdWkuYmx1ZWdyZXkgPSBzYXZlQ29sb3IoYmx1ZWdyZXkpO1xuICAgIFNuYXAuZmxhdC50dXJxdW9pc2UgPSBcIiMxYWJjOWNcIjtcbiAgICBTbmFwLmZsYXQuZ3JlZW5zZWEgPSBcIiMxNmEwODVcIjtcbiAgICBTbmFwLmZsYXQuc3VuZmxvd2VyID0gXCIjZjFjNDBmXCI7XG4gICAgU25hcC5mbGF0Lm9yYW5nZSA9IFwiI2YzOWMxMlwiO1xuICAgIFNuYXAuZmxhdC5lbWVybGFuZCA9IFwiIzJlY2M3MVwiO1xuICAgIFNuYXAuZmxhdC5uZXBocml0aXMgPSBcIiMyN2FlNjBcIjtcbiAgICBTbmFwLmZsYXQuY2Fycm90ID0gXCIjZTY3ZTIyXCI7XG4gICAgU25hcC5mbGF0LnB1bXBraW4gPSBcIiNkMzU0MDBcIjtcbiAgICBTbmFwLmZsYXQucGV0ZXJyaXZlciA9IFwiIzM0OThkYlwiO1xuICAgIFNuYXAuZmxhdC5iZWxpemVob2xlID0gXCIjMjk4MGI5XCI7XG4gICAgU25hcC5mbGF0LmFsaXphcmluID0gXCIjZTc0YzNjXCI7XG4gICAgU25hcC5mbGF0LnBvbWVncmFuYXRlID0gXCIjYzAzOTJiXCI7XG4gICAgU25hcC5mbGF0LmFtZXRoeXN0ID0gXCIjOWI1OWI2XCI7XG4gICAgU25hcC5mbGF0Lndpc3RlcmlhID0gXCIjOGU0NGFkXCI7XG4gICAgU25hcC5mbGF0LmNsb3VkcyA9IFwiI2VjZjBmMVwiO1xuICAgIFNuYXAuZmxhdC5zaWx2ZXIgPSBcIiNiZGMzYzdcIjtcbiAgICBTbmFwLmZsYXQud2V0YXNwaGFsdCA9IFwiIzM0NDk1ZVwiO1xuICAgIFNuYXAuZmxhdC5taWRuaWdodGJsdWUgPSBcIiMyYzNlNTBcIjtcbiAgICBTbmFwLmZsYXQuY29uY3JldGUgPSBcIiM5NWE1YTZcIjtcbiAgICBTbmFwLmZsYXQuYXNiZXN0b3MgPSBcIiM3ZjhjOGRcIjtcbiAgICAvKlxcXG4gICAgICogU25hcC5pbXBvcnRNVUlDb2xvcnNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEltcG9ydHMgTWF0ZXJpYWwgVUkgY29sb3VycyBpbnRvIGdsb2JhbCBvYmplY3QuXG4gICAgIHwgU25hcC5pbXBvcnRNVUlDb2xvcnMoKTtcbiAgICAgfCBTbmFwKCkucmVjdCgwLCAwLCAxMCwgMTApLmF0dHIoe2ZpbGw6IGRlZXBwdXJwbGUsIHN0cm9rZTogYW1iZXJbNjAwXX0pO1xuICAgICAjIEZvciBjb2xvdXIgcmVmZXJlbmNlOiA8YSBocmVmPVwiaHR0cHM6Ly93d3cubWF0ZXJpYWx1aS5jb1wiPmh0dHBzOi8vd3d3Lm1hdGVyaWFsdWkuY288L2E+LlxuICAgIFxcKi9cbiAgICBTbmFwLmltcG9ydE1VSUNvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgY29sb3IgaW4gU25hcC5tdWkpIHtcbiAgICAgICAgICAgIGlmIChTbmFwLm11aS5oYXNPd25Qcm9wZXJ0eShjb2xvcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3dbY29sb3JdID0gU25hcC5tdWlbY29sb3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNuYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zbmFwc3ZnLWNqcy9kaXN0L3NuYXAuc3ZnLWNqcy5qcyIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8vIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkCBcXFxcXG4vLyDilIIgRXZlIDAuNS40IC0gSmF2YVNjcmlwdCBFdmVudHMgTGlicmFyeSAgICAgICAgICAgICAgICAgICAgICDilIIgXFxcXFxuLy8g4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkIFxcXFxcbi8vIOKUgiBBdXRob3IgRG1pdHJ5IEJhcmFub3Zza2l5IChodHRwOi8vZG1pdHJ5LmJhcmFub3Zza2l5LmNvbS8pIOKUgiBcXFxcXG4vLyDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJggXFxcXFxuXG4oZnVuY3Rpb24gKGdsb2IpIHtcbiAgICB2YXIgdmVyc2lvbiA9IFwiMC41LjRcIixcbiAgICAgICAgaGFzID0gXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgICAgICBzZXBhcmF0b3IgPSAvW1xcLlxcL10vLFxuICAgICAgICBjb21hc2VwYXJhdG9yID0gL1xccyosXFxzKi8sXG4gICAgICAgIHdpbGRjYXJkID0gXCIqXCIsXG4gICAgICAgIG51bXNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50X2V2ZW50LFxuICAgICAgICBzdG9wLFxuICAgICAgICBldmVudHMgPSB7bjoge319LFxuICAgICAgICBmaXJzdERlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxhc3REZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbaV0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9ianRvcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIFN0ciA9IFN0cmluZyxcbiAgICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXIgaW5zdGFuY2VvZiBBcnJheSB8fCBvYmp0b3MuY2FsbChhcikgPT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9LFxuICAgIC8qXFxcbiAgICAgKiBldmVcbiAgICAgWyBtZXRob2QgXVxuXG4gICAgICogRmlyZXMgZXZlbnQgd2l0aCBnaXZlbiBgbmFtZWAsIGdpdmVuIHNjb3BlIGFuZCBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgIC0gbmFtZSAoc3RyaW5nKSBuYW1lIG9mIHRoZSAqZXZlbnQqLCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkXG4gICAgIC0gc2NvcGUgKG9iamVjdCkgY29udGV4dCBmb3IgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgIC0gdmFyYXJncyAoLi4uKSB0aGUgcmVzdCBvZiBhcmd1bWVudHMgd2lsbCBiZSBzZW50IHRvIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgPSAob2JqZWN0KSBhcnJheSBvZiByZXR1cm5lZCB2YWx1ZXMgZnJvbSB0aGUgbGlzdGVuZXJzLiBBcnJheSBoYXMgdHdvIG1ldGhvZHMgYC5maXJzdERlZmluZWQoKWAgYW5kIGAubGFzdERlZmluZWQoKWAgdG8gZ2V0IGZpcnN0IG9yIGxhc3Qgbm90IGB1bmRlZmluZWRgIHZhbHVlLlxuICAgIFxcKi9cbiAgICAgICAgZXZlID0gZnVuY3Rpb24gKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgb2xkc3RvcCA9IHN0b3AsXG4gICAgICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gZXZlLmxpc3RlbmVycyhuYW1lKSxcbiAgICAgICAgICAgICAgICB6ID0gMCxcbiAgICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQgPSBbXSxcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IHt9LFxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIGNlID0gY3VycmVudF9ldmVudDtcbiAgICAgICAgICAgIG91dC5maXJzdERlZmluZWQgPSBmaXJzdERlZmluZWQ7XG4gICAgICAgICAgICBvdXQubGFzdERlZmluZWQgPSBsYXN0RGVmaW5lZDtcbiAgICAgICAgICAgIGN1cnJlbnRfZXZlbnQgPSBuYW1lO1xuICAgICAgICAgICAgc3RvcCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykgaWYgKFwiekluZGV4XCIgaW4gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKGxpc3RlbmVyc1tpXS56SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uekluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtsaXN0ZW5lcnNbaV0uekluZGV4XSA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleGVkLnNvcnQobnVtc29ydCk7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXhlZFt6XSA8IDApIHtcbiAgICAgICAgICAgICAgICBsID0gcXVldWVbaW5kZXhlZFt6KytdXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChsLmFwcGx5KHNjb3BlLCBhcmdzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChcInpJbmRleFwiIGluIGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwuekluZGV4ID09IGluZGV4ZWRbel0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBxdWV1ZVtpbmRleGVkW3pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICYmIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChsKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbbC56SW5kZXhdID0gbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGwuYXBwbHkoc2NvcGUsIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcCA9IG9sZHN0b3A7XG4gICAgICAgICAgICBjdXJyZW50X2V2ZW50ID0gY2U7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuICAgIC8vIFVuZG9jdW1lbnRlZC4gRGVidWcgb25seS5cbiAgICBldmUuX2V2ZW50cyA9IGV2ZW50cztcbiAgICAvKlxcXG4gICAgICogZXZlLmxpc3RlbmVyc1xuICAgICBbIG1ldGhvZCBdXG5cbiAgICAgKiBJbnRlcm5hbCBtZXRob2Qgd2hpY2ggZ2l2ZXMgeW91IGFycmF5IG9mIGFsbCBldmVudCBoYW5kbGVycyB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSBnaXZlbiBgbmFtZWAuXG5cbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkXG5cbiAgICAgPSAoYXJyYXkpIGFycmF5IG9mIGV2ZW50IGhhbmRsZXJzXG4gICAgXFwqL1xuICAgIGV2ZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gbmFtZSA6IG5hbWUuc3BsaXQoc2VwYXJhdG9yKSxcbiAgICAgICAgICAgIGUgPSBldmVudHMsXG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgaXRlbXMsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGpqLFxuICAgICAgICAgICAgbmVzLFxuICAgICAgICAgICAgZXMgPSBbZV0sXG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBuZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDAsIGpqID0gZXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgIGUgPSBlc1tqXS5uO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gW2VbbmFtZXNbaV1dLCBlW3dpbGRjYXJkXV07XG4gICAgICAgICAgICAgICAgayA9IDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGstLSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IG91dC5jb25jYXQoaXRlbS5mIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzID0gbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvKlxcXG4gICAgICogZXZlLnNlcGFyYXRvclxuICAgICBbIG1ldGhvZCBdXG5cbiAgICAgKiBJZiBmb3Igc29tZSByZWFzb25zIHlvdSBkb27igJl0IGxpa2UgZGVmYXVsdCBzZXBhcmF0b3JzIChgLmAgb3IgYC9gKSB5b3UgY2FuIHNwZWNpZnkgeW91cnNcbiAgICAgKiBoZXJlLiBCZSBhd2FyZSB0aGF0IGlmIHlvdSBwYXNzIGEgc3RyaW5nIGxvbmdlciB0aGFuIG9uZSBjaGFyYWN0ZXIgaXQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgICogYSBsaXN0IG9mIGNoYXJhY3RlcnMuXG5cbiAgICAgLSBzZXBhcmF0b3IgKHN0cmluZykgbmV3IHNlcGFyYXRvci4gRW1wdHkgc3RyaW5nIHJlc2V0cyB0byBkZWZhdWx0OiBgLmAgb3IgYC9gLlxuICAgIFxcKi9cbiAgICBldmUuc2VwYXJhdG9yID0gZnVuY3Rpb24gKHNlcCkge1xuICAgICAgICBpZiAoc2VwKSB7XG4gICAgICAgICAgICBzZXAgPSBTdHIoc2VwKS5yZXBsYWNlKC8oPz1bXFwuXFxeXFxdXFxbXFwtXSkvZywgXCJcXFxcXCIpO1xuICAgICAgICAgICAgc2VwID0gXCJbXCIgKyBzZXAgKyBcIl1cIjtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IC9bXFwuXFwvXS87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub25cbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIEJpbmRzIGdpdmVuIGV2ZW50IGhhbmRsZXIgd2l0aCBhIGdpdmVuIG5hbWUuIFlvdSBjYW4gdXNlIHdpbGRjYXJkcyDigJxgKmDigJ0gZm9yIHRoZSBuYW1lczpcbiAgICAgfCBldmUub24oXCIqLnVuZGVyLipcIiwgZik7XG4gICAgIHwgZXZlKFwibW91c2UudW5kZXIuZmxvb3JcIik7IC8vIHRyaWdnZXJzIGZcbiAgICAgKiBVc2UgQGV2ZSB0byB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICoqXG4gICAgIC0gbmFtZSAoYXJyYXkpIGlmIHlvdSBkb27igJl0IHdhbnQgdG8gdXNlIHNlcGFyYXRvcnMsIHlvdSBjYW4gdXNlIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgLSBmIChmdW5jdGlvbikgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqKlxuICAgICA9IChmdW5jdGlvbikgcmV0dXJuZWQgZnVuY3Rpb24gYWNjZXB0cyBhIHNpbmdsZSBudW1lcmljIHBhcmFtZXRlciB0aGF0IHJlcHJlc2VudHMgei1pbmRleCBvZiB0aGUgaGFuZGxlci4gSXQgaXMgYW4gb3B0aW9uYWwgZmVhdHVyZSBhbmQgb25seSB1c2VkIHdoZW4geW91IG5lZWQgdG8gZW5zdXJlIHRoYXQgc29tZSBzdWJzZXQgb2YgaGFuZGxlcnMgd2lsbCBiZSBpbnZva2VkIGluIGEgZ2l2ZW4gb3JkZXIsIGRlc3BpdGUgb2YgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQuXG4gICAgID4gRXhhbXBsZTpcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBlYXRJdCkoMik7XG4gICAgIHwgZXZlLm9uKFwibW91c2VcIiwgc2NyZWFtKTtcbiAgICAgfCBldmUub24oXCJtb3VzZVwiLCBjYXRjaEl0KSgxKTtcbiAgICAgKiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgYGNhdGNoSXRgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBgZWF0SXRgLlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gcHV0IHlvdXIgaGFuZGxlciBiZWZvcmUgbm9uLWluZGV4ZWQgaGFuZGxlcnMsIHNwZWNpZnkgYSBuZWdhdGl2ZSB2YWx1ZS5cbiAgICAgKiBOb3RlOiBJIGFzc3VtZSBtb3N0IG9mIHRoZSB0aW1lIHlvdSBkb27igJl0IG5lZWQgdG8gd29ycnkgYWJvdXQgei1pbmRleCwgYnV0IGl04oCZcyBuaWNlIHRvIGhhdmUgdGhpcyBmZWF0dXJlIOKAnGp1c3QgaW4gY2FzZeKAnS5cbiAgICBcXCovXG4gICAgZXZlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lcyA9IGlzQXJyYXkobmFtZSkgPyBpc0FycmF5KG5hbWVbMF0pID8gbmFtZSA6IFtuYW1lXSA6IFN0cihuYW1lKS5zcGxpdChjb21hc2VwYXJhdG9yKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVzID0gaXNBcnJheShuYW1lKSA/IG5hbWUgOiBTdHIobmFtZSkuc3BsaXQoc2VwYXJhdG9yKSxcbiAgICAgICAgICAgICAgICAgICAgZSA9IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Q7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlID0gZS5uO1xuICAgICAgICAgICAgICAgICAgICBlID0gZS5oYXNPd25Qcm9wZXJ0eShuYW1lc1tpXSkgJiYgZVtuYW1lc1tpXV0gfHwgKGVbbmFtZXNbaV1dID0ge246IHt9fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUuZiA9IGUuZiB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGUuZi5sZW5ndGg7IGkgPCBpaTsgaSsrKSBpZiAoZS5mW2ldID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIWV4aXN0ICYmIGUuZi5wdXNoKGYpO1xuICAgICAgICAgICAgfShuYW1lc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoekluZGV4KSB7XG4gICAgICAgICAgICBpZiAoK3pJbmRleCA9PSArekluZGV4KSB7XG4gICAgICAgICAgICAgICAgZi56SW5kZXggPSArekluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5mXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBSZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBmaXJlIGdpdmVuIGV2ZW50IHdpdGggb3B0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqIEFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSByZXN1bHQgZnVuY3Rpb24gd2lsbCBiZSBhbHNvXG4gICAgICogY29uY2F0ZWQgdG8gdGhlIGxpc3Qgb2YgZmluYWwgYXJndW1lbnRzLlxuICAgICB8IGVsLm9uY2xpY2sgPSBldmUuZihcImNsaWNrXCIsIDEsIDIpO1xuICAgICB8IGV2ZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgIHwgICAgIGNvbnNvbGUubG9nKGEsIGIsIGMpOyAvLyAxLCAyLCBbZXZlbnQgb2JqZWN0XVxuICAgICB8IH0pO1xuICAgICAtIGV2ZW50IChzdHJpbmcpIGV2ZW50IG5hbWVcbiAgICAgLSB2YXJhcmdzICjigKYpIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzXG4gICAgID0gKGZ1bmN0aW9uKSBwb3NzaWJsZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuICAgIGV2ZS5mID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhdHRycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZS5hcHBseShudWxsLCBbZXZlbnQsIG51bGxdLmNvbmNhdChhdHRycykuY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5zdG9wXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBJcyB1c2VkIGluc2lkZSBhbiBldmVudCBoYW5kbGVyIHRvIHN0b3AgdGhlIGV2ZW50LCBwcmV2ZW50aW5nIGFueSBzdWJzZXF1ZW50IGxpc3RlbmVycyBmcm9tIGZpcmluZy5cbiAgICBcXCovXG4gICAgZXZlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0b3AgPSAxO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5udFxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQ291bGQgYmUgdXNlZCBpbnNpZGUgZXZlbnQgaGFuZGxlciB0byBmaWd1cmUgb3V0IGFjdHVhbCBuYW1lIG9mIHRoZSBldmVudC5cbiAgICAgKipcbiAgICAgLSBzdWJuYW1lIChzdHJpbmcpICNvcHRpb25hbCBzdWJuYW1lIG9mIHRoZSBldmVudFxuICAgICAqKlxuICAgICA9IChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBpZiBgc3VibmFtZWAgaXMgbm90IHNwZWNpZmllZFxuICAgICAqIG9yXG4gICAgID0gKGJvb2xlYW4pIGB0cnVlYCwgaWYgY3VycmVudCBldmVudOKAmXMgbmFtZSBjb250YWlucyBgc3VibmFtZWBcbiAgICBcXCovXG4gICAgZXZlLm50ID0gZnVuY3Rpb24gKHN1Ym5hbWUpIHtcbiAgICAgICAgdmFyIGN1ciA9IGlzQXJyYXkoY3VycmVudF9ldmVudCkgPyBjdXJyZW50X2V2ZW50LmpvaW4oXCIuXCIpIDogY3VycmVudF9ldmVudDtcbiAgICAgICAgaWYgKHN1Ym5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XFxcXC58XFxcXC98XilcIiArIHN1Ym5hbWUgKyBcIig/OlxcXFwufFxcXFwvfCQpXCIpLnRlc3QoY3VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5udHNcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIENvdWxkIGJlIHVzZWQgaW5zaWRlIGV2ZW50IGhhbmRsZXIgdG8gZmlndXJlIG91dCBhY3R1YWwgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAgICoqXG4gICAgICoqXG4gICAgID0gKGFycmF5KSBuYW1lcyBvZiB0aGUgZXZlbnRcbiAgICBcXCovXG4gICAgZXZlLm50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkoY3VycmVudF9ldmVudCkgPyBjdXJyZW50X2V2ZW50IDogY3VycmVudF9ldmVudC5zcGxpdChzZXBhcmF0b3IpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS5vZmZcbiAgICAgWyBtZXRob2QgXVxuICAgICAqKlxuICAgICAqIFJlbW92ZXMgZ2l2ZW4gZnVuY3Rpb24gZnJvbSB0aGUgbGlzdCBvZiBldmVudCBsaXN0ZW5lcnMgYXNzaWduZWQgdG8gZ2l2ZW4gbmFtZS5cbiAgICAgKiBJZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkIGFsbCB0aGUgZXZlbnRzIHdpbGwgYmUgY2xlYXJlZC5cbiAgICAgKipcbiAgICAgLSBuYW1lIChzdHJpbmcpIG5hbWUgb2YgdGhlIGV2ZW50LCBkb3QgKGAuYCkgb3Igc2xhc2ggKGAvYCkgc2VwYXJhdGVkLCB3aXRoIG9wdGlvbmFsIHdpbGRjYXJkc1xuICAgICAtIGYgKGZ1bmN0aW9uKSBldmVudCBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgXFwqL1xuICAgIC8qXFxcbiAgICAgKiBldmUudW5iaW5kXG4gICAgIFsgbWV0aG9kIF1cbiAgICAgKipcbiAgICAgKiBTZWUgQGV2ZS5vZmZcbiAgICBcXCovXG4gICAgZXZlLm9mZiA9IGV2ZS51bmJpbmQgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGV2ZS5fZXZlbnRzID0gZXZlbnRzID0ge246IHt9fTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gaXNBcnJheShuYW1lWzBdKSA/IG5hbWUgOiBbbmFtZV0gOiBTdHIobmFtZSkuc3BsaXQoY29tYXNlcGFyYXRvcik7XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXZlLm9mZihuYW1lc1tpXSwgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gbmFtZSA6IFN0cihuYW1lKS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNwbGljZSxcbiAgICAgICAgICAgIGksIGlpLCBqLCBqaixcbiAgICAgICAgICAgIGN1ciA9IFtldmVudHNdLFxuICAgICAgICAgICAgaW5vZGVzID0gW107XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbmFtZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1ci5sZW5ndGg7IGogKz0gc3BsaWNlLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpY2UgPSBbaiwgMV07XG4gICAgICAgICAgICAgICAgZSA9IGN1cltqXS5uO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc1tpXSAhPSB3aWxkY2FyZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZVtuYW1lc1tpXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5wdXNoKGVbbmFtZXNbaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlub2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUpIGlmIChlW2hhc10oa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlLnB1c2goZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlub2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLnNwbGljZS5hcHBseShjdXIsIHNwbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBjdXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgZSA9IGN1cltpXTtcbiAgICAgICAgICAgIHdoaWxlIChlLm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGUuZi5sZW5ndGg7IGogPCBqajsgaisrKSBpZiAoZS5mW2pdID09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmYuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWUuZi5sZW5ndGggJiYgZGVsZXRlIGUuZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBlLm4pIGlmIChlLm5baGFzXShrZXkpICYmIGUubltrZXldLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdW5jcyA9IGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGZ1bmNzLmxlbmd0aDsgaiA8IGpqOyBqKyspIGlmIChmdW5jc1tqXSA9PSBmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmNzLmxlbmd0aCAmJiBkZWxldGUgZS5uW2tleV0uZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmY7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGUubikgaWYgKGUubltoYXNdKGtleSkgJiYgZS5uW2tleV0uZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUubltrZXldLmY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZSA9IGUubjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcnVuZSBpbm5lciBub2RlcyBpbiBwYXRoXG4gICAgICAgIHBydW5lOiBmb3IgKGkgPSAwLCBpaSA9IGlub2Rlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBlID0gaW5vZGVzW2ldO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gZS5uW2UubmFtZV0uZikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBlbXB0eSAoaGFzIGxpc3RlbmVycylcbiAgICAgICAgICAgICAgICBjb250aW51ZSBwcnVuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGUubltlLm5hbWVdLm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgZW1wdHkgKGhhcyBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjb250aW51ZSBwcnVuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlzIGVtcHR5XG4gICAgICAgICAgICBkZWxldGUgZS5uW2UubmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qXFxcbiAgICAgKiBldmUub25jZVxuICAgICBbIG1ldGhvZCBdXG4gICAgICoqXG4gICAgICogQmluZHMgZ2l2ZW4gZXZlbnQgaGFuZGxlciB3aXRoIGEgZ2l2ZW4gbmFtZSB0byBvbmx5IHJ1biBvbmNlIHRoZW4gdW5iaW5kIGl0c2VsZi5cbiAgICAgfCBldmUub25jZShcImxvZ2luXCIsIGYpO1xuICAgICB8IGV2ZShcImxvZ2luXCIpOyAvLyB0cmlnZ2VycyBmXG4gICAgIHwgZXZlKFwibG9naW5cIik7IC8vIG5vIGxpc3RlbmVyc1xuICAgICAqIFVzZSBAZXZlIHRvIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxuICAgICAqKlxuICAgICAtIG5hbWUgKHN0cmluZykgbmFtZSBvZiB0aGUgZXZlbnQsIGRvdCAoYC5gKSBvciBzbGFzaCAoYC9gKSBzZXBhcmF0ZWQsIHdpdGggb3B0aW9uYWwgd2lsZGNhcmRzXG4gICAgIC0gZiAoZnVuY3Rpb24pIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKipcbiAgICAgPSAoZnVuY3Rpb24pIHNhbWUgcmV0dXJuIGZ1bmN0aW9uIGFzIEBldmUub25cbiAgICBcXCovXG4gICAgZXZlLm9uY2UgPSBmdW5jdGlvbiAobmFtZSwgZikge1xuICAgICAgICB2YXIgZjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBldmUub2ZmKG5hbWUsIGYyKTtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBldmUub24obmFtZSwgZjIpO1xuICAgIH07XG4gICAgLypcXFxuICAgICAqIGV2ZS52ZXJzaW9uXG4gICAgIFsgcHJvcGVydHkgKHN0cmluZykgXVxuICAgICAqKlxuICAgICAqIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICBcXCovXG4gICAgZXZlLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGV2ZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiWW91IGFyZSBydW5uaW5nIEV2ZSBcIiArIHZlcnNpb247XG4gICAgfTtcbiAgICBnbG9iLmV2ZSA9IGV2ZTtcbiAgICB0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA9IGV2ZSA6IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFwiZXZlXCIsIFtdLCBmdW5jdGlvbiAoKSB7IHJldHVybiBldmU7IH0pIDogZ2xvYi5ldmUgPSBldmU7XG59KSh0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ldmUvZXZlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3NuYXBzdmdJbXBvcnRlciA9IHJlcXVpcmUoJy4uL3NuYXBzdmdJbXBvcnRlcicpO1xuXG52YXIgX3NuYXBzdmdJbXBvcnRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zbmFwc3ZnSW1wb3J0ZXIpO1xuXG52YXIgX21lbnVGYWN0b3J5ID0gcmVxdWlyZSgnLi4vbWVudUZhY3RvcnknKTtcblxudmFyIF9tZW51RmFjdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZW51RmFjdG9yeSk7XG5cbnZhciBzdHlsZXMgPSB7XG5cbiAgc3ZnOiB7XG4gICAgbGliOiBfc25hcHN2Z0ltcG9ydGVyMlsnZGVmYXVsdCddLFxuICAgIHBhdGhJbml0aWFsOiAnTS03LjMxMiwwSDBjMCwwLDAsMTEzLjgzOSwwLDQwMGMwLDI2NC41MDYsMCw0MDAsMCw0MDBoLTcuMzEyVjB6JyxcbiAgICBwYXRoT3BlbjogJ00tNy4zMTIsMEgxNWMwLDAsNjYsMTEzLjMzOSw2NiwzOTkuNUM4MSw2NjQuMDA2LDE1LDgwMCwxNSw4MDBILTcuMzEyVjB6O00tNy4zMTIsMEgxMDBjMCwwLDAsMTEzLjgzOSwwLDQwMGMwLDI2NC41MDYsMCw0MDAsMCw0MDBILTcuMzEyVjB6JyxcbiAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHBhdGgpIHtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHN0ZXBzID0gdGhpcy5wYXRoT3Blbi5zcGxpdCgnOycpO1xuICAgICAgdmFyIHN0ZXBzVG90YWwgPSBzdGVwcy5sZW5ndGg7XG4gICAgICB2YXIgbWluYSA9IHdpbmRvdy5taW5hO1xuXG4gICAgICB2YXIgbmV4dFN0ZXAgPSBmdW5jdGlvbiBuZXh0U3RlcCgpIHtcbiAgICAgICAgaWYgKHBvcyA+IHN0ZXBzVG90YWwgLSAxKSByZXR1cm47XG5cbiAgICAgICAgcGF0aC5hbmltYXRlKHsgcGF0aDogc3RlcHNbcG9zXSB9LCBwb3MgPT09IDAgPyA0MDAgOiA1MDAsIHBvcyA9PT0gMCA/IG1pbmEuZWFzZWluIDogbWluYS5lbGFzdGljLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbmV4dFN0ZXAoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcG9zKys7XG4gICAgICB9O1xuXG4gICAgICBuZXh0U3RlcCgpO1xuICAgIH1cbiAgfSxcblxuICBtb3JwaFNoYXBlOiBmdW5jdGlvbiBtb3JwaFNoYXBlKGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgcmlnaHQ6IHJpZ2h0ID8gJ2luaGVyaXQnIDogMCxcbiAgICAgIGxlZnQ6IHJpZ2h0ID8gMCA6ICdpbmhlcml0JyxcbiAgICAgIE1velRyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICdyb3RhdGVZKDBkZWcpJyxcbiAgICAgIE1zVHJhbnNmb3JtOiByaWdodCA/ICdyb3RhdGVZKDE4MGRlZyknIDogJ3JvdGF0ZVkoMGRlZyknLFxuICAgICAgT1RyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICdyb3RhdGVZKDBkZWcpJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICdyb3RhdGVZKDBkZWcpJyxcbiAgICAgIHRyYW5zZm9ybTogcmlnaHQgPyAncm90YXRlWSgxODBkZWcpJyA6ICdyb3RhdGVZKDBkZWcpJ1xuICAgIH07XG4gIH0sXG5cbiAgbWVudVdyYXA6IGZ1bmN0aW9uIG1lbnVXcmFwKGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknLFxuICAgICAgTXNUcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCknLFxuICAgICAgdHJhbnNmb3JtOiBpc09wZW4gPyAndHJhbnNsYXRlM2QoMCwgMCwgMCknIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoMTAwJSwgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiBpc09wZW4gPyAndHJhbnNmb3JtIDAuNHMgMHMnIDogJ3RyYW5zZm9ybSAwLjRzJ1xuICAgIH07XG4gIH0sXG5cbiAgbWVudTogZnVuY3Rpb24gbWVudShpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHdpZHRoIC09IDE0MDtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiBpc09wZW4gPyAnb3BhY2l0eSAwLjFzIDAuNHMgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyksIHRyYW5zZm9ybSAwLjFzIDAuNHMgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyknIDogJ29wYWNpdHkgMHMgMC4zcyBjdWJpYy1iZXppZXIoLjE3LCAuNjcsIC4xLCAxLjI3KSwgdHJhbnNmb3JtIDBzIDAuM3MgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyknLFxuICAgICAgb3BhY2l0eTogaXNPcGVuID8gMSA6IDBcbiAgICB9O1xuICB9LFxuXG4gIGl0ZW06IGZ1bmN0aW9uIGl0ZW0oaXNPcGVuLCB3aWR0aCwgcmlnaHQsIG50aENoaWxkKSB7XG4gICAgd2lkdGggLT0gMTQwO1xuICAgIHJldHVybiB7XG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAndHJhbnNsYXRlM2QoMCwgMCwgMCknIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBPVHJhbnNmb3JtOiBpc09wZW4gPyAndHJhbnNsYXRlM2QoMCwgMCwgMCknIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgdHJhbnNpdGlvbjogaXNPcGVuID8gJ29wYWNpdHkgMC4zcyAwLjRzLCB0cmFuc2Zvcm0gMC4zcyAwLjRzJyA6ICdvcGFjaXR5IDBzIDAuM3MgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyksIHRyYW5zZm9ybSAwcyAwLjNzIGN1YmljLWJlemllciguMTcsIC42NywgLjEsIDEuMjcpJyxcbiAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwXG4gICAgfTtcbiAgfSxcblxuICBjbG9zZUJ1dHRvbjogZnVuY3Rpb24gY2xvc2VCdXR0b24oaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICB3aWR0aCAtPSAxNDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgTXNUcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgdHJhbnNmb3JtOiBpc09wZW4gPyAndHJhbnNsYXRlM2QoMCwgMCwgMCknIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiBpc09wZW4gPyAnb3BhY2l0eSAwLjNzIDAuNHMgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyksIHRyYW5zZm9ybSAwLjNzIDAuNHMgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyknIDogJ29wYWNpdHkgMHMgMC4zcyBjdWJpYy1iZXppZXIoLjE3LCAuNjcsIC4xLCAxLjI3KSwgdHJhbnNmb3JtIDBzIDAuM3MgY3ViaWMtYmV6aWVyKC4xNywgLjY3LCAuMSwgMS4yNyknLFxuICAgICAgb3BhY2l0eTogaXNPcGVuID8gMSA6IDBcbiAgICB9O1xuICB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSAoMCwgX21lbnVGYWN0b3J5MlsnZGVmYXVsdCddKShzdHlsZXMpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWJ1cmdlci1tZW51L2xpYi9tZW51cy9idWJibGUuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbWVudUZhY3RvcnkgPSByZXF1aXJlKCcuLi9tZW51RmFjdG9yeScpO1xuXG52YXIgX21lbnVGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVGYWN0b3J5KTtcblxudmFyIHN0eWxlcyA9IHtcblxuICBwYWdlV3JhcDogZnVuY3Rpb24gcGFnZVdyYXAoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTW96VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgTXNUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBPVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgdHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjVzJ1xuICAgIH07XG4gIH0sXG5cbiAgb3V0ZXJDb250YWluZXI6IGZ1bmN0aW9uIG91dGVyQ29udGFpbmVyKGlzT3Blbikge1xuICAgIHJldHVybiB7XG4gICAgICBvdmVyZmxvdzogaXNPcGVuID8gJycgOiAnaGlkZGVuJ1xuICAgIH07XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9ICgwLCBfbWVudUZhY3RvcnkyWydkZWZhdWx0J10pKHN0eWxlcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL3B1c2guanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbWVudUZhY3RvcnkgPSByZXF1aXJlKCcuLi9tZW51RmFjdG9yeScpO1xuXG52YXIgX21lbnVGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVGYWN0b3J5KTtcblxudmFyIHN0eWxlcyA9IHtcblxuICBwYWdlV3JhcDogZnVuY3Rpb24gcGFnZVdyYXAoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTW96VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKSByb3RhdGVZKDE1ZGVnKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCkgcm90YXRlWSgtMTVkZWcpJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKSByb3RhdGVZKDE1ZGVnKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCkgcm90YXRlWSgtMTVkZWcpJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApIHJvdGF0ZVkoMTVkZWcpJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKSByb3RhdGVZKC0xNWRlZyknLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKSByb3RhdGVZKDE1ZGVnKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCkgcm90YXRlWSgtMTVkZWcpJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCkgcm90YXRlWSgxNWRlZyknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApIHJvdGF0ZVkoLTE1ZGVnKScsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW46IHJpZ2h0ID8gJzEwMCUgNTAlJyA6ICcwJSA1MCUnLFxuICAgICAgdHJhbnNmb3JtU3R5bGU6ICdwcmVzZXJ2ZS0zZCcsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuNXMnXG4gICAgfTtcbiAgfSxcblxuICBvdXRlckNvbnRhaW5lcjogZnVuY3Rpb24gb3V0ZXJDb250YWluZXIoaXNPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcnNwZWN0aXZlOiAnMTUwMHB4JyxcbiAgICAgIG92ZXJmbG93OiBpc09wZW4gPyAnJyA6ICdoaWRkZW4nXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gKDAsIF9tZW51RmFjdG9yeTJbJ2RlZmF1bHQnXSkoc3R5bGVzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvcHVzaFJvdGF0ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9tZW51RmFjdG9yeSA9IHJlcXVpcmUoJy4uL21lbnVGYWN0b3J5Jyk7XG5cbnZhciBfbWVudUZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVudUZhY3RvcnkpO1xuXG52YXIgc3R5bGVzID0ge1xuXG4gIHBhZ2VXcmFwOiBmdW5jdGlvbiBwYWdlV3JhcChpc09wZW4sIHdpZHRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgMCwgLScgKyB3aWR0aCArICcpJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgwLCAwLCAtJyArIHdpZHRoICsgJyknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgMCwgLScgKyB3aWR0aCArICcpJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgMCwgLScgKyB3aWR0aCArICcpJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgMCwgLScgKyB3aWR0aCArICcpJyxcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogJzEwMCUnLFxuICAgICAgdHJhbnNmb3JtU3R5bGU6ICdwcmVzZXJ2ZS0zZCcsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuNXMnXG4gICAgfTtcbiAgfSxcblxuICBvdXRlckNvbnRhaW5lcjogZnVuY3Rpb24gb3V0ZXJDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcnNwZWN0aXZlOiAnMTUwMHB4J1xuICAgIH07XG4gIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9ICgwLCBfbWVudUZhY3RvcnkyWydkZWZhdWx0J10pKHN0eWxlcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtYnVyZ2VyLW1lbnUvbGliL21lbnVzL3NjYWxlRG93bi5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9tZW51RmFjdG9yeSA9IHJlcXVpcmUoJy4uL21lbnVGYWN0b3J5Jyk7XG5cbnZhciBfbWVudUZhY3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWVudUZhY3RvcnkpO1xuXG52YXIgc3R5bGVzID0ge1xuXG4gIHBhZ2VXcmFwOiBmdW5jdGlvbiBwYWdlV3JhcChpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLTEwMHB4LCAwLCAtNjAwcHgpIHJvdGF0ZVkoMjBkZWcpJyA6ICd0cmFuc2xhdGUzZCgxMDBweCwgMCwgLTYwMHB4KSByb3RhdGVZKC0yMGRlZyknLFxuICAgICAgTXNUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLTEwMHB4LCAwLCAtNjAwcHgpIHJvdGF0ZVkoMjBkZWcpJyA6ICd0cmFuc2xhdGUzZCgxMDBweCwgMCwgLTYwMHB4KSByb3RhdGVZKC0yMGRlZyknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtMTAwcHgsIDAsIC02MDBweCkgcm90YXRlWSgyMGRlZyknIDogJ3RyYW5zbGF0ZTNkKDEwMHB4LCAwLCAtNjAwcHgpIHJvdGF0ZVkoLTIwZGVnKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLTEwMHB4LCAwLCAtNjAwcHgpIHJvdGF0ZVkoMjBkZWcpJyA6ICd0cmFuc2xhdGUzZCgxMDBweCwgMCwgLTYwMHB4KSByb3RhdGVZKC0yMGRlZyknLFxuICAgICAgdHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0xMDBweCwgMCwgLTYwMHB4KSByb3RhdGVZKDIwZGVnKScgOiAndHJhbnNsYXRlM2QoMTAwcHgsIDAsIC02MDBweCkgcm90YXRlWSgtMjBkZWcpJyxcbiAgICAgIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnLFxuICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjVzJyxcbiAgICAgIG92ZXJmbG93OiBpc09wZW4gPyAnJyA6ICdoaWRkZW4nXG4gICAgfTtcbiAgfSxcblxuICBvdXRlckNvbnRhaW5lcjogZnVuY3Rpb24gb3V0ZXJDb250YWluZXIoaXNPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcnNwZWN0aXZlOiAnMTUwMHB4JyxcbiAgICAgIG92ZXJmbG93OiBpc09wZW4gPyAnJyA6ICdoaWRkZW4nXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gKDAsIF9tZW51RmFjdG9yeTJbJ2RlZmF1bHQnXSkoc3R5bGVzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvc2NhbGVSb3RhdGUuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbWVudUZhY3RvcnkgPSByZXF1aXJlKCcuLi9tZW51RmFjdG9yeScpO1xuXG52YXIgX21lbnVGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVGYWN0b3J5KTtcblxudmFyIHN0eWxlcyA9IHtcblxuICBtZW51V3JhcDogZnVuY3Rpb24gbWVudVdyYXAoaXNPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6ICd0cmFuc2xhdGUzZCgwLCAtMTAwJSwgMCknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiAndHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApJyxcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMC41cyBlYXNlLWluLW91dCdcbiAgICB9O1xuICB9LFxuXG4gIHBhZ2VXcmFwOiBmdW5jdGlvbiBwYWdlV3JhcChpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06IGlzT3BlbiA/ICcnIDogcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScsXG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuNXMnXG4gICAgfTtcbiAgfSxcblxuICBvdXRlckNvbnRhaW5lcjogZnVuY3Rpb24gb3V0ZXJDb250YWluZXIoaXNPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcnNwZWN0aXZlOiAnMTUwMHB4JyxcbiAgICAgIHBlcnNwZWN0aXZlT3JpZ2luOiAnMCUgNTAlJyxcbiAgICAgIG92ZXJmbG93OiBpc09wZW4gPyAnJyA6ICdoaWRkZW4nXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gKDAsIF9tZW51RmFjdG9yeTJbJ2RlZmF1bHQnXSkoc3R5bGVzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvZmFsbERvd24uanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfbWVudUZhY3RvcnkgPSByZXF1aXJlKCcuLi9tZW51RmFjdG9yeScpO1xuXG52YXIgX21lbnVGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lbnVGYWN0b3J5KTtcblxudmFyIHN0eWxlcyA9IHtcblxuICBtZW51V3JhcDogZnVuY3Rpb24gbWVudVdyYXAoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJpbGl0eTogaXNPcGVuID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsXG4gICAgICBNb3pUcmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgIE9UcmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICB6SW5kZXg6IDFcbiAgICB9O1xuICB9LFxuXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkoaXNPcGVuLCB3aWR0aCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgekluZGV4OiA0LFxuICAgICAgTW96VHJhbnNmb3JtOiBpc09wZW4gPyByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICBNc1RyYW5zZm9ybTogaXNPcGVuID8gcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gcmlnaHQgPyAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgV2Via2l0VHJhbnNmb3JtOiBpc09wZW4gPyByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICB0cmFuc2Zvcm06IGlzT3BlbiA/IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMC41cycsXG4gICAgICB2aXNpYmlsaXR5OiBpc09wZW4gPyAndmlzaWJsZScgOiAnaGlkZGVuJ1xuICAgIH07XG4gIH0sXG5cbiAgcGFnZVdyYXA6IGZ1bmN0aW9uIHBhZ2VXcmFwKGlzT3Blbiwgd2lkdGgsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1velRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyAnJyA6IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknLFxuICAgICAgT1RyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIFdlYmtpdFRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gJycgOiByaWdodCA/ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyxcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMC41cycsXG4gICAgICB6SW5kZXg6IDIsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH07XG4gIH0sXG5cbiAgYnVyZ2VySWNvbjogZnVuY3Rpb24gYnVyZ2VySWNvbihpc09wZW4sIHdpZHRoLCByaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBNb3pUcmFuc2Zvcm06IGlzT3BlbiA/IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgIE1zVHJhbnNmb3JtOiBpc09wZW4gPyByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICBPVHJhbnNmb3JtOiBpc09wZW4gPyByaWdodCA/ICd0cmFuc2xhdGUzZCgnICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoLScgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICBXZWJraXRUcmFuc2Zvcm06IGlzT3BlbiA/IHJpZ2h0ID8gJ3RyYW5zbGF0ZTNkKCcgKyB3aWR0aCArICcsIDAsIDApJyA6ICd0cmFuc2xhdGUzZCgtJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgIHRyYW5zZm9ybTogaXNPcGVuID8gcmlnaHQgPyAndHJhbnNsYXRlM2QoJyArIHdpZHRoICsgJywgMCwgMCknIDogJ3RyYW5zbGF0ZTNkKC0nICsgd2lkdGggKyAnLCAwLCAwKScgOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgdHJhbnNpdGlvbjogJ2FsbCAwLjFzJyxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgekluZGV4OiAzXG4gICAgfTtcbiAgfSxcblxuICBvdXRlckNvbnRhaW5lcjogZnVuY3Rpb24gb3V0ZXJDb250YWluZXIoaXNPcGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG92ZXJmbG93OiBpc09wZW4gPyAnJyA6ICdoaWRkZW4nXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gKDAsIF9tZW51RmFjdG9yeTJbJ2RlZmF1bHQnXSkoc3R5bGVzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1idXJnZXItbWVudS9saWIvbWVudXMvcmV2ZWFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5sZXQgaXNUb3VjaERldmljZSA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY5O1xuXG5mdW5jdGlvbiBOYXZVcmxzKCkge1xuXHRsZXQgYXJyYXlPZk5hdkxpbmtzID0gW107XG5cdGxldCBuYXZFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbmF2XScpO1xuXHRsZXQgbGlua3MgPSBuYXZFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdGFycmF5T2ZOYXZMaW5rcy5wdXNoKHtocmVmOmxpbmtzW2ldLmhyZWYsIHRleHQ6bGlua3NbaV0uaW5uZXJUZXh0fSk7XG5cdH1cblxuXHRyZXR1cm4gYXJyYXlPZk5hdkxpbmtzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBOYXZVcmxzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL3V0aWxzL25hdlVybHMuanMiXSwic291cmNlUm9vdCI6IiJ9